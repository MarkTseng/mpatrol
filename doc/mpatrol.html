<html lang="en"><head>
<title>mpatrol</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="mpatrol">
<meta name=generator content="makeinfo 4.0">
<link href="http://texinfo.org/" rel=generator-home>
</head><body>


<h1>Table of Contents</h1>
<ul>
<li><a href="#Top">mpatrol</a>
<li><a href="#Foreword">Foreword</a>
<li><a href="#Overview">1 Overview</a>
<li><a href="#Features">2 Features</a>
<li><a href="#Installation">3 Installation</a>
<li><a href="#Integration">4 Integration</a>
<li><a href="#Memory%20allocations">5 Memory allocations</a>
<ul>
<li><a href="#Static%20memory%20allocations">5.1 Static memory allocations</a>
<li><a href="#Stack%20memory%20allocations">5.2 Stack memory allocations</a>
<li><a href="#Dynamic%20memory%20allocations">5.3 Dynamic memory allocations</a>
</ul>
<li><a href="#Operating%20system%20support">6 Operating system support</a>
<ul>
<li><a href="#Virtual%20memory">6.1 Virtual memory</a>
<li><a href="#Call%20stacks%20and%20symbol%20tables">6.2 Call stacks and symbol tables</a>
<li><a href="#Threads">6.3 Threads</a>
</ul>
<li><a href="#Using%20mpatrol">7 Using mpatrol</a>
<ul>
<li><a href="#Library%20behaviour">7.1 Library behaviour</a>
<li><a href="#Logging%20and%20tracing">7.2 Logging and tracing</a>
<li><a href="#General%20errors">7.3 General errors</a>
<li><a href="#Overwrites%20and%20underwrites">7.4 Overwrites and underwrites</a>
<li><a href="#Using%20with%20a%20debugger">7.5 Using with a debugger</a>
<li><a href="#Testing">7.6 Testing</a>
<li><a href="#Library%20functions">7.7 Library functions</a>
<li><a href="#Utilities">7.8 Utilities</a>
<ul>
<li><a href="#The%20mpatrol%20command">7.8.1 The <code>mpatrol</code> command</a>
<li><a href="#The%20mleak%20command">7.8.2 The <code>mleak</code> command</a>
<li><a href="#The%20mpsym%20command">7.8.3 The <code>mpsym</code> command</a>
<li><a href="#The%20mpedit%20command">7.8.4 The <code>mpedit</code> command</a>
</ul>
</ul>
<li><a href="#Profiling">8 Profiling</a>
<li><a href="#Improving%20performance">9 Improving performance</a>
<li><a href="#How%20it%20works">10 How it works</a>
<li><a href="#Examples">11 Examples</a>
<ul>
<li><a href="#Example%201">11.1 Getting started</a>
<li><a href="#Example%202">11.2 Detecting incorrect reuse of freed memory</a>
<li><a href="#Example%203">11.3 Detecting use of free memory</a>
<li><a href="#Example%204">11.4 Using overflow buffers</a>
<li><a href="#Example%205">11.5 Bad memory operations</a>
<li><a href="#Example%206">11.6 Incompatible function calls</a>
<li><a href="#Example%207">11.7 The <code>alloca()</code> functions</a>
<li><a href="#Example%208">11.8 Additional useful information</a>
</ul>
<li><a href="#Tutorial">12 Tutorial</a>
<li><a href="#Functions">Appendix A Functions</a>
<li><a href="#Environment">Appendix B Environment</a>
<li><a href="#Options">Appendix C Options</a>
<li><a href="#Diagnostic%20messages">Appendix D Diagnostic messages</a>
<li><a href="#Library%20performance">Appendix E Library performance</a>
<li><a href="#File%20formats">Appendix F File formats</a>
<ul>
<li><a href="#Profiling%20file%20format">F.1 Profiling file format</a>
<li><a href="#Tracing%20file%20format">F.2 Tracing file format</a>
</ul>
<li><a href="#Supported%20systems">Appendix G Supported systems</a>
<ul>
<li><a href="#New%20system%20support">G.1 Adding a new operating system</a>
<li><a href="#New%20processor%20support">G.2 Adding a new processor architecture</a>
<li><a href="#New%20file%20format%20support">G.3 Adding a new object file format</a>
</ul>
<li><a href="#Notes">Appendix H Notes</a>
<ul>
<li><a href="#Generic%20notes">H.1 Notes for all platforms</a>
<li><a href="#UNIX%20notes">H.2 Notes for UNIX platforms</a>
<li><a href="#Amiga%20notes">H.3 Notes for Amiga platforms</a>
<li><a href="#Windows%20notes">H.4 Notes for Windows platforms</a>
<li><a href="#Netware%20notes">H.5 Notes for Netware platforms</a>
</ul>
<li><a href="#Frequently%20asked%20questions">Appendix I Frequently asked questions</a>
<ul>
<li><a href="#Documentation">I.1 Documentation</a>
<li><a href="#Building">I.2 Building</a>
<li><a href="#Linking">I.3 Linking</a>
<li><a href="#Running">I.4 Running</a>
<li><a href="#Files">I.5 Files</a>
</ul>
<li><a href="#Related%20software">Appendix J Related software</a>
<li><a href="#References">Appendix K References</a>
<li><a href="#Copying">Appendix L Copying</a>
<li><a href="#Function%20index">Function index</a>
<li><a href="#Index">Index</a>
</ul>

<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next href="#Foreword">Foreword</a>,
Up:<a rel=up href="#(dir)">(dir)</a>
<br>

<h1>mpatrol</h1>

<img src="images/mpatrol.jpg" alt="images/mpatrol.jpg">

<p>This document describes mpatrol, a library for controlling and tracing dynamic
memory allocations.

<p>This is edition 2.2 of the mpatrol manual for version
1.3.2, 13th December, 2000.

<ul>
<li><a href="#Foreword">Foreword</a>:                     Motivation and feedback. 
<li><a href="#Overview">Overview</a>:                     Overview of mpatrol. 
<li><a href="#Features">Features</a>:                     Features of mpatrol. 
<li><a href="#Installation">Installation</a>:                 Building and installing. 
<li><a href="#Integration">Integration</a>:                  Debugging existing programs. 
<li><a href="#Memory%20allocations">Memory allocations</a>:           Background. 
<li><a href="#Operating%20system%20support">Operating system support</a>:     Additional background. 
<li><a href="#Using%20mpatrol">Using mpatrol</a>:                Using the library. 
<li><a href="#Profiling">Profiling</a>:                    Memory allocation profiling. 
<li><a href="#Improving%20performance">Improving performance</a>:        Life beyond mpatrol. 
<li><a href="#How%20it%20works">How it works</a>:                 Implementation details. 
<li><a href="#Examples">Examples</a>:                     Examples of usage. 
<li><a href="#Tutorial">Tutorial</a>:                     Complete example. 
<li><a href="#Functions">Functions</a>:                    Library functions. 
<li><a href="#Environment">Environment</a>:                  Library run-time options. 
<li><a href="#Options">Options</a>:                      Command line options. 
<li><a href="#Diagnostic%20messages">Diagnostic messages</a>:          Warnings and errors. 
<li><a href="#Library%20performance">Library performance</a>:          Comparitive timings. 
<li><a href="#File%20formats">File formats</a>:                 Output file layouts. 
<li><a href="#Supported%20systems">Supported systems</a>:            Known platforms that mpatrol runs on. 
<li><a href="#Notes">Notes</a>:                        Known bugs and future enhancements. 
<li><a href="#Frequently%20asked%20questions">Frequently asked questions</a>:   For answering specific problems. 
<li><a href="#Related%20software">Related software</a>:             Similar programs. 
<li><a href="#References">References</a>:                   Additional information. 
<li><a href="#Copying">Copying</a>:                      GNU Library General Public License. 
<li><a href="#Function%20index">Function index</a>:               Library functions. 
<li><a href="#Index">Index</a>:                        Main index. 
</ul>

<p><hr>
Node:<a name="Foreword">Foreword</a>,
Next:<a rel=next href="#Overview">Overview</a>,
Previous:<a rel=previous href="#Top">Top</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Foreword</h1>

<p>I first started writing this library a few years ago when the company I work for
sent me out to a customer who had reported a memory leak, which he expected was
coming from the code generated by our C++ compiler.  A few years on and the
library has changed dramatically from its first beginnings, but I thought I'd
release it publicly in case anyone else found it useful.

<p>When writing the library, I placed more emphasis on the quantity and quality of
information about allocated memory rather than the speed and efficiency of
allocating the actual memory.  This means that the library will use dramatically
more memory than normal dynamic memory allocation libraries and can slow down to
a crawl depending on which options you use.  However, the end results are likely
to be accurate and reliable, and in most cases the library will run quite
happily at a sane speed.

<p>The mpatrol library is by no means the only library of its kind.  Solaris has
no less that 6 different malloc libraries, and there are plenty available as
freeware or as commercial products.  Try to keep in mind that mpatrol comes with
absolutely no warranty and so if it doesn't work for you and you need a fast
solution, try some of the other libraries or products available.  I have listed
some of the most popular at the end of this manual (see <a href="#Related%20software">Related software</a>).

<p>This manual is arranged so that complete reference material on the mpatrol
library can be found in the appendices, while introductory and background
material can be found in the preceding chapters and sections.  For readers who
wish to delve right in and use the library, the Installation
(see <a href="#Installation">Installation</a>) and Examples (see <a href="#Examples">Examples</a>) chapters should be enough
to get started in combination with the quick reference card.  Otherwise, this
manual should be read from beginning to end in order to get the most out of the
software it describes.  Note that all of the output shown from the examples was
produced on 32-bit environments, although mpatrol can be built to support 64-bit
environments as well.

<p>Due to their very nature, problems with dynamic memory allocations are
notoriously difficult to reproduce and debug, and this is likely to be the case
if you find a bug in the mpatrol library as it might be extremely hard to
reproduce on another system.  Details on how to report bugs are given elsewhere
in this document (see <a href="#Notes">Notes</a>), but it would be very useful if you could try
to provide as much information as possible when reporting a problem, and that
includes having a look in the library source code to see if it's obvious what is
wrong.  However, please try to read the frequently asked questions
(see <a href="#Frequently%20asked%20questions">Frequently asked questions</a>) first in case your question or problem is
covered there since they are usually updated every time I receive a question
about mpatrol.

<p>The latest version of the mpatrol library and this manual can always be found at
<a href="http://www.cbmamiga.demon.co.uk/mpatrol/">http://www.cbmamiga.demon.co.uk/mpatrol/</a>, and any correspondence relating
to mpatrol (bug reports, enhancement requests, compliments, etc.) should be sent
to <a href="mailto:mpatrol@cbmamiga.demon.co.uk">mpatrol@cbmamiga.demon.co.uk</a>.  I'd be very interested in hearing any
success stories with using mpatrol to debug programs, since I get very little
feedback apart from the occasional bug report.  The mpatrol library is also
registered at FreshMeat (<a href="http://freshmeat.net/">http://freshmeat.net/</a>) and several other
software sites so you can receive notification of updates there as well.  I
normally only check my e-mail about once or twice a week, so don't expect an
immediate response.  I can also be reached at <a href="mailto:graeme@epc.co.uk">graeme@epc.co.uk</a> but that
is my work e-mail address.  There is now also a discussion group at
<a href="http://www.egroups.com/group/mpatrol/">http://www.egroups.com/group/mpatrol/</a> where you can post mpatrol-related
questions but you must first subscribe to the group before you can send mail to
it.

<p>Finally, I'd like to thank Stephan Springl (<a href="mailto:springl@bfw-online.de">springl@bfw-online.de</a>) for
his help on reading debugging information from object files via the GNU BFD
library, and Alexander Barton (<a href="mailto:abarton@innotrac.com">abarton@innotrac.com</a>) and Dave Gibson
(<a href="mailto:david@epc.co.uk">david@epc.co.uk</a>) for their help on writing thread-safe code.

<p>Oh, and always remember to do final release builds without the mpatrol library
as the library is much slower than normal malloc implementations and uses much
more memory.

<p>Happy debugging!

<p>Graeme Roy, 11th October, 1999.

<p>Edinburgh, Scotland.

<p><hr>
Node:<a name="Overview">Overview</a>,
Next:<a rel=next href="#Features">Features</a>,
Previous:<a rel=previous href="#Foreword">Foreword</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>1 Overview</h1>

<p>The mpatrol library is yet another link library that attempts to diagnose
run-time errors that are caused by the wrong use of dynamically allocated
memory.  If you don't know what the <code>malloc()</code> function or <code>operator
new[]</code> do then this library is probably not for you.  You have to have a certain
amount of programming expertise and a knowledge of how to run a command line
compiler and linker before you should attempt to use this.

<p>Along with providing a comprehensive and configurable log of all dynamic memory
operations that occurred during the lifetime of a program, the mpatrol library
performs extensive checking to detect any misuse of dynamically allocated
memory.  All of this functionality can be integrated into existing code through
the inclusion of a single header file at compile-time.  On UNIX and Windows
platforms (and AmigaOS when using <code>gcc</code>) this may not even be necessary
as the mpatrol library can be linked with existing object files at link-time or,
on some platforms, even dynamically linked with existing programs at run-time.

<p>All logging and tracing output from the mpatrol library is sent to a separate
log file in order to keep its diagnostics separate from any that the program
being tested might generate.  A wide variety of library settings can also be
changed at run-time via an environment variable, thus removing the need to
recompile or relink in order to change the library's behaviour.

<p>A file containing a summary of the memory allocation profiling statistics for a
particular program can be produced by the mpatrol library.  This file can then
be read by a profiling tool which will display a set of tables based upon the
accumulated data.  The profiling information includes summaries of all of the
memory allocations listed by size and the function that allocated them and a
list of memory leaks with the call stack of the allocating function.  It also
includes a graph of all memory allocations listed in tabular form, and an
optional graph specification file for later processing by the <code>dot</code>
graph visualisation package.

<p>A file containing a concise encoded trace of all memory allocations and
deallocations made by a program can also be produced by the mpatrol library. 
This file can then be read by a tracing tool which will decode the trace and
display the events in tabular or graphical form, and also display any relevant
statistics that could be calculated.

<p>The mpatrol library has been designed with the intention of replacing calls to
existing C and C++ memory allocation functions as seamlessly as possible, but
in many cases that may not be possible and slight code modifications may be
required.  However, a preprocessor macro containing the version of the mpatrol
library is provided for the purposes of conditional compilation so that release
builds and debug builds can be easily automated.

<p><hr>
Node:<a name="Features">Features</a>,
Next:<a rel=next href="#Installation">Installation</a>,
Previous:<a rel=previous href="#Overview">Overview</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>2 Features</h1>

<p>An overall list of features contained in the mpatrol library is given below. 
This is not intended to be exhaustive since the best way to see what the library
does is to read the documentation and try it out.

<ul>
<li>Written for 32-bit and 64-bit UNIX, AmigaOS, Windows and Netware platforms.

<li>Can be built to allocate memory from a fixed-sized static array rather than
using heap memory from the system.

<li>Can be built as archive, shared and/or thread-safe libraries on systems that
support them, or even as one large object file.  A lint library can also be
built from the mpatrol library on UNIX platforms.

<li>Details of memory allocations and free memory are stored internally as a tree
structure for speed and also to allow the best fit allocation algorithm to be
used.  This also enables the library to perform intelligent resizing of memory
allocations and can be used to quickly determine if an address has been
allocated on the heap.

<li>Contains 18 replacement C dynamic memory allocation functions:

<p><table><tr align="left"><td><code>malloc()</code>
<td>ANSI
<td>Allocates memory. 
<br></tr><tr align="left"><td><code>calloc()</code>
<td>ANSI
<td>Allocates zero-filled memory. 
<br></tr><tr align="left"><td><code>memalign()</code>
<td>UNIX
<td>Allocates memory with a specified alignment. 
<br></tr><tr align="left"><td><code>valloc()</code>
<td>UNIX
<td>Allocates page-aligned memory. 
<br></tr><tr align="left"><td><code>pvalloc()</code>
<td>UNIX
<td>Allocates a number of pages. 
<br></tr><tr align="left"><td><code>alloca()</code>
<td>old
<td>Allocates temporary memory. 
<br></tr><tr align="left"><td><code>strdup()</code>
<td>UNIX
<td>Duplicates a string. 
<br></tr><tr align="left"><td><code>strndup()</code>
<td>old
<td>Duplicates a string with a maximum length. 
<br></tr><tr align="left"><td><code>strsave()</code>
<td>old
<td>Duplicates a string. 
<br></tr><tr align="left"><td><code>strnsave()</code>
<td>old
<td>Duplicates a string with a maximum length. 
<br></tr><tr align="left"><td><code>strdupa()</code>
<td>old
<td>Duplicates a string. 
<br></tr><tr align="left"><td><code>strndupa()</code>
<td>old
<td>Duplicates a string with a maximum length. 
<br></tr><tr align="left"><td><code>realloc()</code>
<td>ANSI
<td>Resizes memory. 
<br></tr><tr align="left"><td><code>recalloc()</code>
<td>old
<td>Resizes memory allocated by <code>calloc()</code>. 
<br></tr><tr align="left"><td><code>expand()</code>
<td>old
<td>Resizes memory but does not relocate it. 
<br></tr><tr align="left"><td><code>free()</code>
<td>ANSI
<td>Frees memory. 
<br></tr><tr align="left"><td><code>cfree()</code>
<td>old
<td>Frees memory allocated by <code>calloc()</code>. 
<br></tr><tr align="left"><td><code>dealloca()</code>
<td>new
<td>Explicitly frees temporary memory.
<br></tr></table>

<li>Contains 4 replacement C++ dynamic memory allocation operators:

<p><table><tr align="left"><td><code>operator new</code>
<td>Allocates memory. 
<br></tr><tr align="left"><td><code>operator new[]</code>
<td>Allocates memory for an array. 
<br></tr><tr align="left"><td><code>operator delete</code>
<td>Frees memory. 
<br></tr><tr align="left"><td><code>operator delete[]</code>
<td>Frees memory allocated by <code>operator new[]</code>.
<br></tr></table>

<li>Contains 10 replacement C memory operation functions:

<p><table><tr align="left"><td><code>memset()</code>
<td>ANSI
<td>Fills memory with a specific byte. 
<br></tr><tr align="left"><td><code>bzero()</code>
<td>UNIX
<td>Fills memory with the zero byte. 
<br></tr><tr align="left"><td><code>memccpy()</code>
<td>UNIX
<td>Copies memory up to a specific byte. 
<br></tr><tr align="left"><td><code>memcpy()</code>
<td>ANSI
<td>Copies non-overlapping memory. 
<br></tr><tr align="left"><td><code>memmove()</code>
<td>ANSI
<td>Copies possibly-overlapping memory. 
<br></tr><tr align="left"><td><code>bcopy()</code>
<td>UNIX
<td>Copies possibly-overlapping memory. 
<br></tr><tr align="left"><td><code>memcmp()</code>
<td>ANSI
<td>Compares two blocks of memory. 
<br></tr><tr align="left"><td><code>bcmp()</code>
<td>UNIX
<td>Compares two blocks of memory. 
<br></tr><tr align="left"><td><code>memchr()</code>
<td>ANSI
<td>Searches memory for a specific byte. 
<br></tr><tr align="left"><td><code>memmem()</code>
<td>UNIX
<td>Searches memory for specific bytes.
<br></tr></table>

<li>All of the above functions can also be defined with an additional underscore
prepended to their external name in order to catch all uses of these functions
in the system and third-party libraries.

<li>Contains support for a user-defined low-memory handler function, including a
replacement for the C++ function, <code>set_new_handler()</code>.

<li>The C++ dynamic memory allocation operators make use of the preprocessor in
order to obtain source-level information.  If this causes problems then
replacement operator names may be used so that the existing operators will still
work.

<li>Contains support for user-defined prologue and epilogue callback functions,
which get called before and after every memory allocation, reallocation or
deallocation.

<li>A function is provided to return as much information as possible about a given
memory allocation, and can be called at any time during program execution.  A
similar function is also provided for calling from within a debugger and an
example command file is provided for use with <code>gdb</code>.

<li>A function is provided to display library settings and heap usage statistics,
including peak memory usage.  This information is also displayed at program
termination.

<li>The library reads any user-controllable options at run-time from an environment
variable, but this does not have to be set as defaults will then be used.  This
prevents having to recompile anything in order to change any library settings. 
An option exists to display a quick-reference summary of all of the recognised
options to the standard error file stream.

<li>All diagnostics and logging are sent to a file in the current directory, but
this can be overridden, including forcing the log file to be the standard output
or standard error file streams.  An environment variable specifying a default
directory in which to place log files can also be set.

<li>Options exist to log details of every memory allocation, reallocation or
deallocation when they occur.

<li>Options exist to halt the program at a specific memory allocation, reallocation
or deallocation when running the program within a debugger.  These options have
no effect when running the program without a debugger.

<li>An option exists to enable memory allocation profiling, which forces a summary
of all memory allocation statistics to be written to a specified file for later
use by a profiling command.  The profiling file can also be written at a
specified frequency.  An environment variable specifying a default directory in
which to place profiling output files can also be set.

<li>A profiling command is provided which reads a profiling output file produced by
the mpatrol library and displays a set of tables based on the accumulated data. 
The profiling information includes summaries of all of the memory allocations
listed by size and the function that allocated them and a list of memory leaks
with the call stack of the allocating function.  It also includes a graph of all
memory allocations listed in tabular form, and an optional graph specification
file for later processing by the <code>dot</code> graph visualisation package.

<li>An option exists to enable memory allocation tracing, which forces certain
details for every memory allocation event to be written to a specified file for
later use by a tracing command.  The tracing file is written in a concise
encoded form so as to keep the size of the file down.  An environment variable
specifying a default directory in which to place tracing output files can also
be set.

<li>A tracing command is provided which reads a tracing output file produced by the
mpatrol library and displays the memory allocation events in tabular or
graphical form.  It also displays any relevant statistics that could be
calculated.

<li>On UNIX platforms, the <code>mmap()</code> function can optionally be used to allocate
memory instead of the <code>sbrk()</code> function, but only if the system supports
it.  This can be useful if the mpatrol library clashes with another malloc
library that uses <code>sbrk()</code> to allocate heap memory.

<li>On non-UNIX platforms where the mpatrol library overrides <code>malloc()</code>
without requiring the inclusion of <code>mpatrol.h</code>, versions of the UNIX
functions <code>brk()</code> and <code>sbrk()</code> are provided for compatibility with
certain libraries.  These should <em>not</em> be called by user code as they have
only limited functionality.

<li>All newly-allocated memory that is not allocated by the <code>calloc()</code> or
<code>recalloc()</code> functions will be pre-filled with a non-zero value in order to
catch out programs that wrongly assume that all newly-allocated memory is
zeroed.  This value can be modified at run-time.

<li>Can automatically check to see if there have been any illegal writes to bytes
located just before and after every memory allocation through the use of
overflow buffers.  The size of such overflow buffers and the value to pre-fill
them with can be modified at run-time.  The checks will be performed before
every memory allocation call to ensure that nothing has overwritten the
overflow buffers, but a function is also provided to perform additional checks
under the programmer's control and an option exists to specify a range in which
checks will be performed.

<li>On systems that support them, watch point areas can be used instead of overflow
buffers so that every read and write to memory is checked to ensure that it is
not within an overflow buffer.

<li>Can automatically check to see if there have been any illegal writes to free
memory blocks.  The value to pre-fill free memory blocks with can be modified
at run-time.  The check will be performed before every memory allocation call
to ensure that nothing has overwritten the free memory block, but a function is
also provided to perform additional checks under the programmer's control and
an option exists to specify a range in which checks will be performed.

<li>On systems that support memory protection, every memory allocation can
optionally be allocated at least one page of memory.  That way, any free memory
blocks can be made read and write protected so that nothing can access free
memory on the heap.  An option is provided to specify whether all memory
allocations should be allocated at the start or at the end of such pages, and
the bytes left over within the pages become overflow buffers.

<li>All freed memory allocations can optionally be prevented from being returned to
the free memory pool.  This is useful for detecting if use is being made of
freed memory just after a memory allocation has been freed.  The contents of
the memory allocation can either be preserved or can be pre-filled with a value
in order to detect illegal writes to the freed memory allocation.  In addition,
only a specified number of recently-freed memory allocations can be prevented
from being returned to the free memory pool.  Any older freed memory allocations
will then eventually be reused.

<li>The <code>alloca()</code>, <code>strdupa()</code> and <code>strndupa()</code> functions are
implemented so that the temporary stack-based allocations that they would
normally make are now temporary heap-based allocations that can be traced by
mpatrol.  Such allocations will be implicitly freed when the function that
allocated them returns, but a function also exists to explicitly free them as
well.

<li>Calls to memory operation functions (such as <code>memset()</code> or <code>memcpy()</code>)
have their arguments checked to ensure that they do not pass null pointers or
attempt to read or write memory straddling the boundary of a previously
allocated memory block, although an option exists to turn such an error into a
warning so that the operation can still be performed.  Tracing from all such
functions can also optionally be written to the log file.

<li>The internal data structures used by the library are kept separate from the
rest of the memory allocations.  On systems that support memory protection, all
of these internal data structures will be write-protected in order to prevent
corruption by the calling program.  This feature can be overridden at run-time
as it can slow the program down.

<li>Certain signals can be saved and restored on entry to each library function and
<code>errno</code> is set to <code>ENOMEM</code> if memory cannot be allocated.

<li>On systems that support memory protection, the library attempts to detect any
illegal memory accesses and display as much information as it can obtain about
the address in question and where the illegal memory access occurred.

<li>A call stack traceback from any function performing a memory allocation is
stored if the library supports this feature on the system it is being run on. 
This information can then be displayed when information about a specific memory
allocation is required.  Many different call stack traceback implementations are
provided for different platforms.

<li>Symbol table details from executable files and shared libraries are
automatically read on systems that support this feature in order to make the
call stack tracebacks more meaningful.  An option also exists to display a
complete list of the symbols that were read by the library at program
termination.

<li>Compiler-generated line number tables from any debugging sections that exist
in executable files and shared libraries can also be used by the mpatrol library
in order to provide more meaningful information in call stack tracebacks.  An
external command is also provided to make use of a debugger to get such
information if one is available.

<li>If the library is unable to automatically determine a program's executable
filename to read symbols from then an option exists to specify the full path to
the program's executable file.

<li>Options are provided to edit and list a source file at a specific line number
when a warning or error occurs due to that source line.  An external command
which provides this functionality outwith the mpatrol library is included.

<li>An option exists to change the default alignment used for general-purpose memory
allocations.

<li>Contains support for a user-defined limit to available memory which can be
useful for stress-testing a program in simulated low memory conditions.

<li>Contains a feature to randomly fail a specific frequency of memory allocations
which can be useful for stress-testing error recovery code in a program.

<li>An option exists to display a complete memory map of the heap at program
termination.  A function to do this is also available to call at any point
during program execution.

<li>Options exist to display all freed and unfreed memory allocations at program
termination in order to detect memory leaks, as well as all free memory blocks. 
A separate program is also provided for locating memory leaks in unfinished log
files.

<li>An option exists to abort the program with a failure condition if there are more
than a specified number of unfreed memory allocations at program termination. 
This could be useful for batch testing in order to check that all tests free up
most of their allocated memory.

<li>Functions always report if their arguments are illegal in order to pinpoint any
errors, and options exist to perform rigorous checking of arguments when
allocating, reallocating and freeing memory.  In addition, checking is performed
to ensure that memory allocated by <code>operator new[]</code> is not freed with
<code>free()</code> for example.

<li>The type of function performing a memory allocation is always stored along with
the allocation, as well as the file and line number it was called from.  If
compiled with <code>gcc</code>, the function name will also be stored and the
thread identifier will be stored if using the thread-safe library.

<li>The library uses a header file to redefine the memory allocation functions as
macros in order to obtain more information about where they were called from. 
This is not strictly required on UNIX and Windows platforms (and AmigaOS when
using <code>gcc</code>), since the library automatically redefines the default
system memory allocation functions.  All redefinitions in the header can also
be disabled by defining the <code>NDEBUG</code> preprocessor macro.

<li>A command is supplied to run a program that was linked with the mpatrol library
with any specified options on the command line.  On some UNIX platforms, an
option also exists to override the default memory allocation routines for any
dynamically-linked program that was not previously linked with the mpatrol
library.

<li>The mpatrol library can be built to liaise with Parasoft Inuse, a commercial
graphical memory usage tool that can display the current memory map of a running
process.  Inuse is supplied with Parasoft Insure++.

<li>Build scripts are supplied to build both installation packages and binary
distributions.  A Linux Software Map file is also provided.

<li>A small test suite is provided in order to test basic features.

<li>User documentation is currently available in TeXinfo format as well as UNIX
manual pages and a quick reference card. 
</ul>

<p><hr>
Node:<a name="Installation">Installation</a>,
Next:<a rel=next href="#Integration">Integration</a>,
Previous:<a rel=previous href="#Features">Features</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>3 Installation</h1>

<p>The mpatrol library was initially developed on an Amiga 4000/040 running AmigaOS
3.1.  I then installed Red Hat Linux 5.1 on my Amiga and added support for
Linux/m68k.  I've now just recently purchased a Dell Inspiron 7500 Notebook PC
and put my Amiga in retirement, so development will now continue on Red Hat
Linux 6.2 and above on the Intel platform.  I've tried my best to make it as
easy as possible to build and install mpatrol on any system, but it isn't
likely to run smoothly for everybody.  However, there shouldn't be any major
problems if you perform the following steps.

<ol type=1 start=1>
</p><li>Go into the <code>build</code> directory and then into the appropriate subdirectory
for your system.

<li>Edit the <code>Makefile</code> in that directory and check that it is using the
appropriate compiler and build tools.  The <code>CC</code> macro specifies the
compiler, the <code>AR</code> macro specifies the tool used to build the archive
library and the <code>LD</code> macro specifies the tool to build the shared library. 
The <code>CFLAGS</code> macro specifies compiler options that are always to be used,
the <code>OFLAGS</code> macro specifies optimisation options for the compiler, the
<code>SFLAGS</code> macro specifies options to be passed to the compiler when building
a shared library and the <code>TFLAGS</code> macro specifies options to be passed to
the compiler when building a thread-safe library.  You may also need to change
the library names and library build commands on different systems.

<li>Use the <code>make</code> command (or equivalent) to build the mpatrol library in
archive form.  The <code>all</code> target builds all possible combinations of the
mpatrol library for your system.  The <code>clean</code> target removes all relevant
object files from the current directory, while the <code>clobber</code> target also
removes all libraries that have been built from the current directory.  On some
UNIX platforms, the <code>lint</code> target will build a <code>lint</code> library for
the mpatrol library.

<li>If the mpatrol library is to be built with support for Parasoft Inuse then the
<code>MP_INUSE_SUPPORT</code> preprocessor macro must be defined in the
<code>CFLAGS</code> portion of the <code>Makefile</code> before building.  This will ensure
that Inuse will be notified of every memory allocation, reallocation and
deallocation, but the Insure++ runtime library will also have to be linked in
with any program that uses mpatrol.

<li>Copy all of the libraries that have been built into your local library
directory.  If there were symbolic links created in the <code>build</code> directory
then these should be recreated in the local library directory rather than simply
copying them.

<li>Copy the <code>mpatrol</code>, <code>mprof</code>, <code>mptrace</code> and
<code>mleak</code> programs that have been built into your local bin directory. 
You may also wish to copy the <code>mpsym</code> and <code>mpedit</code> commands to
your local bin directory as well if your system supports Bourne shell scripts.

<li>Go up two directory levels into the <code>src</code> directory and copy the
<code>mpatrol.h</code> header file into your local include directory.

<li>On UNIX platforms, go up one directory level into the <code>man</code> directory and
copy the <code>man1</code> and <code>man3</code> subdirectories to your local man directory. 
Unfortunately, the location for manual pages varies from system to system so you
may or may not also be able to copy the <code>cat1</code> and <code>cat3</code>
subdirectories as well.  The <code>man*</code> subdirectories contain the unformatted
manual pages while the <code>cat*</code> subdirectories contain the formatted manual
pages.

<li>Go up one directory level into the <code>doc</code> directory and examine the files
located there.  The <code>mpatrol.texi</code> file contains the TeXinfo source for
this manual and can be translated into a wide variety of documentation formats. 
The <code>refcard.tex</code> file contains the LaTeX source for the quick reference
card and can be translated into formats suitable for printing onto a single
page.  There may already be translated files in the <code>doc</code> directory, but if
not you will either have to generate them yourself using an appropriate tool or
you could download an archive containing the latest mpatrol manual and reference
card in a variety of documentation formats from the mpatrol home page.  You can
then install or print these documents.
</ol>

<p>Alternatively, the <code>pkg</code> directory contains files that can be used to
automatically generate a <em>package</em> in a specific format suitable for
installation on a system.  Three package formats (PKG, SD/UX and RPM) and three
archive formats are currently supported (generic tape archive, LhA and ZIP). 
The first package format is generally used on UNIX SVR4 systems, while the
second is used on HP/UX systems and the third was introduced by Red Hat for use
in their Linux distributions.  The generic tape archive can be used as a
distribution for UNIX systems where no package format is supported, but it does
not contain information on how to install the files on the system once they
have been extracted from the distribution.  The LhA and ZIP formats are also
roughly the same, but the LhA format is intended for Amiga systems and is used
for Aminet distributions, while the ZIP format is intended for Windows systems
and is used for WinSite distributions.  You should really know what you are
doing before you attempt to build a package, and you should also be aware that
some of the package files may need to be modified before you begin.

<p>In addition, a Linux Software Map index file exists in the <code>pkg/lsm</code>
directory.

<p><hr>
Node:<a name="Integration">Integration</a>,
Next:<a rel=next href="#Memory%20allocations">Memory allocations</a>,
Previous:<a rel=previous href="#Installation">Installation</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>4 Integration</h1>

<p>The following steps should allow you to easily integrate the mpatrol library
into an existing application, although some of them may not be available to do
on many platforms.  They are listed in the order of number of changes required
to modify existing code -- the last step will require a complete recompilation
of all your code.

<ol type=1 start=1>
</p><li>This step is currently only available on DYNIX/ptx, IRIX, Linux and Solaris
platforms and on DG/UX 4.20MU07<a rel=footnote href="#fn-1"><sup>1</sup></a> or
later platforms with the <code>LD_PRELOAD</code> feature.

<p>If your program or application has been dynamically linked with the system C
library (<code>libc.so</code>) or an alternative malloc shared library then you can
use the <code>--dynamic</code> option to the <code>mpatrol</code> command to override the
default definitions of <code>malloc()</code>, etc. at run-time without having to
relink your program.  If your program is multithreaded then you must also add
the <code>--threads</code> option to pick up the multithreaded shared libraries
instead.

<p>For example, if your program's executable file is called <code>testprog</code> and it
accepts an option specifying an input file, you can force the system's dynamic
linker to use mpatrol's versions of <code>malloc()</code>, etc. instead of the
default versions by typing:

<pre>mpatrol --dynamic ./testprog -i file
</pre>

<p>The resulting log file should be called <code>mpatrol.&lt;procid&gt;.log</code> by default
(where <var>procid</var> is the current process id), but if no such file exists after
running the <code>mpatrol</code> command then it will not be possible to force the
run-time linking of mpatrol functions to your program and you will have to
proceed to the next step.  Note that the <code>mpatrol</code> command overrides
any previous setting of the <code>MPATROL_OPTIONS</code> environment variable.

</p><li>This step is currently only available on UNIX and Windows platforms (and AmigaOS
when using <code>gcc</code>).

<p>You should be able to link in the mpatrol library when linking your program
without having to recompile any of your object files or libraries, but this will
only be worthwhile on systems where stack tracebacks are supported, otherwise
you should proceed to the next step since there will not be enough information
for you to tell where the calls to dynamic memory allocation functions took
place.

<p>Information on how to link the mpatrol library to an application is given at the
start of the examples (see <a href="#Examples">Examples</a>), but you should note that if your
program does not directly call any of the functions in the mpatrol library then
it will not be linked in and you will not see a log file being generated when
you run it.  You can force the linking of the mpatrol library by causing
<code>malloc()</code> to be undefined on the link line, usually through the use of the
<code>-u</code> linker option.

</p><li>All of the following steps will require you to recompile some or all of your
code so that your code calls dynamic memory allocation functions from the
mpatrol library rather than the system C library.

<p>For this step, if you have a rough idea of where the function calls lie that you
would like to trace or test, you need only recompile the relevant source files. 
You should modify these source files to include the <code>mpatrol.h</code> header file
before any calls to dynamic memory allocation or memory operation functions.

<p>However, you should take particular care to ensure that all calls to memory
allocation functions in the mpatrol library will be matched by calls to memory
reallocation or deallocation functions in the mpatrol library, since if they are
unmatched then the log file will either fill up with errors complaining about
trying to free unknown allocations, or warnings about unfreed memory allocations
at the end of execution.

</p><li>This step requires you to recompile all of your source files to include the
<code>mpatrol.h</code> header file.  Obviously, this will take the longest amount of
time to integrate, but need not require you to change any source files if the
compiler you are using has a command line option to include a specific header
file before any source files.

<p>For example, <code>gcc</code> comes with a <code>-include</code> option which has this
feature, so if you had to recompile a source file called <code>test.c</code> then the
following command would allow you to include <code>mpatrol.h</code> without having
to modify the source file:

<pre>gcc -include /usr/local/include/mpatrol.h -c test.c
</pre>
</ol>

<p>In all cases, it will be desirable to compile your source files with
compiler-generated debugging information since that may be able to be used by
the <code>USEDEBUG</code> option or the <code>mpsym</code> command.  In addition, more
symbolic information will be available if the executable files have not had
their symbol tables stripped from them, although mpatrol can also fall back to
using the dynamic symbol table from dynamically linked executable files.

<p><hr>
Node:<a name="Memory%20allocations">Memory allocations</a>,
Next:<a rel=next href="#Operating%20system%20support">Operating system support</a>,
Previous:<a rel=previous href="#Integration">Integration</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>5 Memory allocations</h1>

<p>In the C and C++ programming languages there are generally three different types
of memory allocation that can be used to hold the contents of variables.  Other
programming languages such as Pascal, BASIC and FORTRAN also support some of
these types of allocation, although their implementations may be slightly
different.

<ul>
<li><a href="#Static%20memory%20allocations">Static memory allocations</a>:    Fixed location, fixed size. 
<li><a href="#Stack%20memory%20allocations">Stack memory allocations</a>:     Variable location, fixed size. 
<li><a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>:   Variable location, variable size. 
</ul>

<p><hr>
Node:<a name="Static%20memory%20allocations">Static memory allocations</a>,
Next:<a rel=next href="#Stack%20memory%20allocations">Stack memory allocations</a>,
Up:<a rel=up href="#Memory%20allocations">Memory allocations</a>
<br>

<h2>5.1 Static memory allocations</h2>

<p>The first type of memory allocation is known as a <em>static memory
allocation</em>, which corresponds to file scope variables and local static
variables.  The addresses and sizes of these allocations are fixed at the time
of compilation<a rel=footnote href="#fn-2"><sup>2</sup></a> and so they can be
placed in a fixed-sized data area which then corresponds to a section within the
final linked executable file.  Such memory allocations are called static because
they do not vary in location or size during the lifetime of the program.

<p>There can be many types of data sections within an executable file; the three
most common are normal data, BSS data and read-only data.  BSS data contains
variables and arrays which are to be initialised to zero at run-time and so is
treated as a special case, since the actual contents of the section need not be
stored in the executable file.  Read-only data consists of constant variables
and arrays whose contents are guaranteed not to change when a program is being
run.  For example, on a typical SVR4 UNIX system the following variable
definitions would result in them being placed in the following sections:

<pre>int a;           /* BSS data */
int b = 1;       /* normal data */
const int c = 2; /* read-only data */
</pre>

<p>In C the first example would be considered a <em>tentative</em> declaration, and
if there was no subsequent definition of that variable in the current
translation unit then it would become a <em>common</em> variable in the resulting
object file.  When the object file gets linked with other object files, any
common variables with the same name become one variable, or take their
definition from a non-tentative definition of that variable.  In the former
case, the variable is placed in the BSS section.  Note that C++ has no support
for tentative declarations.

<p>As all static memory allocations have sizes and address offsets that are known
at compile-time and are explicitly initialised, there is very little that can go
wrong with them.  Data can be read or written past the end of such variables,
but that is a common problem with all memory allocations and is generally easy
to locate in that case.  On systems that separate read-only data from normal
data, writing to a read-only variable can be quickly diagnosed at run-time.

<p><hr>
Node:<a name="Stack%20memory%20allocations">Stack memory allocations</a>,
Next:<a rel=next href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>,
Previous:<a rel=previous href="#Static%20memory%20allocations">Static memory allocations</a>,
Up:<a rel=up href="#Memory%20allocations">Memory allocations</a>
<br>

<h2>5.2 Stack memory allocations</h2>

<p>The second type of memory allocation is known as a <em>stack memory
allocation</em>, which corresponds to non-static local variables and call-by-value
parameter variables.  The sizes of these allocations are fixed at the time of
compilation but their addresses will vary depending on when the function which
defines them is called.  Their contents are not immediately initialised, and
must be explicitly initialised by the programmer upon entry to the function or
when they become visible in scope.

<p>Such memory allocations are placed in a system memory area called the
<em>stack</em>, which is allocated per process<a rel=footnote href="#fn-3"><sup>3</sup></a> and generally grows down in memory.  When a function is called, the
state of the calling function must be preserved so that when the called function
returns, the calling function can resume execution.  That state is stored on the
stack, including all local variables and parameters.  The compiler generates
code to increase the size of the stack upon entry to a function, and decrease
the size of the stack upon exit from a function, as well as saving and restoring
the values of registers.

<p>There are a few common problems using stack memory allocations, and most
generally involve uninitialised variables, which a good compiler can usually
diagnose at compile-time.  Some compilers also have options to initialise all
local variables with a bit pattern so that uninitialised stack variables will
cause program faults at run-time.  As with static memory allocations, there can
be problems with reading or writing past the end of stack variables, but as
their sizes are fixed these can usually easily be located.

<p><hr>
Node:<a name="Dynamic%20memory%20allocations">Dynamic memory allocations</a>,
Previous:<a rel=previous href="#Stack%20memory%20allocations">Stack memory allocations</a>,
Up:<a rel=up href="#Memory%20allocations">Memory allocations</a>
<br>

<h2>5.3 Dynamic memory allocations</h2>

<p>The last type of memory allocation is known as a <em>dynamic memory
allocation</em>, which corresponds to memory allocated via <code>malloc()</code> or
<code>operator new[]</code>.  The sizes, addresses and contents of such memory vary
at run-time and so can cause a lot of problems when trying to diagnose a fault
in a program.  These memory allocations are called dynamic memory allocations
because their location and size can vary throughout the lifetime of a program.

<p>Such memory allocations are placed in a system memory area called the
<em>heap</em>, which is allocated per process on some systems, but on others may
be allocated directly from the system in scattered blocks.  Unlike memory
allocated on the stack, memory allocated on the heap is not freed when a
function or scope is exited and so must be explicitly freed by the programmer. 
The pattern of allocations and deallocations is not guaranteed to be (and is not
really expected to be) linear and so the functions that allocate memory from the
heap must be able to efficiently reuse freed memory and resize existing
allocated memory on request.  In some programming languages there is support for
a <em>garbage collector</em>, which attempts to automatically free memory that has
had all references to it removed, but this has traditionally not been very
popular for programming languages such as C and C++, and has been more widely
used in functional languages like ML<a rel=footnote href="#fn-4"><sup>4</sup></a>.

<p>Because dynamic memory allocations are performed at run-time rather than
compile-time, they are outwith the domain of the compiler and must be
implemented in a run-time package, usually as a set of functions within a
linker library.  Such a package manages the heap in such a way as to abstract
its underlying structure from the programmer, providing a common interface to
heap management on different systems.  However, this <em>malloc library</em> must
decide whether to implement a fast memory allocator, a space-conserving memory
allocator, or a bit of both.  It must also try to keep its own internal tables
to a minimum so as to conserve memory, but this means that it has very little
capability to diagnose errors if any occur.

<p>In some compiler implementations there is a builtin function called
<code>alloca()</code>.  This is a dynamic memory allocation function that allocates
memory from the stack rather than the heap, and so the memory is automatically
freed when the function that called it returns.  This is a non-standard feature
that is not guaranteed to be present in a compiler, and indeed may not be
possible to implement on some systems<a rel=footnote href="#fn-5"><sup>5</sup></a>.  However,
the mpatrol library provides a debugging version of this function (and a few
other related functions) on all systems, so that they make use of the heap
instead of the stack.

<p>As can be seen from the above paragraphs, dynamic memory allocations are the
types of memory allocations that can cause the most problems in a program since
almost nothing about them can be used by the compiler to give the programmer
useful warnings about using uninitialised variables, using freed memory, running
off the end of a dynamically-allocated array, etc.  It is these types of memory
allocation problems that the mpatrol library loves to get its teeth into!

<p><hr>
Node:<a name="Operating%20system%20support">Operating system support</a>,
Next:<a rel=next href="#Using%20mpatrol">Using mpatrol</a>,
Previous:<a rel=previous href="#Memory%20allocations">Memory allocations</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>6 Operating system support</h1>

<p>Beneath every malloc library's public interface there is the underlying
operating system's memory management interface.  This provides features which
can be as simple as giving processes the ability to allocate a new block of
memory for themselves, or it can offer advanced features such as protecting
areas of memory from being read or written.  Some embedded systems have no
operating systems and hence no support for dynamic memory allocation, and so the
malloc library must instead allocate blocks of memory from a fixed-sized array. 
The mpatrol library can be built to support all of the above types of system,
but the more features an operating system can provide it with, the more it can
do.

<p>On operating systems such as UNIX and Windows, all dynamic memory allocation
requests from a process are dealt with by using a feature called <em>virtual
memory</em>.  This means that a process cannot perform illegal requests without
them being denied, which protects the other running processes and the operating
system from being affected by such errors.  However, on AmigaOS and Netware
platforms there is no virtual memory support and so all processes effectively
share the same address space as the operating system and any other running
processes.  This means that one process can accidentally write into the data
structures of another process, usually causing the other process to fail and
bring down the system.  In addition, a process which allocates a lot of memory
will result in there being less available memory for other running processes,
and in extreme cases the operating system itself.

<ul>
<li><a href="#Virtual%20memory">Virtual memory</a>:                   Addition facilities. 
<li><a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>:    Tracing information. 
<li><a href="#Threads">Threads</a>:                          Multiple threads of execution. 
</ul>

<p><hr>
Node:<a name="Virtual%20memory">Virtual memory</a>,
Next:<a rel=next href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>,
Up:<a rel=up href="#Operating%20system%20support">Operating system support</a>
<br>

<h2>6.1 Virtual memory</h2>

<p><em>Virtual memory</em> is an operating system feature that was originally used to
provide large usable address spaces for every process on machines that had very
little physical memory.  It is used by an operating system to
fool<a rel=footnote href="#fn-6"><sup>6</sup></a> a running process into believing that it can
allocate a vast amount of memory for its own purposes, although whether it is
allowed to or not depends on the operating system and the permissions of the
individual user.

<p>Virtual memory works by translating a virtual address (which the process uses)
into a physical address (which the operating system uses).  It is generally
implemented via a piece of hardware called a <em>memory management unit</em>, or
MMU.  The MMU's primary job is to translate any virtual addresses that are
referred to by machine instructions into physical addresses by looking up a
table which is built by the operating system.  This table contains mappings to
and from <em>pages</em><a rel=footnote href="#fn-7"><sup>7</sup></a> rather than bytes since it
would otherwise be very inefficient to handle mappings between individual bytes. 
As a result, every virtual memory operation operates on pages, which are
indivisible and are always aligned to the system page size.

<p>Even though each process can now see a huge address space, what happens when it
attempts to allocate more pages than actually physically exist, or allocate an
additional page of memory when all of the physical pages are in use by it and
other processes?  This problem is solved by the operating system temporarily
saving one or more of the least-used pages (which might not necessarily belong
that that process) to a special place in the file system called a <em>swap
file</em>, and mapping the new pages to the physical addresses where the old pages
once resided.  The old pages which have been <em>swapped out</em> are no longer
currently accessible, but their location in the swap file is noted in the
translation table.

<p>However, if one of the pages that has been swapped out is accessed again, a
<em>page fault</em> occurs at the instruction which referred to the address and
the operating system catches this and reloads the page from the swap file,
possibly having to swap out another page to make space for the new one.  If this
occurs too often then the operating system can slow down, having to constantly
swap in and swap out the same pages over and over again.  Such a problem is
called <em>thrashing</em> and can only really be overcome by using less virtual
memory or buying more physical memory.

<p>It is also possible to take advantage of the virtual memory system's
interaction between physical memory and the file system in program code, since
mapping an existing file to memory means that the usual file I/O operations can
be replaced with memory read and write operations.  The operating system will
work out the optimum way to read and write any buffers and it means that only
one copy of the file exists in both physical memory and the file system.  Note
that this is how <em>shared libraries</em><a rel=footnote href="#fn-8"><sup>8</sup></a>
on UNIX platforms are generally implemented, with each individual process that
uses the shared library having it mapped to somewhere in its address space.

<p>Another major feature of virtual memory is its ability to read protect and write
protect individual pages of process memory.  This means that the operating
system can control access to different parts of the address space for each
process, and also means that a process can read and/or write protect an area of
memory when it wants to ensure that it won't ever read or write to it again.  If
an illegal memory access is detected then a <em>signal</em> will be sent to the
process, which can either be caught and handled or will otherwise terminate the
process.  Note that as with all virtual memory operations, this ability to
protect memory only applies to pages, so that it is not possible to protect
individual bytes.

<p>However, some versions of UNIX have programmable software <em>watch points</em>
which are implemented at operating system level.  These are normally used by
debuggers to watch a specified area of memory that is expected to be read from
or written to, but can just as easily be used to implement memory protection at
byte level.  Unfortunately, as this feature is implemented in
software<a rel=footnote href="#fn-9"><sup>9</sup></a> rather
than in hardware, watch points tend to be incredibly slow, mainly as a result of
the operating system having to check every instruction before it is executed. 
In addition, some UNIX platforms only allow a certain number of software watch
points to be in use at any one time, so even if your system supports them you
may not be able to use them with the mpatrol library if there are many memory
allocations in use at one time.

<p>There is also an additional problem when using watch points, which is due to
misaligned reads from memory.  These can occur with compiler-generated code or
with optimised library routines where memory read, move or write operations have
been optimised to work at word level rather than byte level.  For example, the
<code>memcpy()</code> function would normally be written to copy memory a byte at a
time, but on some systems this can be improved by copying a word at a time. 
Unfortunately, care has to be taken when reading and writing such words as the
equivalent bytes may not be aligned on word boundaries.  Technically, reading
additional bytes before or after a memory allocation when they share the same
word is legal, but when using watch points such errors will be picked up.  The
mpatrol library replaces most of the memory operation functions provided by the
system libraries with safer versions, although they may not be as efficient.

<p>An operating system with virtual memory is usually going to run ever so slightly
slower than an operating system without it<a rel=footnote href="#fn-10"><sup>10</sup></a>, but the advantages of virtual memory far
outweigh the disadvantages, especially when used for debugging purposes.

<p><hr>
Node:<a name="Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>,
Next:<a rel=next href="#Threads">Threads</a>,
Previous:<a rel=previous href="#Virtual%20memory">Virtual memory</a>,
Up:<a rel=up href="#Operating%20system%20support">Operating system support</a>
<br>

<h2>6.2 Call stacks and symbol tables</h2>

<p>As stated in the section on stack memory allocations (see <a href="#Stack%20memory%20allocations">Stack memory allocations</a>), when a function is called, a copy of the caller's state
information (including local variables and registers) is saved on the stack so
that it can be restored when the called function returns.  On many operating
systems there is a <em>calling convention</em><a rel=footnote href="#fn-11"><sup>11</sup></a> which defines the layout of such
stack entries so that code compiled in different languages and with different
compilers can be intermixed.  This usually specifies at which stack offsets the
stack pointer, program counter and local variables for the calling function can
be found, although on some processor architectures the function calling
conventions are specified by the hardware and so the operating system must use
these instead.

<p>On systems that have consistent calling conventions, it is usually possible to
perform call stack <em>tracebacks</em> from within the current function in order
to determine the stack of function calls that led to the current function.  This
is extremely useful for debugging purposes and is done by examining the current
stack frame to see if there is a pointer to the previous stack frame.  If there
is, then it can be followed to find out all of the state information about the
calling function.  This can be repeated until there are no more stack
frames<a rel=footnote href="#fn-12"><sup>12</sup></a>. 
This is generally how this information is determined by debuggers when a call
stack traceback is requested.

<p>In addition to the pointer to the previous stack frame, the saved state
information also always contains the saved program counter register, which
contains either the address of the instruction that performed the function call,
or the address of the instruction at which to continue execution when the
called function returns<a rel=footnote href="#fn-13"><sup>13</sup></a>. 
This information can be used to identify which function performed the call,
since the address of the instruction must lie between the start and end of one
of the functions in the process.

<p>There are several different ways to perform stack unwinding.  The first requires
compiler support and uses builtin functions to determine the next stack frame
and the return address.  The GNU C compiler, <code>gcc</code>, supports this but
unfortunately the number of stack frames to traverse must be known at
compile-time rather than run-time.  The second method requires operating system
support, with a library of routines provided to perform call stack traversal. 
Unfortunately, such routines can be quite time consuming and may require a lot
of resources, but on the other hand they are likely to be very reliable at
obtaining the necessary information.  The mpatrol library can be built to
support either of these methods, with the <code>MP_BUILTINSTACK_SUPPORT</code> and
the <code>MP_LIBRARYSTACK_SUPPORT</code> preprocessor macros.

<p>A third way to perform stack unwinding involves reading (or effectively
disassembling) the instructions that are being executed in order to determine
the size of the stack frame being used and the address of the instruction at
which execution will resume when the function returns.  This can also be quite
a reliable method of obtaining call stack information but is only likely to be
feasible on a processor architecture which has a very simple instruction set,
such as a RISC<a rel=footnote href="#fn-14"><sup>14</sup></a> architecture.  MIPS
processors are a good example of this.

<p>The final method of stack unwinding requires that the frame pointer and return
address are both stored on the stack whenever a new function is called.  The
chain of frame pointers can then be followed down the stack, and the return
addresses can be read at a given offset from the frame pointers.  This is
usually possible with CISC<a rel=footnote href="#fn-15"><sup>15</sup></a> processor
architectures that have dedicated call instructions which automatically save
such information on the stack, although some RISC processors also save these as
well.  However, inline functions and compiler optimisations can sometimes result
in the frame pointer being omitted, usually resulting in an inability to walk
the stack.

<p>However, in order to determine this symbolic information, it must be possible to
find out where the start and end addresses of all of the functions in the
process are.  This can usually only be read from object files, since they
contain the symbol tables that were used by the linker to generate the final
executable file for the program.  The object file's symbol tables normally
contain information about the start address, size, name and visibility of every
symbol that was defined, but this depends on the format of the object file and
if the symbol tables have been stripped from the final executable file.

<p>If the object file was created by a compiler then it may also contain debugging
information that was generated by the compiler for use with a debugger.  Such
information may include a mapping of code addresses to source
lines<a rel=footnote href="#fn-16"><sup>16</sup></a>, and this information
can be used by the mpatrol library to provide more meaningful information in
call stack tracebacks.

<p>On systems that support shared libraries, additional work must be done to
determine the symbolic information for all of the functions which have been
defined in them.  The symbols for functions that are defined in shared libraries
normally appear as undefined symbols in the executable file for the program and
so must be searched in the system in order to get the necessary information.  It
is usually necessary to liaise with the <em>dynamic linker</em><a rel=footnote href="#fn-17"><sup>17</sup></a> on many systems.

<p><hr>
Node:<a name="Threads">Threads</a>,
Previous:<a rel=previous href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>,
Up:<a rel=up href="#Operating%20system%20support">Operating system support</a>
<br>

<h2>6.3 Threads</h2>

<p>On systems with virtual memory, such as UNIX and Windows, user programs are run
as <em>processes</em> which have their own address space and resources.  If a
process needs to create sub-processes to perform other tasks it must call
<code>fork()</code> or <code>spawn()</code> to create new processes, but these new processes
do not share the same address space or resources as the parent process.  If
processes need to share memory they must either use a message passing interface
or explicitly mark a range of memory as shareable.

<p>Traditionally, this was not too much of a handicap as parallel processing was
an expensive luxury and could only be made use of by the kernel of such systems. 
However, with the birth of fast processors and parallel programming, programs
could be made to run more efficiently and faster on multi-processor systems by
having more than one <em>thread</em> of control.  This was achieved by allowing
processes to have more than one program counter through which the processor
could execute instructions, and if one thread of control stalled for a
particular reason then another could continue without stalling the entire
process.

<p>Such multithreaded programs allow parallel programming and implicit shared
memory between threads since all threads in a process share the same address
space and resources.  This is similar to operating systems that have no
virtual memory, such as AmigaOS and Netware<a rel=footnote href="#fn-18"><sup>18</sup></a>, except
that once a process terminates, all threads terminate as well and all of its
resources are still reclaimed.

<p>Multithreaded programming generally needs no compiler support, but does require
some primitive operations to be supported by the operating system for a threads
library to call.  The functions that are available in the threads library
provide the means for a process to create and destroy threads.  There are
currently several popular threads libraries available, although the POSIX
threads standard remains the definitive implementation.

<p>It is always important to remember when programming a multithreaded application
that because all threads in a process share the same address space, measures
must be taken to prevent threads reading and writing global data in a haphazard
fashion.  This can either be done by locking with semaphores and mutexes, or can
be performed by using stack variables instead of global variables since every
thread has its own local stack.  Care must be taken to write re-entrant
functions -- i.e. a function will give exactly the same result with one
thread as it will with multiple threads running it at the same time.

<p>The mpatrol library can be built as a thread-safe library with support for
multi-threaded programs.  When this library is linked with your program, only
one thread at a time can allocate, reallocate or deallocate dynamic memory, or
perform a memory operation via <code>memcpy()</code>, <code>memset()</code>, etc.  This does
not take full advantage of the potential concurrency in the library, but at
least it will allow the debugging of multi-threaded programs.

<p>The process of making the mpatrol library thread-safe was made more complicated
by the fact that the mutexes protecting the library's data structures had to be
recursive, since some of the functions that the library will call may call
<code>malloc()</code> and <code>free()</code> or any other functions redefined by the
library.  If this was to happen with non-recursive mutexes then the recursive
call would result in the thread attempting to lock a mutex that it already
owned.  However, implementing recursive mutexes was only half the problem.

<p>The other problem with writing a thread-safe malloc library is that it must be
initialised before the program becomes multi-threaded.  If the library is
initialised when there are multiple threads running then one thread may be
attempting to initialise the mutexes whilst another thread may be attempting
to lock an uninitialised mutex.  Ideally, the best place to initialise the
library would be at the start of <code>main()</code> but there is currently no way
to do this other than getting users to explicitly plant calls to initialise the
library in their code.  This is not a very satisfactory solution if all we want
to do is link in the replacement malloc library without any need for
recompilation.

<p>Fortunately, there are some ways to plant initialisation calls before
<code>main()</code> is called, but they all have some drawbacks.  The first way is to
use a static file-scope constructor in C++, which will then initialise the
mutexes and the library data structures before the code in <code>main()</code> is
executed.  However, on many systems this will require the final link to be
performed by the C++ compiler that built the library.  That may not be desirable
or even possible in many cases.  Unfortunately, this drawback appears in the
second method, which involves using the GNU C compiler to compile the library. 
This compiler has an extension which allows functions to be specified as
constructors which will be called before <code>main()</code>, but means that any
program which is linked with the resulting library must be linked with the GNU C
compiler driver.  However, many systems are now GNU-based which would mean that
this would happen anyway.

<p>The final way of initialising the mutexes and the library data structures is to
plant a call to the initialisation routines from a special section which the
system will call before <code>main()</code> is called.  This section is called the
<code>.init</code> section on ELF-based platforms, but may exist in another form on
other platforms too.  This has the advantage that the system linker can be used
to link the final program, but a possible disadvantage is that the library may
be initialised too early, possibly before the environment or file streams have
been set up.  You may find that if one of the above methods does not work for
you then perhaps another one will.

<p><hr>
Node:<a name="Using%20mpatrol">Using mpatrol</a>,
Next:<a rel=next href="#Profiling">Profiling</a>,
Previous:<a rel=previous href="#Operating%20system%20support">Operating system support</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>7 Using mpatrol</h1>

<p>This chapter contains a general description of all of the features of mpatrol
and how to use them effectively.  You'll also find a complete reference for
mpatrol in the appendices, but you may wish to try out the examples
(see <a href="#Examples">Examples</a>) and the tutorial (see <a href="#Tutorial">Tutorial</a>) before reading further.

<ul>
<li><a href="#Library%20behaviour">Library behaviour</a>:            Miscellaneous information. 
<li><a href="#Logging%20and%20tracing">Logging and tracing</a>:          General information. 
<li><a href="#General%20errors">General errors</a>:               Everyday problems. 
<li><a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>:   Overflow buffers. 
<li><a href="#Using%20with%20a%20debugger">Using with a debugger</a>:        Setting breakpoints. 
<li><a href="#Testing">Testing</a>:                      Additional checks. 
<li><a href="#Library%20functions">Library functions</a>:            What's provided. 
<li><a href="#Utilities">Utilities</a>:                    External programs. 
</ul>

<p><hr>
Node:<a name="Library%20behaviour">Library behaviour</a>,
Next:<a rel=next href="#Logging%20and%20tracing">Logging and tracing</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.1 Library behaviour</h2>

<p>Most of the behaviour of the mpatrol library can be controlled at run-time via
options which are read from the <code>MPATROL_OPTIONS</code> environment variable. 
This prevents you having to recompile or relink each time you want to change a
library setting, and so makes it really easy to try out different settings to
locate a particular bug.  You should know how to set the value of an environment
variable on your system before you read on.

<p>By default, the mpatrol library will attempt to determine the minimum required
alignment for any generic memory allocation when it first initialises itself. 
This may be affected by the compiler and its settings when the library was built
but it should normally reflect the minimum alignment required by the processor
on your system.  If you would prefer a larger (or perhaps even smaller) default
alignment you may change it at run-time using the <code>DEFALIGN</code> option.  The
value you supply must be in bytes, must be a power of two, and should not be
larger that the system page size.  If you encounter bus errors due to misaligned
memory accesses then you should increase this value.

<p>On systems that have virtual memory the library will attempt to write-protect
all of its internal structures when user code is being run.  This ensures that
it is nearly impossible for a program to corrupt any mpatrol library data. 
However, unprotecting and then protecting the structures at every library call
has a slight overhead so you may prefer to disable this behaviour by using the
<code>NOPROTECT</code> option.  This has no effect on systems that have no virtual
memory.

<p>Usually it is desirable for many system library routines to be protected from
being interrupted by certain signals since they may themselves be called from
signal handlers.  If this is not the case then it may be possible to interrupt
the program from within such routines, perhaps causing problems if their global
variables are left in an undefined state.  As the mpatrol library replaces some
of these system library routines it is also possible to specify that they are
protected from certain interrupt signals using the <code>SAFESIGNALS</code> option. 
However, this can sometimes result in it being hard to interrupt the program
from the keyboard if a lot of processor time is spent in mpatrol routines,
which is why this behaviour is disabled by default<a rel=footnote href="#fn-19"><sup>19</sup></a>.

<p>On UNIX systems, the usual way for malloc libraries to allocate memory from the
process heap is through the <code>sbrk()</code> system call.  This allocates memory
from a contiguous heap, but has the disadvantage in that other library functions
may also allocate memory using the same function, thus creating holes in the
heap.  This is not a problem for mpatrol, but you may have a suspicion that your
bug is due to a function from another library corrupting your data so you may
wish to use the <code>USEMMAP</code> option.  This is only available on systems that
have the <code>mmap()</code> system call and allows mpatrol to allocate all of its
memory from a part of the process heap that is non-contiguous (i.e. each call
to <code>mmap()</code> may return a block of memory that is completely unrelated to
that returned by the previous call).  It may also be required on some systems in
order for the mpatrol library to implement memory protection.

<p>By default, every time an mpatrol library function is called the library will
automatically check the freed memory and overflow buffers of every memory
allocation, which can slow program execution down, especially if you suspect the
error you are looking for occurs at the 1000th memory allocation, for example. 
You can therefore use the <code>CHECK</code> option to specify a range of memory
allocations at which the mpatrol library will automatically check the freed
memory and overflow buffers.  All other allocations that fall outside this range
will not be checked.

<p>On UNIX systems, the mpatrol library can also invoke the <code>mpedit</code>
command to edit source files that show up in any warnings or error messages that
it generates.  This can only happen if the diagnostic message can be traced back
to a specific source line in the program; in many cases this is not possible. 
If editing the files is not required, a context listing of the appropriate
source line can be generated instead.  The <code>EDIT</code> option specifies that
files are to be edited and the <code>LIST</code> option specifies that a context
listing is to be generated.  These options are mutually exclusive.

<p>If the mpatrol library that was built for your system supports reading symbolic
information from a program's executable file, but it cannot locate the
executable file, or you wish to specify an alternative, you can use the
<code>PROGFILE</code> option to do this.  All this does is instruct the mpatrol
library to read symbols from this file instead.  Note that on systems that
support dynamic linking, the library can also read symbols from a dynamically
linked executable file that has had its normal symbol table stripped.

<p>Finally, a list of all of the recognised options in the mpatrol library can be
displayed to the standard error file stream by using the <code>HELP</code> option. 
This will not affect the settings of the library in any way, so you should be
able to use other options at the same time.

<p><hr>
Node:<a name="Logging%20and%20tracing">Logging and tracing</a>,
Next:<a rel=next href="#General%20errors">General errors</a>,
Previous:<a rel=previous href="#Library%20behaviour">Library behaviour</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.2 Logging and tracing</h2>

<p>If you would like to see a complete log of all of the memory allocations,
reallocations and deallocations performed by your program, use the
<code>LOGALL</code> option.  This provides detailed tracing for each of the mpatrol
library functions, and a full description of the format of such tracing is given
in Example 1 (see <a href="#Example%201">Example 1</a>).  Alternatively, you may select one or more
types of functions to be traced using the <code>LOGALLOCS</code>,
<code>LOGREALLOCS</code>, <code>LOGFREES</code> and <code>LOGMEMORY</code> options if you
feel that the log file is too large when <code>LOGALL</code> is used.  By default
all diagnostics from the mpatrol library get sent to <code>mpatrol.log</code> in the
current directory, but this can be changed using the <code>LOGFILE</code> option. 
In fact, you can also specify a directory where all log files from the mpatrol
library will get placed by setting the <code>LOGDIR</code> environment variable.

<p>On systems that support it, every log entry also contains a call stack
traceback that may also include the names of the symbols that appear on the
call stack.  If the object file access library that mpatrol was built with has
support for reading line number tables from object files then the
<code>USEDEBUG</code> option will also try to determine the file name and line
number for each entry in the call stack, but only if the object files contain
the relevant debugging information.  This information will only be available
before program termination and so any call stack tracebacks that appear after
the library summary will not be displayed with their corresponding file name
and line number.  This option will also slow down program execution since a
search through the line number tables will have to be made every time a call
stack is displayed.  Alternatively, the <code>mpsym</code> command may be used to
process an mpatrol log file with a debugger in order to obtain symbol names and
source level information for any call stacks.

<p>Because the <code>alloca()</code>, <code>strdupa()</code> and <code>strndupa()</code> functions
automatically free their allocations when the calling function returns, the log
entries for these types of memory allocation are slightly different.  The actual
memory allocation will have an entry similar to <code>malloc()</code>, etc., but the
memory deallocation will be marked as being done by <code>alloca()</code> and will
occur at the next call to an mpatrol library function after the calling function
has returned.  However, any such allocations that are explicitly deallocated
with the <code>dealloca()</code> function will be marked as being done by
<code>dealloca()</code>.

<p>The mpatrol library will always try to display as much useful information as
possible in this log file, and will always display a summary of library settings
and statistics when your program terminates successfully.  If you don't get this
then your program did not call <code>exit()</code> and either called <code>abort()</code> or
was terminated by the operating system instead.  In such cases, either use a
debugger to see where your program crashed or use the <code>LOGALL</code> option to
see the last successful library call in the log file so that you have a rough
idea of where your program crashed.

<p>It is also possible to get mpatrol to write more summary information to the log
file after it writes out its settings and statistics at program termination. 
Use the <code>SHOWFREED</code> and <code>SHOWUNFREED</code> options to display a list of
freed and unfreed memory allocations.  The former will only be displayed if the
<code>NOFREE</code> option is used, but the latter can be useful for detecting
memory leaks.  The <code>SHOWFREE</code> option can be used to display a summary of
any free memory blocks.

<p>The <code>SHOWMAP</code> option will display a memory map of the heap that was valid
when the process terminated, and the <code>SHOWSYMBOLS</code> option will display
any symbolic information that the mpatrol library managed to obtain from any
executable files and libraries that were relevant to the program being tested. 
All of the above five options can be selected with the <code>SHOWALL</code> option.

<p>Because the log file can contain verbose information about memory allocations,
reallocations, deallocations and operations, it can end up being too large if
all such information is being logged for a large program.  To get around this,
it is possible to <em>trace</em> all memory allocation and deallocation events in
a concise way, to be stored in a separate file for later processing by the
<code>mptrace</code> command.  By default, no such tracing is performed but it can
be enabled with the <code>TRACE</code> option.  The default tracing output file is
<code>mpatrol.trace</code>, but this can be changed using the <code>TRACEFILE</code>
option.  As with the <code>LOGFILE</code> option, you can also specify a directory
where all tracing output files from the mpatrol library will get placed by
setting the <code>TRACEDIR</code> environment variable.

<p><hr>
Node:<a name="General%20errors">General errors</a>,
Next:<a rel=next href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>,
Previous:<a rel=previous href="#Logging%20and%20tracing">Logging and tracing</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.3 General errors</h2>

<p>By default, the mpatrol library follows the guidelines for ANSI C regarding the
behaviour of the dynamic memory allocation and memory operation functions it
replaces<a rel=footnote href="#fn-20"><sup>20</sup></a>.  This means that calling <code>malloc()</code> with a size of zero is
allowed, for example.  However, warnings can be generated for all of these
types of calls by using the <code>CHECKALL</code> option.  The <code>CHECKALLOCS</code>
option warns only about calls to <code>malloc()</code> and similar functions with a
size of zero, the <code>CHECKREALLOCS</code> option warns only about calls to
<code>realloc()</code> and similar functions with either a null pointer or a size of
zero, and the <code>CHECKFREES</code> option warns only about calls to <code>free()</code>
and similar functions with a null pointer.  The <code>CHECKMEMORY</code> option
gives an error if a zero-size memory operation is performed on a <code>NULL</code>
pointer -- this is normally allowed by default.

<p>All newly-allocated memory can be pre-filled with a specified byte by using the
<code>ALLOCBYTE</code> option.  This can be used to catch out code that expects
newly-allocated memory to be zeroed, although this option will have no effect on
memory that was allocated with <code>calloc()</code>.  All free memory can also be
pre-filled with a different specified byte by using the <code>FREEBYTE</code>
option.  This will catch out code that expects to be able to use the contents of
freed memory.  Note that you may wish to change these options from their default
values on your system so that the contents can be filled with values that are
least likely to be used at run-time.  For example, ensuring that the pointer
representation of the value can never be a valid pointer, or that the floating
point representation will always be invalid.  These values will vary across
operating systems and processor architectures.

<p>Alternatively, the mpatrol library can be instructed to keep all (or a certain
number of recent) freed memory allocations so that its diagnostics can be
clearer about which freed allocation a piece of code is erroneously trying to
access.  This is controlled with the <code>NOFREE</code> option, which accepts an
argument specifying the maximum number of recently-freed memory allocations to
prevent being reused.  If the argument is zero then no freed memory allocations
will ever be reused, thus resulting in a lot more heap memory being used.  Note
that this option distinguishes between <em>free</em> memory and <em>freed</em>
memory.  <em>Free</em> memory is unallocated memory that has been taken from the
system heap.  <em>Freed</em> memory is a freed memory allocation, with all of the
original details of the allocation preserved.

<p>Normally, the <code>NOFREE</code> option will fill the freed allocation with the
free byte so that any code that accesses it will hopefully fall over.  However,
the original contents can be preserved using the <code>PRESERVE</code> option in
case you need to see what the contents were just before it was freed.  The
<code>NOFREE</code> option is also affected by the <code>PAGEALLOC</code> option, since
then the freed allocation will have its contents both read and write protected
so that nothing can access them.  If the <code>PRESERVE</code> option is used in
this case then the freed allocation will only be made write-protected so that
the original contents can be read from but not written to.

<p>Note that if the argument specified with the <code>NOFREE</code> option is non-zero
then the mpatrol library will store all recently-freed memory allocations in a
queue<a rel=footnote href="#fn-21"><sup>21</sup></a>.  Once the queue has filled to the point specified with
the <code>NOFREE</code> option then all subsequent calls to free memory will result
in the most recently-freed memory allocation being placed at the end of the
queue and the freed memory allocation at the beginning of the queue will be
returned to the free memory pool for later reuse.  Obviously, the larger the
freed queue size, the better chance of detecting attempts to access
previously-freed memory, but unfortunately more memory will be used up and the
mpatrol library will have to keep track of a larger number of memory
allocations.

<p><hr>
Node:<a name="Overwrites%20and%20underwrites">Overwrites and underwrites</a>,
Next:<a rel=next href="#Using%20with%20a%20debugger">Using with a debugger</a>,
Previous:<a rel=previous href="#General%20errors">General errors</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.4 Overwrites and underwrites</h2>

<p>Once a block of memory has been allocated, it is imperative that the program
does not attempt to write any data past the end of the block or write any data
just before the beginning of the block.  Even writing a single byte just beyond
the end of an allocation or just before the beginning of an allocation can cause
havoc.  This is because most malloc libraries store the details of the allocated
block in the first few words before the beginning of the block, such as its size
and a pointer to the next block.  The mpatrol library does not do this, so a
program which failed using the normal malloc library and worked when the mpatrol
library was linked in is a possible candidate for turning on overflow buffers.

<p>Such memory corruption can be extremely difficult to pinpoint as it is unlikely
to show itself until the next call is made to the malloc library, or if the
internal malloc library blocks were not overwritten, the next time the data is
read from the block that was overwritten.  If the former is the case then the
next library call will cause an internal error or a crash, but only when the
memory block that was affected is referenced.  This is likely to disappear when
using the mpatrol library since it keeps its internal structures separate, and
write-protects them on systems that support memory protection.

<p>In order to identify such errors, it is possible to place special
buffers<a rel=footnote href="#fn-22"><sup>22</sup></a> on either side of every memory allocation, and these will be pre-filled
with a specified byte.  Before every mpatrol library call, the library will
check the integrity of every such overflow buffer in order to check for a memory
underwrite or overwrite.  Depending on the number of allocations and size of
these buffers, this can take a noticable amount of time (which is why overflow
buffers are disabled by default), but can mean that these errors get noticed
sooner.  The option which governs this is <code>OFLOWSIZE</code>.  The byte with
which they get pre-filled can be changed with <code>OFLOWBYTE</code>.  Depending on
what gets written, it might only be possible to see such errors when a different
size of buffer or a different pre-fill byte is used.

<p>Note that you may wish to change the <code>OFLOWBYTE</code> from its default value
on your system so that the contents can be filled with values that are least
likely to be used at run-time.  For example, ensuring that the pointer
representation of the value can never be a valid pointer, or that the floating
point representation will always be invalid.  These values will vary across
operating systems and processor architectures, but may also vary depending on
the datatypes that you will be expecting to store in the memory allocations.

<p>A worse situation can occur when it is only reads from memory that overflow or
underflow; i.e. with the faulty code reading just before or just past a memory
allocation.  These cannot be detected by overflow buffers as it is not possible
using conventional means to interrupt every single read from memory.  However,
on systems with virtual memory, it is possible to use the memory protection
feature to provide an alternative to overflow buffers, although at the added
expense of increased memory usage.

<p>The <code>PAGEALLOC</code> option turns on this feature and automatically rounds
up the size of every memory allocation to a multiple of the system page size. 
It also rounds up the size of every overflow buffer to a multiple of the system
page size so that every memory allocation occupies its own set of pages of
virtual memory and no two memory allocations occupy the same page of virtual
memory.  The overflow buffers are then read and write protected so that any
memory accesses to them will generate an error<a rel=footnote href="#fn-23"><sup>23</sup></a>.  Following on from the previous section, the <code>PAGEALLOC</code>
option also causes free memory to be read and write protected as well since that
will also occupy non-overlapping virtual memory pages.

<p>The remaining memory that is left over within an allocation's pages is
effectively turned into traditional overflow buffers, being pre-filled with the
overflow byte and checked periodically by the mpatrol library to ensure that
nothing has written into them.  However, because of this remaining memory, the
library has a choice of where to place the memory allocation within its pages. 
If it places the allocation at the very beginning then it will catch memory
underwrites, but if it places the allocation at the very end then it will catch
memory overwrites.  Such a choice can be controlled at run-time by supplying an
argument to the <code>PAGEALLOC</code> option.  If <code>PAGEALLOC=LOWER</code> is used
then every allocation will be placed at the very beginning of its pages and if
<code>PAGEALLOC=UPPER</code> is used then the placement will be at the very end of
its pages.  This is probably better explained in Example 3 (see <a href="#Example%203">Example 3</a>)
where the problems with <code>PAGEALLOC=UPPER</code> and alignment are also
discussed.

<p>Obviously, there are still some deficiencies when using <code>PAGEALLOC</code> since
it can use up a huge amount of memory (especially with <code>NOFREE</code>) and the
overflow buffers within an allocation's pages can still be read without causing
an immediate error.  Both of these deficiencies can be overcome by using the
<code>OFLOWWATCH</code> option to install <em>software watch points</em> instead of
overflow buffers, but there are still very few systems that support software
watch points at the moment, and it can slow a program's execution speed down by
a factor of around 10,000.  The reason for this is that software watch points
instruct the operating system to check every read from and write to memory,
which means that it has to single-step through a process checking every
instruction before it is executed.  However, this is a very thorough way of
checking for overflows and is unlikely to miss anything, although there may be
problems with misaligned memory accesses when using watch points
(see <a href="#Virtual%20memory">Virtual memory</a>).

<p>Note that from release 1.1.0 of mpatrol, the library comes with replacement
functions for many memory operation functions, such as <code>memset()</code> and
<code>memcpy()</code>.  These new functions provide additional checks to ensure that
if a memory operation is being performed on a memory block, the operation will
not read or write before or beyond the boundaries of that block.

<p>Normally, if an error is discovered in the call to such functions, the mpatrol
library will report the error but prevent the operation from being performed
before continuing execution.  If the error was that the range of memory being
operated on overflowed the boundaries of an existing memory allocation then the
<code>ALLOWOFLOW</code> option can be used to turn the error into a warning and
force the operation to continue.  This behaviour can be desirable in certain
cases where third-party libraries are being used that make such calls but the
end result does not overflow the allocation boundary.

<p>To conclude, if you suspect your program has a piece of code which is performing
illegal memory underwrites or overwrites to a memory allocation you should use
each of the following options in sequence, but only if your system supports
them.

<ol type=1 start=1>
</p><li><code>OFLOWSIZE=8</code>

<li><code>OFLOWSIZE=32</code>

<li><code>OFLOWSIZE=1</code> <code>PAGEALLOC=LOWER</code>

<li><code>OFLOWSIZE=1</code> <code>PAGEALLOC=UPPER</code>

<li><code>OFLOWSIZE=8</code> <code>OFLOWWATCH</code>

<li><code>OFLOWSIZE=32</code> <code>OFLOWWATCH</code>
</ol>

<p><hr>
Node:<a name="Using%20with%20a%20debugger">Using with a debugger</a>,
Next:<a rel=next href="#Testing">Testing</a>,
Previous:<a rel=previous href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.5 Using with a debugger</h2>

<p>If you would like to use mpatrol to pause at a specific memory allocation,
reallocation or deallocation in a debugger then this section will describe how
to go about it.  Unfortunately, debuggers vary widely in function and usage and
are normally very system-dependent.  The example below will use <code>gdb</code> as
the debugger, but as long as you know how to set a breakpoint within a debugger,
any one will do.

<p>First of all, decide where you would like the mpatrol library to pause when
running your program within the debugger.  You can choose one allocation index
to break at using the <code>ALLOCSTOP</code> option, or you can choose to break at
a specific reallocation of that allocation by also using the
<code>REALLOCSTOP</code> option.  If you use <code>REALLOCSTOP</code> without using
<code>ALLOCSTOP</code> then you will break at the first memory allocation that has
been reallocated the specified number of times.  You can also choose to break at
the point in your program that frees a specific allocation index by using the
<code>FREESTOP</code> option.

<p>The normal process for determining where you would like to pause your program
in the debugger is by using the <code>LOGALL</code> option and examining the log
file produced by mpatrol.  If your program crashed then you should look at the
last entry in the log file to see what the allocation index (and possibly also
the reallocation index) of the last successful call was.  You can then decide
which of the above options to use.  Note that the debugger will break at a point
before any work is done by the mpatrol library for that allocation index so that
you can see if it was the last successful operation that caused the damage.

<p>Having decided which combination of mpatrol options to use, you should set them
in the <code>MPATROL_OPTIONS</code> environment variable before running the debugger on
your program.  Alternatively, your debugger may have a command that allows you
to modify your environment during debugging, but you're just as well setting the
environment variable before you run the debugger as it shouldn't make any
difference<a rel=footnote href="#fn-24"><sup>24</sup></a>.

<p>After you get to the debugger command prompt, you should set a breakpoint at the
<code>__mp_trap()</code> function.  This is the function that gets called when the
specified allocation index and/or reallocation index appears and so when you
run your program under the debugger the mpatrol library will call
<code>__mp_trap()</code> and the debugger will stop at that point.  If you are not
running your program within a debugger, or if you haven't set the breakpoint,
then <code>__mp_trap()</code> will still be called, but it won't do anything.  Note
that there may be some naming issues on some platforms where the visible name of
a global function gets an underscore prepended to it.  You may have to take that
into account when setting the breakpoint on such systems.

<p>Now that you have set the <code>MPATROL_OPTIONS</code> environment variable and have
set the debugger to break at <code>__mp_trap()</code>, all that is required is for you
to run your program.  Hopefully, the debugger should stop at <code>__mp_trap()</code>. 
If it doesn't then you may have to check your environment variable settings to
ensure that they are the same as when you ran the program outwith the debugger,
although obviously with the addition of <code>ALLOCSTOP</code>, etc.  Once the
program has been halted by the debugger, you can then single-step through your
code until you see where it goes wrong.  If this is near the end of your program
then you'll have saved yourself a lot of time by using this method.

<p>The following example will be used to illustrate the steps involved in using the
<code>ALLOCSTOP</code>, <code>REALLOCSTOP</code> and <code>FREESTOP</code> options. 
However, it is only for tutorial purposes and the same effect could easily be
achieved by breaking at line 18 in a debugger because in this case it is obvious
from the code and the mpatrol log file where it is going wrong.  In real
programs this is hardly ever the case<a rel=footnote href="#fn-25"><sup>25</sup></a>.

<pre> 1  /*
 2   * Allocates 1000 blocks of 16 bytes, freeing each block immediately
 3   * after it is allocated, and freeing the last block twice.
 4   */


 7  #include "mpatrol.h"


10  int main(void)
11  {
12      void *p;
13      int i;

15      for (i = 0; i &lt; 1000; i++)
16          if (p = malloc(16))
17              free(p);
18      free(p);
19      return EXIT_SUCCESS;
20  }
</pre>

<p>Compile this example code with debugging information enabled and link it with
the mpatrol library, then set <code>MPATROL_OPTIONS</code> to <code>LOGALL</code> and run
the resulting program.  If you examine <code>mpatrol.log</code> you will see the
following near the bottom of the file.

<pre><small>...</small>

ALLOC: malloc (1000, 16 bytes, 4 bytes) [main|test.c|16]
        0x08049449 main+57
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

returns 0x080620E8

FREE: free (0x080620E8) [main|test.c|17]
        0x08049470 main+96
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

    0x080620E8 (16 bytes) {malloc:1000:0} [main|test.c|16]
        0x08049449 main+57
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

FREE: free (0x080620E8) [main|test.c|18]
        0x08049491 main+129
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

ERROR: [NOTALL]: free: 0x080620E8 has not been allocated

<small>...</small>
</pre>

<p>In this example, we'll want to use <code>ALLOCSTOP</code> to halt the program at
the 1000th memory allocation so that we can step through it with a debugger. 
So, set <code>MPATROL_OPTIONS</code> to <code>ALLOCSTOP=1000</code> and load the program
into the debugger.  If you are using <code>gdb</code> you can now do the following
steps, but if you are not you will have to use the equivalent commands in your
debugger.  Note that <code>(gdb)</code> is the debugger command prompt and so anything
that appears on that line after that should be typed as a command.

<pre>(gdb) break __mp_trap
Breakpoint 1 at 0x804ee83
(gdb) run
Starting program: a.out
Breakpoint 1, 0x804ee83 in __mp_trap()
(gdb) backtrace
#0  0x804ee83 in __mp_trap()
#1  0x804c61b in __mp_getmemory()
#2  0x8049894 in __mp_alloc()
#3  0x8049449 in main() at test.c:16
(gdb) finish
Run till exit from #0  0x804ee83 in __mp_trap()
0x804c61b in __mp_getmemory()
(gdb) finish
Run till exit from #0  0x804c61b in __mp_getmemory()
0x8049894 in __mp_alloc()
(gdb) finish
Run till exit from #0  0x8049894 in __mp_alloc()
0x8049449 in main() at test.c:16
16              if (p = malloc(16))
(gdb) step
17                  free(p);
(gdb) step
15          for (i = 0; i &lt; 1000; i++)
(gdb) step
18          free(p);
(gdb) quit
The program is running.  Exit anyway? (y or n) y
</pre>

<p>After setting the breakpoint and running the program, the debugger halts at
<code>__mp_trap()</code>.  Because <code>__mp_trap()</code> is a function within the mpatrol
library, you don't want to bother stepping through any of the library functions,
and in this case you can't since the mpatrol library was not compiled with
debugging information enabled.  So, after returning from all of the library
functions, the source line becomes line 16 because that was the location of the
1000th memory allocation.  Single-stepping twice gets us to line 18 which is our
destination.

<p>Sometimes it is useful to be able to see information about a memory allocation
whilst running a program from within a debugger.  The <code>__mp_printinfo()</code>
function is provided for that purpose and takes a heap address as its only
argument.  Using the above example, it would have been possible to print out
information about the pointer <code>p</code> at line 17 from within <code>gdb</code>:

<pre>(gdb) call __mp_printinfo(p)
address 0x080620E8 located in allocated block:
    start of block:     0x080620E8
    size of block:      16 bytes
    allocated by:       malloc
    allocation index:   1000
    reallocation index: 0
    calling function:   main
    called from file:   test.c
    called at line:     16
    function call stack:
        0x08049449 main
        0x4007C9CB __libc_start_main
        0x08049381 _start
</pre>

<p>Some debuggers, such as <code>gdb</code>, also allow you to define your own
commands for use in a debugging session.  The following example defines a
new <code>gdb</code> command called <code>printalloc</code> which calls
<code>__mp_printinfo()</code><a rel=footnote href="#fn-26"><sup>26</sup></a>:

<pre>(gdb) define printalloc
Type commands for definition of "printalloc".
End with a line saying just "end".
&gt;call __mp_printinfo($arg0)
&gt;end
(gdb) document printalloc
Type documentation for "printalloc".
End with a line saying just "end".
&gt;Displays information about an address in the heap.
&gt;end
</pre>

<p><hr>
Node:<a name="Testing">Testing</a>,
Next:<a rel=next href="#Library%20functions">Library functions</a>,
Previous:<a rel=previous href="#Using%20with%20a%20debugger">Using with a debugger</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.6 Testing</h2>

<p>The mpatrol library has several features that make it useful when testing a
program's dynamic memory allocations.  These are features that do not help in
fixing an existing bug, but rather help to identify additional bugs that may be
lurking in your code.

<p>It is possible to set a simulated upper limit on the amount of heap memory
available to a process with the <code>LIMIT</code> option, which accepts a size in
bytes, but will be disabled when it is zero.  This can be extremely useful for
testing a program under simulated low memory conditions to see how it handles
such errors.  Of course, you should set the heap limit to a value less than the
amount of actual available memory otherwise this option will have no effect. 
Note that the mpatrol library may use up a small amount of heap memory when it
initialises itself<a rel=footnote href="#fn-27"><sup>27</sup></a> so the value passed
to the <code>LIMIT</code> option may need to be set slightly higher than you would
normally expect.

<p>It is also possible to instruct the mpatrol library to randomly fail a certain
number of memory allocations so that you can further test error handling code in
a program.  The frequency at which failures occur can be controlled with the
<code>FAILFREQ</code> option, where a value of zero means that no failures will
occur, but any other value will randomly cause failures.  For example, a value
of <code>10</code> will cause roughly one in ten failures and a value of <code>1</code> will
cause every memory allocation to fail.  The random sequence can be made
predictable by using the <code>FAILSEED</code> option.  If this is non-zero then the
same program run with the same failure frequency and same failure seed will fail
on exactly the same memory allocations.  If this is zero then the failure seed
will itself be set randomly, but you can see its value when the summary is
displayed at program termination.

<p>When running <em>batch tests</em><a rel=footnote href="#fn-28"><sup>28</sup></a> it is sometimes useful to be able to detect if there have been
any memory leaks.  Such leaks should normally be distinguished from code which
has purposely not freed the memory that it allocated, so there may be a certain
expected number of unfreed allocations at program termination.  It may be that
you would like to highlight any additional unfreed allocations since they may be
due to real memory leaks, so the <code>UNFREEDABORT</code> option can be set to a
threshold number of expected unfreed allocations.  If the library detects a
number of unfreed allocations higher than this then it will abort the program at
termination so that it fails.  All tests that fail in this way can then be
examined after the test suite finishes.

<p><hr>
Node:<a name="Library%20functions">Library functions</a>,
Next:<a rel=next href="#Utilities">Utilities</a>,
Previous:<a rel=previous href="#Testing">Testing</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.7 Library functions</h2>

<p>Along with the standard set of C and C++ dynamic memory allocation functions,
the mpatrol library also comes with an additional set of functions which can be
used to provide additional information to your program, and which can be called
at various points in your code for debugging purposes.  You must always include
the <code>mpatrol.h</code> header file in order to use these functions, but you can
check for a specific version of the mpatrol library by checking the
<code>MPATROL_VERSION</code> preprocessor macro.

<p>It is possible to obtain a great deal of information about an existing memory
allocation using the <code>__mp_info()</code> function.  This takes an address as an
argument and fills in any details about its corresponding memory allocation in
a supplied structure.  The following example illustrates this (it can be found
in <code>tests/pass/test4.c</code>).

<pre>23  /*
24   * Demonstrates and tests the facility for obtaining information
25   * about the allocation a specific address belongs to.
26   */


29  #include "mpatrol.h"
30  #include &lt;stdio.h&gt;


33  void display(void *p)
34  {
35      __mp_allocstack *s;
36      __mp_allocinfo d;

38      if (!__mp_info(p, &amp;d))
39      {
40          fprintf(stderr, "nothing known about address 0x%08lX\n", p);
41          return;
42      }
43      fprintf(stderr, "block:   0x%08lX\n", d.block);
44      fprintf(stderr, "size:    %lu\n", d.size);
45      fprintf(stderr, "type:    %lu\n", d.type);
46      fprintf(stderr, "alloc:   %lu\n", d.alloc);
47      fprintf(stderr, "realloc: %lu\n", d.realloc);
48      fprintf(stderr, "func:    %s\n", d.func ? d.func : "NULL");
49      fprintf(stderr, "file:    %s\n", d.file ? d.file : "NULL");
50      fprintf(stderr, "line:    %lu\n", d.line);
51      for (s = d.stack; s != NULL; s = s-&gt;next)
52      {
53          fprintf(stderr, "\t0x%08lX: ", s-&gt;addr);
54          fprintf(stderr, "%s\n", s-&gt;name ? s-&gt;name : "NULL");
55      }
56      fprintf(stderr, "freed:   %d\n", d.freed);
57  }


60  void func2(void)
61  {
62      void *p;

64      if (p = malloc(16))
65      {
66          display(p);
67          free(p);
68      }
69      display(p);
70  }


73  void func1(void)
74  {
75      func2();
76  }


79  int main(void)
80  {
81      func1();
82      return EXIT_SUCCESS;
83  }
</pre>

<p>When this is compiled and run, it should give the following output, although
the pointers are likely to be different.

<pre>block:   0x080620E8
size:    16
type:    0
alloc:   52
realloc: 0
func:    func2
file:    test4.c
line:    73
         0x0804960B: func2
         0x08049658: func1
         0x08049664: main
         0x4007C9CB: __libc_start_main
         0x08049381: _start
freed:   0
nothing known about address 0x080620E8
</pre>

<p>As you can see, anything that the mpatrol library knows about any memory
allocation can be obtained for use in your own code, which can be very useful
if you need to write handlers to keep track of memory allocations, etc. for
debugging purposes.  It can also be useful to have this information when running
your program within a debugger, so you can use the <code>__mp_printinfo()</code>
function to display information about a heap address if your debugger supports
calling functions from the command prompt.

<p>It is also possible for you to be able to intercept calls to allocate,
reallocate and deallocate memory for your own purposes.  You can install
prologue and epilogue functions that the mpatrol library will call before and
after every time one of its functions is called.  These can be used for
additional tracing or simply to add extra checks to your code.  The following
code is an example of this and can be found in <code>tests/pass/test2.c</code>.

<pre>23  /*
24   * Demonstrates and tests the facility for specifying user-defined
25   * prologue and epilogue functions.
26   */


29  #include "mpatrol.h"
30  #include &lt;stdio.h&gt;


33  void prologue(const void *p, size_t l)
34  {
35      if (p == (void *) -1)
36          fprintf(stderr, "allocating %lu bytes\n", l);
37      else if (l == (size_t) -1)
38          fprintf(stderr, "freeing allocation 0x%08lX\n", p);
39      else if (l == (size_t) -2)
40          fprintf(stderr, "duplicating string `%s'\n", p);
41      else
42          fprintf(stderr, "reallocating allocation 0x%08lX to %lu bytes\n", p, l);
43  }


46  void epilogue(const void *p)
47  {
48      if (p != (void *) -1)
49          fprintf(stderr, "allocation returns 0x%08lX\n", p);
50  }


53  int main(void)
54  {
55      void *p, *q;

57      __mp_prologue(prologue);
58      __mp_epilogue(epilogue);
59      if (p = malloc(16))
60          if (q = realloc(p, 32))
61              free(q);
62          else
63              free(p);
64      if (p = (char *) strdup("test"))
65          free(p);
66      return EXIT_SUCCESS;
67  }
</pre>

<p>Once again, if you compile and run the above code, you should see the following
output.

<pre>allocating 16 bytes
allocation returns 0x080620E8
reallocating allocation 0x080620E8 to 32 bytes
allocation returns 0x080620E8
freeing allocation 0x080620E8
duplicating string `test'
allocation returns 0x080620E5
freeing allocation 0x080620E5
</pre>

<p>Along with being able to install prologue and epilogue functions, you can also
install a low-memory handler with the <code>__mp_nomemory()</code> function, which
will be called by the mpatrol library if it ever runs out of memory during the
call to a memory allocation function.  This gives you the opportunity to use
that handler to either free up any unneeded memory or simply to abort, thus
removing the need to check for failed allocations.

<p>Finally, there are three functions which affect the mpatrol library globally. 
The first, <code>__mp_check()</code>, allows you to force an internal check of the
mpatrol library's data structures at any point during program execution and also
to free up any out of scope memory allocations made by the <code>alloca()</code>
family of functions.  The other two functions, <code>__mp_memorymap()</code> and
<code>__mp_summary()</code> allow you to force the generation of a memory map or
library statistics at any point in your program, in much the same way as they
would normally be displayed at the end of program execution.

<p><hr>
Node:<a name="Utilities">Utilities</a>,
Previous:<a rel=previous href="#Library%20functions">Library functions</a>,
Up:<a rel=up href="#Using%20mpatrol">Using mpatrol</a>
<br>

<h2>7.8 Utilities</h2>

<p>Several external programs are supplied with the mpatrol distribution in the
form of commands that can be used to enhance the functionality of the mpatrol
library.  Each command comes with its own UNIX manual page (although they also
support the <code>--help</code> and <code>--version</code> options), but a few of the
commands are written as UNIX shell scripts and so will not work on non-UNIX
platforms.  Note that the <code>mprof</code> command is documented in the profiling
chapter (see <a href="#Profiling">Profiling</a>).

<ul>
<li><a href="#The%20mpatrol%20command">The mpatrol command</a>:          Running with the library. 
<li><a href="#The%20mleak%20command">The mleak command</a>:            Detecting memory leaks. 
<li><a href="#The%20mpsym%20command">The mpsym command</a>:            Obtaining symbolic information. 
<li><a href="#The%20mpedit%20command">The mpedit command</a>:           Editing and listing files. 
</ul>

<p><hr>
Node:<a name="The%20mpatrol%20command">The mpatrol command</a>,
Next:<a rel=next href="#The%20mleak%20command">The mleak command</a>,
Up:<a rel=up href="#Utilities">Utilities</a>
<br>

<h3>7.8.1 The <code>mpatrol</code> command</h3>

<p>A command is provided with the mpatrol distribution which can run programs that
have been linked with the mpatrol library, using a combination of mpatrol
options that can be set via the command line.  Most of these options map
directly onto their equivalent environment variable settings and exist mainly
so that the user does not have to manually change the <code>MPATROL_OPTIONS</code>
environment variable.

<p>The main option that is the exception to this is the <code>--dynamic</code> option,
which can be used to run a program under the control of the mpatrol library,
even if it wasn't originally linked with the mpatrol library.  This can only be
done on systems that support dynamic linking and where the dynamic linker
recognises the <code>LD_PRELOAD</code> or <code>_RLD_LIST</code> environment variables.  Even
then, it can only be used when the program that is being run has been
dynamically linked with the system C library, rather than statically linked.

<p>The reason for all of these limitations is that some SVR4 UNIX platforms have a
special feature in the dynamic linker which can be told to override the symbols
from one shared library using the symbols from another shared library at
run-time.  In this case, it involves replacing the symbols for <code>malloc()</code>,
etc., in the system C library with the mpatrol versions, but only if they were
marked as undefined in the original executable file and would therefore have to
have been loaded from <code>libc.so</code>.

<p>However, if a program qualifies for use with the <code>--dynamic</code> option, it
means that you can trace all of its dynamic memory allocations as well as
running it with any of the mpatrol library's debugging options.  This is mainly
a <em>toy</em> feature which allows you to view and manipulate the dynamic memory
allocations of programs that you don't have the source for, but in theory it
could be quite useful if you need to debug a previously released executable and
are unable to recompile or relink it.  Note that if the program being run is
multithreaded then you must add the <code>--threads</code> option as well.

<p>Note that the <code>mpatrol</code> command must be set up to use the correct
object file format access libraries that are required for your system if you
wish to use the <code>--dynamic</code> option.  If the mpatrol library was built
with <code>FORMAT=FORMAT_ELF32</code> or <code>FORMAT=FORMAT_ELF64</code> support then it
must be told to preload the ELF access library (normally <code>libelf.so</code>).  If
it was built with <code>FORMAT=FORMAT_BFD</code> support then it must be told to
preload the GNU BFD access libraries (normally <code>libbfd.so</code> and
<code>libiberty.so</code>).  However, if these libraries only exist on your system in
archive form then you must build <code>libmpatrol.so</code> with these extra
libraries incorporated into it so that there are no dependencies on them at
run-time.  However, there may well be problems if the resulting shared library
contains position-dependent code from the archive libraries you incorporated. 
The only way to find out is for you to try it and see.

<p>If you have access to the GNU linker on your system then there may be a way to
convert archive libraries into shared libraries if position-independent code is
not necessarily required for building shared libraries on your system.  If you
use the <code>--whole-archive</code> and <code>--shared</code> linker options then the
GNU linker will read the entire contents of one or more archive libraries before
writing out a shared library.  All going well, you should be able to use the new
shared library in conjunction with the <code>--dynamic</code> <code>mpatrol</code>
option.

<p>In order to build a shared version of the mpatrol library with embedded object
file format access libraries, you must first modify the <code>Makefile</code> you
would normally use to build the mpatrol library.  At the lines where the linker
is invoked to build the shared library, you must explicitly add any object file
format access libraries that you want to use at the end of the linker command
line.  This ensures that all references to such libraries will be resolved at
link time rather than run time.  You must then edit the file <code>src/config.h</code>
and remove all of the libraries that you embedded from the definitions of the
<code>MP_PRELOAD_LIBS</code> and <code>MP_PRELOADMT_LIBS</code> preprocessor macros. 
Finally, rebuild the shared version of the mpatrol library and the
<code>mpatrol</code> command and see if your efforts were worth it.

<p>Because the <code>mpatrol</code> command sets the <code>MPATROL_OPTIONS</code> environment
variable for each of the programs it runs, it does not affect the value of the
environment variable for the current process (except on AmigaOS and Netware
where all processes share the same environment).  However, if you wish to use
the <code>mpatrol</code> command to set <code>MPATROL_OPTIONS</code> in the current
process environment then you can use its <code>--show-env</code> option to help you
do so.  This option will apply all of the <code>mpatrol</code> command line options
to the <code>MPATROL_OPTIONS</code> environment variable and then display its value on
the standard output without actually running any programs.  You can then
manually set the environment variable with the output from the <code>mpatrol</code>
command.

<p>If you wish the <code>MPATROL_OPTIONS</code> environment variable to be set in the
current shell process automatically with the <code>mpatrol</code> command then you
must use some shell trickery.  The following script excerpts can be found in
<code>extra/.profile</code>, <code>extra/.cshrc</code> and <code>extra/.gdbinit</code> and can be
inserted into your <code>ksh</code>/<code>bash</code>, <code>csh</code>/<code>tcsh</code>
and <code>gdb</code> configuration files respectively.  They each provide the
<code>mallopt</code> command, which takes <code>mpatrol</code> command options and
sets the <code>MPATROL_OPTIONS</code> environment variable in the current shell or
debugger process.

<pre># mallopt for ksh/bash

function mallopt()
{
    export MPATROL_OPTIONS=`mpatrol --show-env "$@"`
    echo "$MPATROL_OPTIONS"
}

# mallopt for csh/tcsh

alias mallopt 'setenv MPATROL_OPTIONS "`mpatrol --show-env \!*`";
               echo "$MPATROL_OPTIONS"'

# mallopt for gdb

define mallopt
printf "Enter mpatrol library options: "
shell read arg; echo set environment MPATROL_OPTIONS
                `mpatrol --show-env $arg` &gt;/tmp/mpatrol.gdb
source /tmp/mpatrol.gdb
shell rm -f /tmp/mpatrol.gdb
show environment MPATROL_OPTIONS
end
document mallopt
Sets mpatrol library options in the current process environment.
end
</pre>

<p><hr>
Node:<a name="The%20mleak%20command">The mleak command</a>,
Next:<a rel=next href="#The%20mpsym%20command">The mpsym command</a>,
Previous:<a rel=previous href="#The%20mpatrol%20command">The mpatrol command</a>,
Up:<a rel=up href="#Utilities">Utilities</a>
<br>

<h3>7.8.2 The <code>mleak</code> command</h3>

<p>Another utility program that is provided is called <code>mleak</code> and is
useful for detecting memory leaks in log files produced by the mpatrol library. 
This program should be used if the mpatrol library could not finish writing the
log file due to abnormal program termination (which would prevent the
<code>SHOWUNFREED</code> option from working), but note that some of the unfreed
allocations might have been freed if the program had terminated successfully.

<p>The <code>mleak</code> command scans through an mpatrol log file looking for
lines beginning with <code>ALLOC:</code> and <code>FREE:</code> but ignores lines beginning
with <code>REALLOC:</code>, so only the <code>LOGALLOCS</code> and <code>LOGFREES</code>
options are necessary when running a program linked with the mpatrol library. 
Note that as a result of this, no attempt is made to account for resizing of
memory allocations and so the total amount of memory used by the resulting
unfreed allocations may not be entirely accurate.

<p>This command will also read the unfreed allocations table produced by the
<code>SHOWUNFREED</code> option in the log file if one is present.  The entries in
the table will be compared with the currently allocated entries and will be
added if not already present.  However, this behaviour can be disabled by
supplying the <code>--ignore</code> option to the <code>mleak</code> command.

<p>The <code>mleak</code> command takes one optional argument which must be a valid
mpatrol log filename but if it is omitted then it will use <code>mpatrol.log</code> as
the name of the log file to use.  The <code>mleak</code> command makes two passes
over the log file so the file must be randomly-accessible.  If the filename
argument is given as <code>-</code> then the standard input file stream will be used
as the log file.  Note also that the <code>mleak</code> command supports the
<code>--help</code> and <code>--version</code> options in common with the other mpatrol
command line tools.

<p><hr>
Node:<a name="The%20mpsym%20command">The mpsym command</a>,
Next:<a rel=next href="#The%20mpedit%20command">The mpedit command</a>,
Previous:<a rel=previous href="#The%20mleak%20command">The mleak command</a>,
Up:<a rel=up href="#Utilities">Utilities</a>
<br>

<h3>7.8.3 The <code>mpsym</code> command</h3>

<p>Another utility program that is provided is called <code>mpsym</code>, which is
used to parse a log file produced by the mpatrol library and uses a debugger to
append symbol names and source level information to code addresses in stack
tracebacks.  This should be used if the <code>USEDEBUG</code> option is not
supported on a particular platform or does not work properly with a specific
program.  It will replace all existing symbols and source level information
associated with the stack tracebacks in the mpatrol log file and will display
the resulting log file on the standard output file stream.

<p>The first argument to <code>mpsym</code> must be the filename of the executable
file that produced the mpatrol log file but if it is omitted then
<code>mpsym</code> will use <code>a.out</code> as the name of the executable file to use. 
The <code>mpsym</code> command will read the symbol table and debugging sections
from this file in order to map the code addresses that appear in the mpatrol log
file into symbol names and source level information.  If the executable file
does not contain a symbol table then no symbol names will be available and if it
does not contain the appropriate debugging sections then no source level
information will be available either.  Obviously, if the executable file is not
the same as the one that created the mpatrol log file then the final output will
be wrong.

<p>The second argument to <code>mpsym</code> must be a valid mpatrol log filename but
if it is omitted then <code>mpsym</code> will use <code>mpatrol.log</code> as the name of
the log file to use.  The <code>mpsym</code> command makes two passes over the log
file so the file must be randomly-accessable.  Note also that the
<code>mpsym</code> command supports the <code>--help</code> and <code>--version</code>
options in common with the other mpatrol command line tools.

<p>The <code>mpsym</code> command currently uses <code>gdb</code> as the debugger with
which to obtain the additional information about the code addresses in the
mpatrol log file.  It also makes use of several UNIX text processing commands in
order to extract information from the debugger's output and from the log file. 
As a result, the <code>mpsym</code> command is only likely to work on UNIX
platforms or on systems which have the necessary commands installed.  By
default, it is set up to work on 32-bit platforms, but this can be changed by
altering the <code>POINTER</code> definition in the <code>mpsym</code> file itself.

<p><hr>
Node:<a name="The%20mpedit%20command">The mpedit command</a>,
Previous:<a rel=previous href="#The%20mpsym%20command">The mpsym command</a>,
Up:<a rel=up href="#Utilities">Utilities</a>
<br>

<h3>7.8.4 The <code>mpedit</code> command</h3>

<p>The final utility program that is provided is called <code>mpedit</code>, which is
used to invoke a text editor on a given source file and optionally jump to a
specific line number.  It is used as a support command by the mpatrol library
when the <code>EDIT</code> or <code>LIST</code> options are used but it can quite easily
be used as a command in its own right if properly configured.  Because it is a
shell script it can be easily configured to support other editors, but this
unfortunately limits it to UNIX platforms at the moment.

<p>The first argument to <code>mpedit</code> must be the filename of the source file
to be edited or listed.  If the source file does not exist then the contents of
the <code>MPATROL_SOURCEPATH</code> environment variable will be used to help locate
the source file, even if the filename contained an absolute or relative path
component.  This environment variable should consist of a colon-separated list
of directory names which may contain absolute paths or be relative to the
current directory; the first directory in the list will be searched first.  If
the <code>MPATROL_SOURCEPATH</code> environment variable is not set then only the
current directory will be searched.  You can also use the <code>--source-dir</code>
option to add directories to the search path used to locate the source file. 
Multiple <code>--source-dir</code> options may be given, and each will be prepended
to the <code>MPATROL_SOURCEPATH</code> environment variable in the order given on the
command line.

<p>If the second argument specifying the line number is omitted then it is assumed
to be <code>1</code>.  The text editor will attempt to jump to the specified line
after opening the source file.  The text editor that <code>mpedit</code> uses is
controlled by setting the <code>EDITOR</code> environment variable.  This can be set to
the full pathname of the text editor to use or it can be set to the command that
would normally be used to invoke the text editor, but it cannot also contain
command line options.  You can also use the <code>--editor</code> option to specify
the text editor on the command line instead of using the value in the
<code>EDITOR</code> environment variable.

<p>The currently supported editors are <code>vi</code>, <code>vim</code>, <code>emacs</code>
and <code>xemacs</code>, and if the <code>EDITOR</code> environment variable is not set
then the default will be <code>vi</code>.  Selecting an unsupported text editor
will result in an error.  However, you can edit the <code>mpedit</code> file to add
support for your own favourite text editor as long as it supports a way to
immediately jump to a specific line number when it is first started up.  Note
that the text editor must also open a new window to edit the source file so that
it does not obscure any mpatrol diagnostic messages, and if it does not support
this then a new terminal window must be opened for it to use.

<p>If the <code>--listing</code> option is given on the command line then the
<code>mpedit</code> command will display a context listing of the source file at
the specified line number to the standard error output stream instead of
invoking the text editor.  The listing will be annotated with line numbers and
will also show the contents of the five lines before and after the specified
line if possible.  Note also that the <code>mpedit</code> command supports the
<code>--help</code> and <code>--version</code> options in common with the other mpatrol
command line tools.

<p><hr>
Node:<a name="Profiling">Profiling</a>,
Next:<a rel=next href="#Improving%20performance">Improving performance</a>,
Previous:<a rel=previous href="#Using%20mpatrol">Using mpatrol</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>8 Profiling</h1>

<p>The mpatrol library has the capability to summarise the information it
accumulated about the behaviour of dynamic memory allocations and deallocations
over the lifetime of any program that it was linked and run with.  This summary
shows a rough profile of all memory allocations that were made, and is hence
called <em>profiling</em>.  There are several other different kinds of profiling
provided with most compilation tools, but they generally profile function calls
or line numbers in combination with the time it takes to execute them.

<p>Memory allocation profiling is useful since it allows a programmer to see which
functions directly allocate memory from the heap, with a view to optimising the
memory usage or performance of a program.  It also summarises any unfreed memory
allocations that were present at the end of program execution, some of which
could be as a result of memory leaks.  In addition, a summary of the sizes and
distribution of all memory allocations and deallocations is available.

<p>A memory allocation call graph is also available for the programmer to be able
to see the caller and callee relationships for all functions that allocated
memory, either directly or indirectly.  This graph is shown in a tabular form
similar to that of <code>gprof</code>, but it can also be written to a graph
specification file for later processing by <code>dot</code>.  The <code>dot</code>
and <code>dotty</code> commands are part of GraphViz, an excellent graph
visualisation package that was developed at AT&amp;T Bell Labs and is available for
free download for UNIX and Windows platforms from
<a href="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</a>.

<p>Only allocations and deallocations are recorded, with each reallocation being
treated as a deallocation immediately followed by an allocation.  For full
memory allocation profiling support, call stack traversal must be supported in
the mpatrol library and all of the program's symbols must have been successfully
read by the mpatrol library before the program was run.  The library will
attempt to compensate if either of these requirements are not met, but the
displayed tables may contain less meaningful information.  Cycles that appear in
the allocation call graph are due to recursion and are currently dealt with by
only recording the memory allocations once along the call stack.

<p>Memory allocation profiling is disabled by default, but can be enabled using
the <code>PROF</code> option.  This writes all of the profiling data to a file
called <code>mpatrol.out</code> in the current directory at the end of program
execution, but the name of this file can be changed using the <code>PROFFILE</code>
option and the default directory in which to place these files can be changed
by setting the <code>PROFDIR</code> environment variable.  Sometimes it can also be
desirable for the mpatrol library to write out the accumulated profiling
information in the middle of program execution rather than just at the end, even
if it is only partially complete, and this behaviour can be controlled with the
<code>AUTOSAVE</code> option.  This can be particularly useful when running the
program from within a debugger, when it is necessary to analyse the profiling
information at a certain point during program execution.

<p>Normally, the mpatrol library will perform profiling with all of its other
features and checks enabled, but you might want to disable these if you only
wish to profile the memory allocations.  For example, you may wish to use the
<code>CHECK=0</code> and <code>NOPROTECT</code> options to remove the internal checking
of the library and speed up profiling dramatically.

<p>When profiling memory allocations, it is necessary to distinguish between small,
medium, large and extra large memory allocations that were made by a function. 
The boundaries which distinguish between these allocation sizes can be
controlled via the <code>SMALLBOUND</code>, <code>MEDIUMBOUND</code> and
<code>LARGEBOUND</code> options, but they default to 32, 256 and 2048 bytes
respectively, which should suffice for most circumstances.

<p>The <code>mprof</code> command is a tool designed to read a profiling output file
produced by the mpatrol library and display the profiling information that was
obtained.  The profiling information includes summaries of all of the memory
allocations listed by size and the function that allocated them and a list of
memory leaks with the call stack of the allocating function.  It also
includes a graph of all memory allocations listed in tabular form, and an
optional graph specification file for later processing by the <code>dot</code>
graph visualisation package.

<p>The <code>mprof</code> command also attempts to calculate the endianness of the
processor that produced the profiling output file and reads the file
accordingly.  This means that it is possible to use <code>mprof</code> on a SPARC
machine to read a profiling output file that was produced on an Intel 80x86
machine, for example.  However, this will only work if the processor that
produced the profiling output file has the same word size as the processor that
is running the <code>mprof</code> command.  For example, reading a 64-bit profiling
output file on a 32-bit machine will not work.

<p>In addition, the profiling output file also contains the version number of the
mpatrol library which produced it.  If the major version number that is embedded
in the profiling output file is newer that the version of mpatrol that
<code>mprof</code> came with then <code>mprof</code> will refuse to read the file. 
You should download the latest version of mpatrol in that case.  The reason for
storing the version number is so that the format of the profiling output file
can change between releases of mpatrol, but also allow <code>mprof</code> to cope
with older versions.

<p>Along with the options listed below, the <code>mprof</code> command takes one
optional argument which must be a valid mpatrol profiling output filename but
if it is omitted then it will use <code>mpatrol.out</code> as the name of the file to
use.  If the filename argument is given as <code>-</code> then the standard input
file stream will be used as the profiling output file.  Note also that the
<code>mprof</code> command supports the <code>--help</code> and <code>--version</code>
options in common with the other mpatrol command line tools.

<dl>
<dt><code>--addresses</code>
<dd>Specifies that different call sites from within the same function are to be
differentiated and that the names of all functions should be displayed with
their call site offset in bytes.  This affects the direct allocation and memory
leak tables, as well as the allocation call graph and the graph specification
file.

<br><dt><code>--counts</code>
<dd>Specifies that certain tables should be sorted by the number of allocations or
deallocations rather than the total number of bytes allocated or deallocated. 
This affects the direct allocation and memory leak tables, as well as the
allocation call graph and the graph specification file.

<br><dt><code>--graph-file</code> &lt;<var>file</var>&gt;
<dd>Specifies that the allocation call graph should also be written to a graph
specification file for later visualisation with <code>dot</code>.  If <var>file</var> is
given as <code>stdout</code> or <code>stderr</code> then the corresponding file stream will
be used as the target for the graph specification file.

<br><dt><code>--leaks</code>
<dd>Specifies that memory leaks rather than memory allocations are to be written to
the graph specification file.  This option only affects the output from the
<code>--graph-file</code> option.

<br><dt><code>--stack-depth</code> &lt;<var>depth</var>&gt;
<dd>Specifies the maximum stack depth to use when calculating if one call site has
the same call stack as another call site.  This also specifies the maximum
number of functions to display in a call stack.  If <var>depth</var> is <code>0</code> then
the call stack depth will be unlimited in size.  The default call stack depth
is <code>1</code>.  This affects the memory leak table. 
</dl>

<p>We'll now look at an example of using the mpatrol library to profile the dynamic
memory allocations in a program.  However, remember that this example will only
fully work on your machine if the mpatrol library supports call stack traversal
and reading symbols from executable files on that platform.  If that is not the
case then only some of the features will be available.

<p>The following example program performs some simple calculations and displays a
list of numbers on its standard output file stream, but it serves to illustrate
all of the different features of memory allocation profiling that mpatrol is
capable of.  The source for the program can be found in
<code>tests/profile/test1.c</code>.

<pre>23  /*
24   * Associates an integer value with its negative string equivalent in a
25   * structure, and then allocates 256 such pairs randomly, displays them
26   * then frees them.
27   */


30  #include &lt;stdio.h&gt;
31  #include &lt;stdlib.h&gt;
32  #include &lt;string.h&gt;


35  typedef struct pair
36  {
37      int value;
38      char *string;
39  }
40  pair;


43  pair *new_pair(int n)
44  {
45      static char s[16];
46      pair *p;

48      if ((p = (pair *) malloc(sizeof(pair))) == NULL)
49      {
50          fputs("Out of memory\n", stderr);
51          exit(EXIT_FAILURE);
52      }
53      p-&gt;value = n;
54      sprintf(s, "%d", -n);
55      if ((p-&gt;string = strdup(s)) == NULL)
56      {
57          fputs("Out of memory\n", stderr);
58          exit(EXIT_FAILURE);
59      }
60      return p;
61  }


64  int main(void)
65  {
66      pair *a[256];
67      int i, n;

69      for (i = 0; i &lt; 256; i++)
70      {
71          n = (int) ((rand() * 256.0) / (RAND_MAX + 1.0)) - 128;
72          a[i] = new_pair(n);
73      }
74      for (i = 0; i &lt; 256; i++)
75          printf("%3d: %4d -&gt; \"%s\"\n", i, a[i]-&gt;value, a[i]-&gt;string);
76      for (i = 0; i &lt; 256; i++)
77          free(a[i]);
78      return EXIT_SUCCESS;
79  }
</pre>

<p>After the above program has been compiled and linked with the mpatrol library,
it should be run with the <code>PROF</code> option set in the <code>MPATROL_OPTIONS</code>
environment variable.  Note that <code>mpatrol.h</code> was not included as it is not
necessary for profiling purposes.

<p>If all went well, a list of numbers should be displayed on the screen and a file
called <code>mpatrol.out</code> should have been produced in the current directory. 
This is a binary file containing the total amount of profiling information that
the mpatrol library gathered while the program was running, but it contains
concise numerical data rather than human-readable data.  To make use of this
file, the <code>mprof</code> command must be run.  An excerpt from the output
produced when running <code>mprof</code> with no options is shown below.

<pre>                             ALLOCATION BINS

                          (number of bins: 1024)

                  allocated                          unfreed
       --------------------------------  --------------------------------
 size   count       %     bytes       %   count       %     bytes       %

    2       9    1.76        18    0.61       9    3.52        18    1.95
    3     105   20.51       315   10.61     105   41.02       315   34.16
    4     121   23.63       484   16.30     121   47.27       484   52.49
    5      21    4.10       105    3.54      21    8.20       105   11.39
    8     256   50.00      2048   68.96       0    0.00         0    0.00

total     512              2970             256               922
</pre>

<pre>                            DIRECT ALLOCATIONS

                 (0 &lt; s &lt;= 32 &lt; m &lt;= 256 &lt; l &lt;= 2048 &lt; x)

       allocated                       unfreed
--------------------------  --------------------------
bytes       %   s  m  l  x  bytes       %   s  m  l  x  count  function

 2970  100.00  %%             922  100.00  %%             512  new_pair

 2970          %%             922          %%             512  total
</pre>

<pre>                               MEMORY LEAKS

                         (maximum stack depth: 1)

                unfreed                      allocated
----------------------------------------  ----------------
     %     bytes       %   count       %     bytes   count  function

100.00       922   31.04     256   50.00      2970     512  new_pair

             922   31.04     256   50.00      2970     512  total
</pre>

<pre>                          ALLOCATION CALL GRAPH

                         (number of vertices: 3)

           allocated               unfreed
     ---------------------  ---------------------
index   bytes   s  m  l  x     bytes   s  m  l  x  function
-------------------------------------------------
[1]                                                _start [1]
         2970  %%                922  %%               main [3]
-------------------------------------------------
         2970  %%                922  %%               main [3]
[2]                                                new_pair [2]
-------------------------------------------------
         2970  %%                922  %%               _start [1]
[3]                                                main [3]
         2970  %%                922  %%               new_pair [2]
</pre>

<p>The first table shown is the allocation bin table which summarises the sizes of
all objects that were dynamically allocated throughout the lifetime of the
program.  In this particular case, counts of all allocations and deallocations
of sizes 1 to 1023 bytes were recorded by the mpatrol library in their own
specific <em>bin</em> and this information was written to the profiling output
file.  Allocations and deallocations of sizes larger than or equal to 1024 bytes
are counted as well and the total number of bytes that they represent are also
recorded.  This information can be extremely useful in understanding which sizes
of data structures are allocated most during program execution, and where
changes might be made to make more efficient use of the dynamically allocated
memory.

<p>As can be seen from the allocation bin table, 9 allocations of 2 bytes, 105
allocations of 3 bytes, 121 allocations of 4 bytes, 21 allocations of 5 bytes
and 256 allocations of 8 bytes were made during the execution of the program. 
However, all of these memory allocations except the 8 byte allocations were
still not freed by the time the program terminated, resulting in a total memory
leak of 922 bytes.

<p>The next table shown is the direct allocation table which lists all of the
functions that allocated memory and how much memory they allocated.  The
<code>s m l x</code> columns represent <em>small</em>, <em>medium</em>, <em>large</em> and
<em>extra large</em> memory allocations, which in this case are 0 bytes is less
than a small allocation, which is less than or equal to 32 bytes, which is less
than a medium allocation, which is less than or equal to 256 bytes, which is
less than a large allocation, which is less than or equal to 2048 bytes, which
is less than an extra large allocation.  The numbers listed under these columns
represent a percentage of the overall total and are listed as <code>%%</code> if
the percentage is 100% or as <code>.</code> if the percentage is less than 1%. 
Percentages of 0% are not displayed.

<p>The information displayed in the direct allocation table is useful for seeing
exactly which functions in a program directly perform memory allocation, and can
quickly highlight where optimisations can be made or where functions might be
making unnecessary allocations.  In the example, this table shows us that 2970
bytes were allocated over 512 calls by <code>new_pair()</code> and that 922 bytes were
left unfreed at program termination.  All of the allocations that were made by
<code>new_pair()</code> were between 1 and 32 bytes in size.

<p>We could now choose to sort the direct allocation table by the number of calls
to allocate memory, rather than the number of bytes allocated, with the
<code>--counts</code> option to <code>mprof</code>, but that is not relevant in this
example.  However, we know that there are two calls to allocate memory from
<code>new_pair()</code>, so we can use the <code>--addresses</code> option to
<code>mprof</code> to show all call sites within functions rather than just the
total for each function.  This option does not affect the allocation bin table
so the new output from <code>mprof</code> with the <code>--addresses</code> option
looks like:

<pre>                            DIRECT ALLOCATIONS

                 (0 &lt; s &lt;= 32 &lt; m &lt;= 256 &lt; l &lt;= 2048 &lt; x)

       allocated                       unfreed
--------------------------  --------------------------
bytes       %   s  m  l  x  bytes       %   s  m  l  x  count  function

 2048   68.96  69               0    0.00                 256  new_pair+20
  922   31.04  31             922  100.00  %%             256  new_pair+140

 2970          %%             922          %%             512  total
</pre>

<pre>                               MEMORY LEAKS

                         (maximum stack depth: 1)

                unfreed                      allocated
----------------------------------------  ----------------
     %     bytes       %   count       %     bytes   count  function

100.00       922  100.00     256  100.00       922     256  new_pair+140

             922   31.04     256   50.00      2970     512  total
</pre>

<pre>                          ALLOCATION CALL GRAPH

                         (number of vertices: 4)

           allocated               unfreed
     ---------------------  ---------------------
index   bytes   s  m  l  x     bytes   s  m  l  x  function
-------------------------------------------------
[1]                                                _start+100 [1]
         2970  %%                922  %%               main+120 [4]
-------------------------------------------------
         2048  %%                  0                   main+120 [4]
[2]                                                new_pair+20 [2]
-------------------------------------------------
          922  %%                922  %%               main+120 [4]
[3]                                                new_pair+140 [3]
-------------------------------------------------
         2970  %%                922  %%               _start+100 [1]
[4]                                                main+120 [4]
         2048  %%                  0                   new_pair+20 [2]
          922  %%                922  %%               new_pair+140 [3]
</pre>

<p>The names of the functions displayed in the above tables now have a byte offset
appended to them to indicate at what position in the function a call to allocate
memory occurred<a rel=footnote href="#fn-29"><sup>29</sup></a>.  Now it is possible to see that the first call to allocate memory
from within <code>new_pair()</code> has had all of its memory freed, but the second
call (from <code>strdup()</code>) has had none of its memory freed.

<p>This is also visible in the next table, which is the memory leak table and lists
all of the functions that allocated memory but did not free all of their memory
during the lifetime of the program.  The default behaviour of <code>mprof</code> is
to show only the function that directly allocated the memory in the memory leak
table, but this can be changed with the <code>--stack-depth</code> option.  This
accepts an argument specifying the maximum number of functions to display in
one call stack, with zero indicating that all functions in a call stack should
be displayed.  This can be useful for tracing down the functions that were
indirectly responsible for the memory leak.  The new memory leak table displayed
by <code>mprof</code> with the <code>--addresses</code> and <code>--stack-depth 0</code>
options looks like:

<pre>                               MEMORY LEAKS

                         (maximum stack depth: 0)

                unfreed                      allocated
----------------------------------------  ----------------
     %     bytes       %   count       %     bytes   count  function

100.00       922  100.00     256  100.00       922     256  new_pair+140
                                                            main+120
                                                            _start+100

             922   31.04     256   50.00      2970     512  total
</pre>

<p>Now that we know where the memory leak is coming from, we can fix it by freeing
the string as well as the structure at line 77.  A version of the above
program that does not contain the memory leak can be found in
<code>tests/profile/test2.c</code>.

<p>The final table that is displayed is the allocation call graph, which shows the
relationship between a particular function in the call graph, the functions that
called it (parents), and the functions that it called (children).  Every
function that appears in the allocation call graph is displayed with a
particular index that can be used to cross-reference it.  The functions which
called a particular function are displayed directly above it, while the
functions that the function called are displayed directly below it.  In the
above example, <code>_start()</code> called <code>main()</code>, which then called
<code>new_pair()</code> which allocated the memory.

<p>The memory that has been allocated by a function (either directly, or indirectly
by its children) for its parents is shown in the details for the parent
functions, showing both a breakdown of the allocated memory and a breakdown of
the unfreed memory.  This also occurs for the child functions.  If a function
does not directly allocate memory then the total memory allocated for its
parents will equal the total memory allocated by its children.  However, if a
parent or child function is part of a cycle in the call graph then a <code>(*)</code>
will appear in the leftmost column of the call graph.  In that case the total
incoming memory may not necessarily equal the total outgoing memory for the main
function.

<p>In the example above when the <code>--addresses</code> option is used, it should be
clear that <code>new_pair()+20</code> allocates 2048 bytes for <code>main()</code>, while
<code>new_pair()+140</code> allocates 922 bytes for <code>main()</code>.  The <code>main()</code>
function itself allocates 2970 bytes for <code>_start()</code> overall via the
<code>new_pair()</code> function.

<p>It is also possible to view this information graphically if you have the
GraphViz package mentioned above installed on your system.  The
<code>--graph-file</code> option can be used to write a <code>dot</code> graph
specification file that can be processed by the <code>dot</code> or <code>dotty</code>
commands that come with GraphViz.  The resulting graphs will show the
relationships between each function, its parents and its children, and will also
show the number of bytes that were allocated along the edges of the call graph,
but this can be changed to the number of calls if the <code>--counts</code> option
is used<a rel=footnote href="#fn-30"><sup>30</sup></a>.  A call graph showing unfreed memory
instead of allocated memory can be generated by adding the <code>--leaks</code>
option. 
The following graph illustrates the use of these options with the above example. 
It was generated using the <code>--addresses</code> and <code>--graph-file</code>
options.

<img src="images/test.jpg" alt="images/test.jpg">

<p>As a final demonstration of mpatrol's profiling features we will attempt to
profile a real application in order to see where the memory allocations come
from.  Since all of the following steps were performed on a Solaris machine, the
<code>--dynamic</code> option of the <code>mpatrol</code> command was used to allow us
to replace the system memory allocation routines with mpatrol's routines without
requiring a relink.  It also means that we can profile all of the child
processes that were created by the application as well.

<p>The application that we are going to profile is the GNU C compiler,
<code>gcc</code> (version 2.95.2), which is quite a complicated and large program. 
The actual <code>gcc</code> command is really the compiler driver which invokes the
C preprocessor followed by the compiler, the assembler, the prelinker and
finally the linker (well, it does in this example).  On Solaris, the
<code>gcc</code> distribution uses the system assembler and linker which come with
no symbol tables in their executable files so we will not be profiling them.

<p>For the purpose of this demonstration we will only be looking at the graph
files produced by the <code>--graph-file</code> option of the <code>mprof</code>
command, but ordinarily you would want to look at the tables that
<code>mprof</code> produces as well.  All of the command line examples use the
<code>bash</code> shell but in most cases these will work in other shells with
a minimal amount of changes.

<p>We will use <code>tests/profile/test2.c</code> as the source file to compile with
<code>gcc</code> and we'll turn on optimisation in order to cause <code>gcc</code> to
allocate a bit more memory than it would normally.  When running it through the
<code>mpatrol</code> command we also use <code>--check=0</code> so that we disable
mpatrol's internal checks -- we don't need them if we are only profiling.  Note
that use is also made of the format string feature of the <code>--log-file</code>
and <code>--prof-file</code> options so that it is clear which mpatrol log and
profiling output files belong to which processes.

<pre>bash$ mpatrol --dynamic --log-file=%p.log --prof-file=%p.out
              --prof --check=0 gcc -O -o test2 test2.c
bash$ ls *.log *.out
as.log         cc1.out        cpp.log        gcc.out
as.out         collect2.log   cpp.out        ld.log
cc1.log        collect2.out   gcc.log        ld.out
</pre>

<p>As mentioned above, we're not interested in the mpatrol log and profiling
output files for <code>as</code> and <code>ld</code> so we'll delete them.  We can
now use <code>mprof</code> to create graph specification files for each of the
profiling output files produced.  You can find these graph specification files
and the profiling output files used to generate them in the <code>extra</code>
directory in the mpatrol distribution.

<pre>bash$ rm as.log as.out ld.log ld.out
bash$ ls *.out
cc1.out        collect2.out   cpp.out        gcc.out
bash$ for file in *.out
&gt; do
&gt;     mprof --graph-file=`basename $file .out`.dot $file
&gt; done &gt;/dev/null
bash$ ls *.dot
cc1.dot        collect2.dot   cpp.dot        gcc.dot
</pre>

<p>The graph specification files that have now been produced can be viewed and
manipulated with the <code>dotty</code> command, or they can be converted to
various image formats with the <code>dot</code> command.  However, this presumes
that you already have the GraphViz graph visualisation package installed.  If
you have then you can convert the graph specification files to GIF and
postscript images using the following commands. 
If not, you can still view the graphs produced in the following figures.

<pre>bash$ dot -Tgif -Gsize="6,3" -Gratio=fill -o gcc.gif gcc.dot
bash$ dot -Tgif -Gsize="6,3" -Gratio=fill -o cpp.gif cpp.dot
bash$ dot -Tgif -Gsize="7,4" -Gratio=fill -o cc1.gif cc1.dot
bash$ dot -Tgif -Gsize="4,3" -Gratio=fill -o collect2.gif collect2.dot
bash$ dot -Tps -Gsize="6,3" -Gratio=fill -o gcc.ps gcc.dot
bash$ dot -Tps -Gsize="6,3" -Gratio=fill -o cpp.ps cpp.dot
bash$ dot -Tps -Gsize="9,6" -Gratio=fill -Grotate=90 -o cc1.ps cc1.dot
bash$ dot -Tps -Gsize="4,3" -Gratio=fill -o collect2.ps collect2.dot
</pre>

<img src="images/gcc.jpg" alt="images/gcc.jpg">

<p>The figure above shows the allocation call graph for the <code>gcc</code> compiler
driver.  From the graph you can see that the vast majority of memory allocations
appear to be required for reading the driver specification file, which details
default options and platform-specific features.  Almost all of the memory
allocations go through the <code>xmalloc()</code> routine, which is an error-checking
function built on top of <code>malloc()</code>.  A large amount of memory is also
allocated by the <em>obstack</em> module, which provides a functionality similar
to <em>arenas</em> for variable-sized data structures.  You'll see extensive use
of both of these types of routines throughout the following graphs.

<img src="images/cpp.jpg" alt="images/cpp.jpg">

<p>As would be expected, in the above allocation call graph for the <code>cpp</code>
C preprocessor, the majority of memory allocations are used for macro
processing, with a sizable chunk being allocated for reading include files. 
You may also notice the dotted lines that connect the <code>rescan()</code>,
<code>handle_directive()</code>, <code>do_include()</code> and <code>finclude()</code>
functions<a rel=footnote href="#fn-31"><sup>31</sup></a>.  These
show a cycle in the call graph where each of these functions may have been
involved in one or more recursive calls.  The labels for such dotted edges may
not be entirely accurate since <code>mprof</code> will only count allocated memory
once for each recursive call chain.

<p>The following figure shows the allocation call graph for the <code>cc1</code>
compiler itself.  As you would expect, it's a bit of a beast compared to the
previous two graphs, and looks very hard to follow.  However, if you look closer
you will notice that the various groups of functions that comprise the compiler
stand out due to their close association with one another.  For example, you
might notice that the functions between <code>cse_insn()</code> and
<code>get_cse_reg_info()</code> form a group that allocates 9140 bytes overall.  You
can also see the parser module at the top left of the graph, initiated with
<code>yyparse()</code>, and the code generator module in the rest of the graph,
initiated with <code>rest_of_compilation()</code>.

<img src="images/cc1.jpg" alt="images/cc1.jpg">

<img src="images/collect2.jpg" alt="images/collect2.jpg">

<p>The allocation call graph for the prelinker, <code>collect2</code>, is a lot
simpler than the previous graphs.  There are no cycles in the graph and most of
the allocations are concerned with maintaining hash tables.  Once again,
<code>xmalloc()</code> and <code>_obstack_begin()</code> are the two main sources of memory
allocation.

<p>As can be seen, a lot of information about the memory allocation behaviour of
a program can be obtained by creating a visual image of the allocation call
graph.  In addition, different graphs can be produced to show call counts
instead of allocated bytes (via the <code>--counts</code> option), and graphs of
unfreed memory can be produced to detect where memory leaks come from (via the
<code>--leaks</code> option).

<p>Much of the functionality of this implementation of memory allocation profiling
is based upon <code>mprof</code> by Benjamin Zorn and Paul Hilfinger, which was
written as a research project and ran on MIPS, SPARC and VAX machines.  However,
the profiling output files are incompatible, the tables displayed have a
different format, and the way they are implemented is entirely different.

<p><hr>
Node:<a name="Improving%20performance">Improving performance</a>,
Next:<a rel=next href="#How%20it%20works">How it works</a>,
Previous:<a rel=previous href="#Profiling">Profiling</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>9 Improving performance</h1>

<p>Because of their need to cover every eventuality, malloc library implementations
are very general and most do their job well when you consider what is thrown at
them.  However, your program may not be performing as well as it should simply
because there may be a more efficient way of dealing with dynamic memory
allocations.  Indeed, there may even be a more efficient malloc library
available for you to use.

<p>If you need to allocate lots of blocks of the same size<a rel=footnote href="#fn-32"><sup>32</sup></a>, but you won't know the number of blocks you'll require until
run-time then you could take the easy approach by simply allocating a new block
of memory for each occurrence.  However, this is going to create a lot of
(typically small) memory blocks that the underlying malloc library will have to
keep track of, and even in many good malloc libraries this is likely to cause
memory fragmentation and possibly even result in the blocks scattered throughout
the address space rather than all in the one place, which is not necessarily a
good thing on systems with virtual memory.

<p>An alternative approach would be to allocate memory in multiples of the block
size, so that several blocks would be allocated at once.  This would require
slightly more work on your part since you would need to write interface code to
return a single block, while possible allocating space for more blocks if no
free blocks were available.  However, this approach has several advantages.  The
first is that the malloc library only needs to keep track of a few large
allocations rather than lots of small allocations, so splitting and merging free
blocks is less likely to occur.  Secondly, your blocks will be scattered about
less in the address space of the process, which means that on systems with
virtual memory there are less likely to be page faults if you need to access or
traverse all of the blocks you have created.

<p>A memory allocation concept that is similar to this is called an <em>arena</em>. 
This datatype requires functions which are built on top of the existing malloc
library functions and which associate each memory allocation with a particular
arena.  An arena can have as many allocations added to it as required, but
allocations cannot usually be freed until the whole arena is freed.  Note that
there are not really any generic implementations of arenas that are available as
everyone tends to write their own version when they require it, although Digital
UNIX and SGI IRIX systems do come with an arena library called <em>amalloc</em>.

<p>However, what if you don't plan to free all of the blocks at the same time?  A
slight modification to the above design could be to have a <em>slot table</em>. 
This would involve allocating chunks of blocks as they are required, adding each
individual block within a chunk to a singly-linked list of free blocks.  Then,
as new blocks are required, the allocator would simply choose the first block on
the free list, otherwise it would allocate memory for a new chunk of blocks and
add them to the free list.  Freeing individual blocks would simply involve
returning the block to the free list.  If this description isn't clear enough,
have a look in <code>src/slots.h</code> and <code>src/slots.c</code>.  This is how the
mpatrol library allocates memory from the system for all of its internal
structures.  For variable-sized structures, a slightly different approach needs
to be taken, but for an example of this using strings see <code>src/strtab.h</code>
and <code>src/strtab.c</code>.

<p>Another optimisation that is possible on UNIX and Windows platforms is making
use of memory-mapped files.  This allows you to map a filesystem object into the
address space of your process, thus allowing you to treat a file as an array of
bytes.  Because it uses the virtual memory system to map the file, any changes
you make to the mapped memory will be applied to the file.  This is implemented
through the virtual memory system treating the file as a pseudo swap file and
will therefore only use up physical memory when pages are accessed.  It also
means that file operations can be replaced by memory read and write operations,
leading to a very fast and efficient way of performing I/O.  Another added
bonus of this system means that entire blocks of process memory can be written
to a file for later re-use, just as long as the file can later be mapped to the
same address.  This can be a lot faster than writing to and reading from a
specific format of file.

<p>If you really don't want to keep track of dynamic memory allocations at all then
perhaps you should consider <em>garbage collection</em>.  This allows you to make
dynamic memory allocations that need not necessarily be matched by corresponding
calls to free these allocations.  A garbage collector will (at certain points
during program execution) attempt to look for memory allocations that are no
longer referenced by the program and free them for later re-use, hence removing
all possibility of memory leaks.  However, the garbage collection process can
take a sizable chunk of processor time depending on how large the program is, so
it is not really an option for real-time programming.  It is also very
platform-dependent as it examines very low-level structures within a process in
order to determine which pointers point to which memory allocations.  But there
is at least one garbage collector<a rel=footnote href="#fn-33"><sup>33</sup></a> that works well with C and C++ and acts
as a replacement for <code>malloc()</code> and <code>free()</code>, so it may be the ideal
solution for you.

<p>If you do choose to use an alternative malloc library make sure that you have a
license to do so and that you follow any distribution requirements.  On systems
that support dynamic linking you may want to link the library statically rather
than dynamically so that you don't have to worry about an additional file that
would need to be installed.  However, whether you have that choice depends on
the license for the specific library, and some licenses also require that the
source code for the library be made readily available.  Shared libraries have
the advantage that they can be updated with bug fixes so that all programs that
require these libraries will automatically receive these fixes without needing
to be relinked.

<p>If all of the above suggestions do not seem to help and you still feel that you
have a performance bottleneck in the part of your code that deals with
dynamically allocated memory then you should try using the memory allocation
profiling feature of mpatrol.  This can be used at run-time to analyse the
dynamic memory allocation calls that your program makes during its execution,
and builds statistics for later viewing with the <code>mprof</code> command.  It is
then possible for you to see exactly how many calls were made to each function
and where they came from.  Such information can then be put to good use in order
to optimise the relevant parts of your code.  The tracing output files that can
be produced by the mpatrol library may also be useful in order to view patterns
in memory allocation behaviour and gather information about lifetimes of memory
allocations.

<p>And finally, some tips on how to correctly use dynamic memory allocations.  The
first, most basic rule is to <em>always</em> check the return values from
<code>malloc()</code> and related functions.  <em>Never</em> assume that a call to
<code>malloc()</code> will succeed, because you're unlikely to be able to read the
future<a rel=footnote href="#fn-34"><sup>34</sup></a>.  Alternatively, use (or write) an <code>xmalloc()</code> or similar function,
which calls <code>malloc()</code> but never returns <code>NULL</code> since it will abort
instead.  With the C++ operators it is slightly different because some versions
use exceptions to indicate failure, so you should always provide a handler to
deal with this eventuality.

<p>Never use <em>features</em><a rel=footnote href="#fn-35"><sup>35</sup></a> of
specific malloc libraries if you want your code to be portable.  Always follow
the ANSI C or C++ calling conventions and never make assumptions about the
function or operator you are about to call -- the standards committees went to
great lengths to explicitly specify its behaviour.  For example, don't assume
that the contents of a freed memory allocation will remain valid until the next
call to <code>malloc()</code>, and don't assume that the contents of a newly
allocated memory block will be zeroed unless you created it with
<code>calloc()</code>.

<p>Finally, try stress-testing your program in low memory conditions.  The mpatrol
library contains the <code>LIMIT</code> option which can place an upper bound on the
size of the heap, and also contains the <code>FAILFREQ</code> and <code>FAILSEED</code>
options which can cause random memory allocation failures.  Doing this will test
parts of your code that you would probably never expect to be called, but
perhaps they will one day!  Who would you rather have debugging your program --
yourself or the user?

<p><hr>
Node:<a name="How%20it%20works">How it works</a>,
Next:<a rel=next href="#Examples">Examples</a>,
Previous:<a rel=previous href="#Improving%20performance">Improving performance</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>10 How it works</h1>

<p>The mpatrol library was originally written with the intention of plugging it
into an existing compiler so that the compiler could plant calls to it in the
code it generated when a specific debugging option was used.  These extra calls
would obviously slow the code down, but along with the stack checking options
that would be provided, this would give the user an enhanced run-time debugging
environment.  Unfortunately, this integration never happened, but the way that
mpatrol works is still significantly different from other malloc tracing
libraries.

<p>In order to quickly determine exactly which memory allocation a heap address
belonged to it was necessary to be able to search the heap in an efficient
manner.  The traditional way of searching along a linked list was unfeasible,
so an implementation based on <em>red-black trees</em> was used, where every known
memory allocation in the heap was given an entry in the tree, with their start
addresses as the key.  Another major design decision was to also choose
red-black trees to implement the <em>best fit</em> allocation algorithm.  Although
<em>first fit</em> was considered, I decided that best fit would allow the library
to have more control over the heap, with every free memory block in the heap
given an entry in the free tree, with their sizes as the key.  There was a bit
of work involved in getting the splitting and merging of free blocks to work
efficiently, but it seems to work well now.

<p>My original implementation had all of the information about each memory block
stored just before the block itself.  I eventually dropped that behaviour in
favour of storing all of the library's internal information in a separate part
of the heap.  I did that for two reasons.  The first was because of the problems
that would occur due to memory allocations with different alignment
requirements.  The second reason was that the library's internal structures
could be write-protected on systems with virtual memory, to prevent user code
interfering with the operation of the library.

<p>Because the library attempts to record as much information as possible about
every memory allocation there will inevitably be a much larger memory
requirement when running a program linked with the library.  This will typically
be two or three times larger in magnitude, but will be affected by the number
of memory allocations made and also the number of symbols read.  The latter
will also affect how quickly the program starts since the first call to allocate
memory will result in the initialisation of the library and the loading of
symbols from the executable file and any shared libraries.

<p>Due to its design, it is also possible to allocate memory from the heap using
the mpatrol library functions whilst already within an mpatrol library function. 
This does not normally occur, but on some platforms calling <code>printf()</code>
from within the library may result in <code>printf()</code> calling <code>malloc()</code> to
allocate itself a buffer, which ends up as a recursive call.  Luckily, this is
dealt with by simply not displaying the allocation in the log file, but all
other details of the allocation are still recorded.  This can sometimes result
in <em>hidden</em> memory usage which occurs behind the scenes and alters the peak
memory usage in the summary.  This is particularly evident when the library uses
an object file access library to read program symbols at the time of library
initialisation.

<p>Memory allocation profiling support was added for mpatrol release 1.2.0.  Every
allocation and deallocation is recorded, with the call stack information being
used to differentiate all of the call sites within the program.  Unlike other
profilers that come with UNIX systems, even the symbolic information about the
program being run is written to the profiling output file, since it makes no
sense for <code>mprof</code> to re-read the symbol table from the executable file
when it has already been read and processed by the mpatrol library.  It also has
the added bonus of allowing the user to save profiling output files for later
use even when the executable files which produced them have changed or no longer
exist.

<p>Memory allocation tracing support was added for mpatrol release 1.3.2 and was
added to produce concise information for every memory allocation event.  This
information could also be produced in a verbose form in the log file, but to log
every memory allocation event in a large program would result in a massive log
file that would be hard to parse.  In order to keep the size of the tracing
output file down, almost all of the data in the file is encoded as LEB128
numbers.  The idea for this comes from the DWARF 2 debugging format.

<p>Support for the <code>alloca()</code> family of functions was added for mpatrol
release 1.3.0 and uses the heap instead of the stack in order to trace and debug
these functions.  If full call stack tracebacks are supported on a particular
system then mpatrol will compare the current call stack with the call stack of
the function that called <code>alloca()</code> in order to determine if a memory
allocation made by <code>alloca()</code> is out of scope.  This is generally a safe
way to determine when such allocations should be freed, but if full call stack
tracebacks are not supported then mpatrol will compare the addresses of specific
local variables in the call stack in order to determine if the allocation should
be freed.  This is an inferior method since it depends on the same function call
sequence being used each time an mpatrol function is called.  Therefore, a
safety boundary was added that will prevent mpatrol from freeing such
allocations unless they are a really clear-cut case (i.e. the stack frames
differ by a minimum number of bytes).  As a result, this second method will not
usually free such allocations until a much later point.

<p>The library is written in a modular fashion so as to make it easy to add new
functionality.  New modules have already been added, such as the <em>stack</em>,
<em>symbol</em>, <em>profile</em> and <em>trace</em> modules.  Extra information about
each memory allocation can be added to the <em>allocation information</em> module
in <code>src/info.h</code> and <code>src/info.c</code> without having to change much code in
any other files.

<p>Platform-dependent code has been isolated to specific modules, and feature
macros are entirely defined and controlled from <code>config.h</code> and
<code>target.h</code>.  The source code has been written so as to make it as easy as
possible to compile the library on new platforms at the first attempt, although
any additional features that the platform supports will then have to be
explicitly enabled in the code.

<p>Of the UNIX platforms that the mpatrol library runs on, Solaris and Linux
proved to be the easiest to port to, with well documented and easily accessible
programming interfaces to operating system features.  Unfortunately, the
non-UNIX ports proved a lot harder to write and do not contain as many of the
useful features that the UNIX ports have, although sometimes not because they
cannot ever support them, but because there would be a huge amount of work
involved.

<p><hr>
Node:<a name="Examples">Examples</a>,
Next:<a rel=next href="#Tutorial">Tutorial</a>,
Previous:<a rel=previous href="#How%20it%20works">How it works</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>11 Examples</h1>

<p>Following are a set of examples that are intended to illustrate what exactly is
possible with the mpatrol library and how to go about using it effectively.

<p>You should already have built and installed the library and should know how to
link programs with the library.  Unfortunately, it isn't possible to give
specific instructions on how to do this as it varies from system to system and
also depends on your preferred compiler and development tools.

<p>However, on a typical SVR4 UNIX system, with mpatrol installed in
<code>/usr/local</code>, the mpatrol library can usually be incorporated into a
program using the following commands:

<ul>
<li>If the mpatrol library was built with no support for any object file format or
was built with support for the COFF or XCOFF object file formats:

<pre>cc -I/usr/local/include &lt;file&gt; -L/usr/local/lib -lmpatrol
</pre>

<li>If the mpatrol library was built with support for the ELF32 or ELF64 object file
format access library:

<pre>cc -I/usr/local/include &lt;file&gt; -L/usr/local/lib -lmpatrol -lelf
</pre>

<li>If the mpatrol library was built with support for the GNU BFD object file format
access library:

<pre>cc -I/usr/local/include &lt;file&gt; -L/usr/local/lib -lmpatrol -lbfd
   -liberty
</pre>

<li>If the mpatrol library was built on HP/UX with support for the GNU BFD object
file format access library:

<pre>cc -I/usr/local/include &lt;file&gt; -L/usr/local/lib -lmpatrol -lbfd
   -liberty -lcl
</pre>
</ul>

<p>On Windows platforms, with mpatrol installed in <code>/mpatrol</code>, the mpatrol
library can usually be incorporated into a program using the following commands:

<ul>
<li>If the program is to be linked with the archive version of the mpatrol library:

<pre>cl -I/mpatrol/include -Zi &lt;file&gt; -link -libpath:/mpatrol/lib
   -defaultlib:libmpatrol -defaultlib:imagehlp -pdb:none
</pre>

<li>If the program is to be linked with the DLL version of the mpatrol library:

<pre>cl -I/mpatrol/include -MD -Zi &lt;file&gt; -link -libpath:/mpatrol/lib
   -defaultlib:mpatrol -pdb:none
</pre>
</ul>

<p>If you need to link with other libraries, make sure that they don't contain
definitions of <code>malloc()</code>, etc., or if they do then you must ensure that
the mpatrol library appears before them on the link line.  Note also that if the
mpatrol library was built on IRIX with the <code>MP_LIBRARYSTACK_SUPPORT</code>
preprocessor macro defined, then the <code>libexc</code> library must be linked in as
well.  You should also check the section on supported systems
(see <a href="#Supported%20systems">Supported systems</a>) to see if there are any other issues on the platform
that you are using.

<p>You should also know how to set an environment variable on your specific system. 
Again, this varies from system to system and also depends on the command line
interpreter or shell that you use.  The environment variable that the mpatrol
library uses is called <code>MPATROL_OPTIONS</code>.  You can see exactly what options
are available for this environment variable by setting it to <code>HELP</code> and
then running a program that has been linked with the library.

<ul>
<li><a href="#Example%201">Example 1</a>:                    Getting started. 
<li><a href="#Example%202">Example 2</a>:                    Detecting incorrect reuse of freed memory. 
<li><a href="#Example%203">Example 3</a>:                    Detecting use of free memory. 
<li><a href="#Example%204">Example 4</a>:                    Using overflow buffers. 
<li><a href="#Example%205">Example 5</a>:                    Bad memory operations. 
<li><a href="#Example%206">Example 6</a>:                    Incompatible function calls. 
<li><a href="#Example%207">Example 7</a>:                    The <code>alloca()</code> functions. 
<li><a href="#Example%208">Example 8</a>:                    Additional useful information. 
</ul>

<p><hr>
Node:<a name="Example%201">Example 1</a>,
Next:<a rel=next href="#Example%202">Example 2</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.1 Getting started</h2>

<p>The first example we'll look at is when the argument in a call to <code>free()</code>
doesn't match the return value from <code>malloc()</code>, even though the intention
is to free the memory that was allocated by <code>malloc()</code>.  This example is in
<code>tests/fail/test1.c</code> and causes many existing <code>malloc()</code>
implementations to crash.

<p>Along the way, I'll try to describe as many features of the mpatrol library as
possible, and illustrate them with examples.  Note that the output from your
version of the library is likely to vary slightly from that shown in the
examples, especially on non-UNIX systems.

<pre>23  /*
24   * Allocates a block of 16 bytes and then attempts to free the
25   * memory returned at an offset of 1 byte into the block.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      if (p = (char *) malloc(16))
37          free(p + 1);
38      return EXIT_SUCCESS;
39  }
</pre>

<p>Note that I've removed the copyright message from the start of the file and
added line numbers so that the tracing below makes more sense.

<p>After compiling and linking the above program with the mpatrol library, the
<code>MPATROL_OPTIONS</code> environment variable should be set to be <code>LOGALL</code>
and the program should be executed, generating the following output in
<code>mpatrol.log</code>.

<pre>@(#) mpatrol 1.3.2 (00/12/12)
Copyright (C) 1997-2000 Graeme S. Roy

This is free software, and you are welcome to redistribute it under
certain conditions; see the GNU Library General Public License for
details.

For the latest mpatrol release and documentation,
visit http://www.cbmamiga.demon.co.uk/mpatrol.

Log file generated on Wed Nov 22 22:26:31 2000

ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test1.c|36]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

returns 0x080620E8

FREE: free (0x080620E9) [main|test1.c|37]
        0x08049457 main+71
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

ERROR: [MISMAT]: free: 0x080620E9 does not match allocation of 0x080620E8
    0x080620E8 (16 bytes) {malloc:52:0} [main|test1.c|36]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

system page size:  4096 bytes
default alignment: 4 bytes
overflow size:     0 bytes
overflow byte:     0xAA
allocation byte:   0xFF
free byte:         0x55
allocation stop:   0
reallocation stop: 0
free stop:         0
unfreed abort:     0
small boundary:    32 bytes
medium boundary:   256 bytes
large boundary:    2048 bytes
lower check range: -
upper check range: -
failure frequency: 0
failure seed:      972951591
prologue function: &lt;unset&gt;
epilogue function: &lt;unset&gt;
handler function:  &lt;unset&gt;
log file:          mpatrol.log
profiling file:    mpatrol.out
tracing file:      mpatrol.trace
program filename:  ./test1
symbols read:      3711
autosave count:    0
freed queue size:  0
allocation count:  52
allocation peak:   32 (426176 bytes)
allocation limit:  0 bytes
allocated blocks:  7 (1528 bytes)
freed blocks:      0 (0 bytes)
free blocks:       8 (494088 bytes)
internal blocks:   46 (323584 bytes)
total heap usage:  819200 bytes
total compared:    0 bytes
total located:     2 bytes
total copied:      19450 bytes
total set:         374704 bytes
total warnings:    0
total errors:      1
</pre>

<p>Ignoring the copyright blurb at the top, let's first take a look at the initial
log message from the library.  I've annotated each of the items with a number
that corresponds to the descriptions below.

<pre> (1)    (2)   (3)    (4)       (5)     (6)    (7)  (8)
  |      |     |      |         |       |      |    |
  V      V     V      V         V       V      V    V
ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test1.c|36]
 (9) -&gt; 0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33 &lt;- (10)

returns 0x080620E8 &lt;- (11)
</pre>

<ol type=1 start=1>
</p><li>Allocation type.  This generalises the type of dynamic memory operation that is
being performed, and can be one of <code>ALLOC</code>, <code>REALLOC</code> or <code>FREE</code>. 
This should make looking for all allocations, reallocations or frees in the log
file a lot easier.  Alternatively, if a memory operation function was called
then this can also be one of <code>MEMSET</code>, <code>MEMCOPY</code>, <code>MEMFIND</code> or
<code>MEMCMP</code>.

<li>Allocation function.  This is the name of the function that has been called to
allocate the memory, in this case <code>malloc</code>.

<li>Allocation index.  This is incremented every time a new memory allocation is
requested, and persists even if the memory allocation is resized with
<code>realloc()</code>, <code>recalloc()</code> or <code>expand()</code>, so can be useful to keep
track of a memory allocation, even if its start address changes.  The mpatrol
library may use up the first few allocation indices when it gets initialised.

<li>Size of requested allocation.

<li>Alignment for requested allocation.  This is normally the default system
alignment for general-purpose memory allocations, but may be different depending
on the type of function that is used to allocate the memory.
</ol>

<p>The following information contains source file details of where the call to
<code>malloc()</code> came from, but is only available if the source file containing
the call to <code>malloc()</code> included <code>mpatrol.h</code>; otherwise the fields will
all be <code>-</code><a rel=footnote href="#fn-36"><sup>36</sup></a>. 
Because of the convoluted way this information is obtained for the C++
operators, you may encounter some problems in existing C++ programs when making
direct calls to <code>operator new</code> for example.  However, if you want to
disable the redefinition of the C++ operators in <code>mpatrol.h</code> you can define
the preprocessor macro <code>MP_NOCPLUSPLUS</code> before the inclusion of that file. 
Alternatively, you may wish to define the <code>MP_NONEWDELETE</code> preprocessor
macro in order to use <code>MP_NEW</code> and <code>MP_DELETE</code> instead of <code>new</code>
and <code>delete</code>.  That way you can combine calls to mpatrol's operators and
the standard operators.  Just make sure you don't mix them!

<p>If you are running on a system on which mpatrol supports full symbolic stack
tracebacks the following information may still be useful if the source files
were compiled with optimisation turned on.  This is because the calling function
may have been inlined, in which case you will only see the name of the function
into which the calling function was expanded in the stack traceback.

<ol type=1 start=6>
</p><li>Function where call to <code>malloc()</code> took place.  This information is only
available if the source file containing the call to <code>malloc()</code> was compiled
with <code>gcc</code> or <code>g++</code>.

<li>Filename in which call to <code>malloc()</code> took place.

<li>Line number at which call to <code>malloc()</code> took place.
</ol>

<p>The following information contains function call stack details of where the
call to <code>malloc()</code> came from, but is only available if the mpatrol library
has been built on a platform that supports this.  The top-most entry should be
the function which called <code>malloc()</code> and the bottom-most entry should be
the entry-point for the process.

<ol type=1 start=9>
</p><li>Address of function call.  This is normally the address of the machine
instruction immediately after the function call instruction, also known as the
return address.

<li>Function where call took place.  This information is only available if the
mpatrol library has been built on a platform that supports reading symbol table
information from executable files, and then only if there is an entry in the
symbol table corresponding to the return address.  C++ function names may still
be in their mangled form, but this can be easily rectified by processing the
log file with a C++ name demangler.  The number after the plus sign is the
offset in bytes from the beginning of the function.
</ol>

<p>The following information is only available when the allocation type is
<code>ALLOC</code> or <code>REALLOC</code> since it makes no sense when applied to
<code>FREE</code>.

<ol type=1 start=11>
</p><li>The address of the new memory block that has been allocated by <code>malloc()</code>.
</ol>

<p>As you can see, there is quite a lot of information that can be displayed from
a simple call to <code>malloc()</code>, and hopefully this information has been
presented in a clear and concise format in the log file.

<p>The next entries in the log file correspond to the call to <code>free()</code>, which
attempts to free the memory allocated by <code>malloc()</code>, but supplies the wrong
address.

<p>The first four lines should be self-explanatory as they are very similar to
those described above for <code>malloc()</code>.  However, the next lines signal that
a terminal error has occurred in the program, so I've annotated them as before.

<pre>FREE: free (0x080620E9) [main|test1.c|37]
        0x08049457 main+71
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

 (1)     (2)      (3)
  |       |        |
  V       V        V
ERROR: [MISMAT]: free: 0x080620E9 does not match allocation of 0x080620E8
       (4)        (5)       (6)  (7)(8)  (9)    (10) (11)
        |          |         |    |  |    |      |    |
        V          V         V    V  V    V      V    V
    0x080620E8 (16 bytes) {malloc:52:0} [main|test1.c|36]
(12) -&gt; 0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33
</pre>

<ol type=1 start=1>
</p><li>Error severity.  The mpatrol library has two different severities of error:
<code>WARNING</code> and <code>ERROR</code>.  The first is always recoverable, and serves
only to indicate that something is not quite right, and so may be useful in
determining where something started to go wrong.  The second may or may not be
recoverable, and the library terminates the program if it is fatal, displaying
any relevant information as it does this.

<li>Error abbreviation code.  This is a code that is different for each type of
error that is detected by the mpatrol library.  Some warnings and errors that
are not directly related to the program being run will not contain this field. 
See the appendix on diagnostic messages (see <a href="#Diagnostic%20messages">Diagnostic messages</a>) for a
complete list of all possible error abbreviation codes and their descriptions.

<li>Allocation function.  This is the name of the function used to allocate,
reallocate or free memory where the error was detected.  This may be omitted if
an error is detected elsewhere in the library.
</ol>

<p>The following information is related to the information that the library has
stored about the relevant memory allocation.  This information is always
displayed in this format when details of individual memory allocations are
required.  If any information is missing then it simply means that the library
was not able to determine it when the memory block was first allocated.

<ol type=1 start=4>
</p><li>Address of memory allocation.

<li>Size of memory allocation.

<li>Allocation function.  This is the name of the function that was called to
allocate the memory block, in this case <code>malloc</code>.  If the memory allocation
has been resized then this will be either <code>realloc</code>, <code>recalloc</code> or
<code>expand</code>.

<li>Allocation index.

<li>Reallocation index.  This is used to count the number of times a memory
allocation has been resized with <code>realloc()</code>, <code>recalloc()</code> or
<code>expand()</code>.

<li>Function where original call to <code>malloc()</code> took place.  If the memory
allocation has been resized then this will be the name of the function which
last called <code>realloc()</code>, <code>recalloc()</code> or <code>expand()</code>.

<li>Filename in which original call to <code>malloc()</code> took place.  If the memory
allocation has been resized then this will be the filename in which the last
call to <code>realloc()</code>, <code>recalloc()</code> or <code>expand()</code> took place.

<li>Line number at which original call to <code>malloc()</code> took place.  If the memory
allocation has been resized then this will be the line number at which the last
call to <code>realloc()</code>, <code>recalloc()</code> or <code>expand()</code> took place.

<li>Function call stack of original memory allocation.  If the memory allocation has
been resized then this will be the call stack of the last call to
<code>realloc()</code>, <code>recalloc()</code> or <code>expand()</code>.
</ol>

<p>So, the mpatrol library detected the error in the above program and terminated
it.  When the library terminates it always displays a summary of various memory
allocation statistics and settings that were used during the execution of the
program.

<p>The various settings and statistics displayed by the library for the above
example have been numbered and their descriptions appear below.

<pre> 1  system page size:  4096 bytes
 2  default alignment: 4 bytes
 3  overflow size:     0 bytes
 4  overflow byte:     0xAA
 5  allocation byte:   0xFF
 6  free byte:         0x55
 7  allocation stop:   0
 8  reallocation stop: 0
 9  free stop:         0
10  unfreed abort:     0
11  small boundary:    32 bytes
12  medium boundary:   256 bytes
13  large boundary:    2048 bytes
14  lower check range: -
15  upper check range: -
16  failure frequency: 0
17  failure seed:      972951591
18  prologue function: &lt;unset&gt;
19  epilogue function: &lt;unset&gt;
20  handler function:  &lt;unset&gt;
21  log file:          mpatrol.log
22  profiling file:    mpatrol.out
23  tracing file:      mpatrol.trace
24  program filename:  ./test1
25  symbols read:      3711
26  autosave count:    0
27  freed queue size:  0
28  allocation count:  52
29  allocation peak:   32 (426176 bytes)
30  allocation limit:  0 bytes
31  allocated blocks:  7 (1528 bytes)
32  freed blocks:      0 (0 bytes)
33  free blocks:       8 (494088 bytes)
34  internal blocks:   46 (323584 bytes)
35  total heap usage:  819200 bytes
36  total compared:    0 bytes
37  total located:     2 bytes
38  total copied:      19450 bytes
39  total set:         374704 bytes
40  total warnings:    0
41  total errors:      1
</pre>

<ol type=1 start=1>
</p><li>System page size.  This value is used on some platforms when allocating and
protecting system memory.

<li>Default alignment.  This value is the minimum alignment required for general
purpose memory allocations, and is usually the alignment required by the most
restrictive datatype on a given system.  It is used when allocating memory that
has no specified alignment.  It can be changed at run-time using the
<code>DEFALIGN</code> option, but setting this value too small may cause the program
to crash due to bus errors which are caused by reading from or writing to
misaligned data.

<li>Overflow size.  This value is the size used by one overflow buffer.  If this is
non-zero then every memory allocation will have two overflow buffers; one on
either side.  These buffers are used by the library to detect if the program
has written too many bytes to a memory allocation, thus overflowing into one of
the buffers, but these extra checks can slow down execution speed.  It can be
changed at run-time using the <code>OFLOWSIZE</code> option.

<li>Overflow byte. 
<li>Allocation byte. 
<li>Free byte.  These values are used by the library to pre-fill blocks of memory
for checking purposes.  The overflow byte is used to fill overflow buffers, the
allocation byte is used to fill newly-allocated memory (except from
<code>calloc()</code> or <code>recalloc()</code>), and the free byte is used to fill free
blocks or freed memory allocations.  These can be changed at run-time using the
<code>OFLOWBYTE</code>, <code>ALLOCBYTE</code> and <code>FREEBYTE</code> options.

<li>Allocation stop. 
<li>Reallocation stop. 
<li>Free stop.  These values are used by the library to halt the program when run
inside a debugger whenever a specified allocation index is allocated,
reallocated or freed.  These can be changed at run-time using the
<code>ALLOCSTOP</code>, <code>REALLOCSTOP</code> and <code>FREESTOP</code> options.

<li>Unfreed abort.  This value is used when the program terminates and is used by
the library to check if there are more than a given number of unfreed memory
allocations.  If there are then the library will cause the program to abort
with an error.  It can be changed at run-time using the <code>UNFREEDABORT</code>
option.

<li>Small boundary. 
<li>Medium boundary. 
<li>Large boundary.  These values are used in memory allocation profiling and
specify the boundaries in bytes between small, medium, large and extra large
allocations.  These can be changed at run-time using the <code>SMALLBOUND</code>,
<code>MEDIUMBOUND</code> and <code>LARGEBOUND</code> options.

<li>Lower check range. 
<li>Upper check range.  These values specify the range of allocation indices through
which the library will physically check every area of free memory and every
overflow buffer for errors.  A dash specifies that either the lower or upper
range is infinite, but if they are both zero then no such checking will ever be
performed, thus speeding up execution speed dramatically.  The library defaults
to performing checks for every allocation index.  These can be changed at
run-time using the <code>CHECK</code> option.

<li>Failure frequency. 
<li>Failure seed.  These values are used to specify if random memory allocation
failures should occur during program execution, for the purposes of stress
testing a program.  If the failure frequency is zero then no random failures
will occur, but if it is greater than zero then the higher the number, the less
frequent the failures.  The failure seed is used internally by the mpatrol
library when generating random numbers.  If it is zero then the seed will be set
randomly, but if it is greater than zero then it will be used to generate a
predictable sequence of random numbers; i.e. two runs of the same program with
the same failure frequencies and the same failure seeds will generate exactly
the same sequence of failures.

<li>Prologue function. 
<li>Epilogue function. 
<li>Handler function.  These values contain addresses or names of functions that
have been installed as callback functions for the library.  These functions, if
set, will be called from the library at appropriate times during program
execution in order to handle specific events.  These can be changed at
compile-time using the <code>__mp_prologue()</code>, <code>__mp_epilogue()</code> and
<code>__mp_nomemory()</code> functions.

<li>Log file.  Simply contains the name of the file where all mpatrol library
diagnostics go to.  It can be changed at run-time using the <code>LOGFILE</code>
option.

<li>Profiling file.  Contains the name of the file where all of the mpatrol
library memory allocation profiling information goes when the <code>PROF</code>
option is used.  It can be changed at run-time using the <code>PROFFILE</code>
option.

<li>Tracing file.  Contains the name of the file where all of the mpatrol library
memory allocation tracing information goes when the <code>TRACE</code> option is
used.  It can be changed at run-time using the <code>TRACEFILE</code> option.

<li>Program filename.  Contains the full pathname to the program's executable file. 
This is used by the mpatrol library to read the symbol table in order to
provide symbolic information in function call stacks.  It can be changed at
run-time using the <code>PROGFILE</code> option.

<li>Symbols read.  This value contains the total number of symbols read from a
program's executable file and/or the dynamic linker, if applicable.

<li>Autosave count.  This value contains the frequency at which the mpatrol library
should periodically write the profiling data to the profiling output file.  When
the total number of profiled memory allocations and deallocations is a multiple
of this number then the current profiling information will be written to the
profiling output file.  It can be changed at run-time using the
<code>AUTOSAVE</code> option.

<li>Freed queue size.  This value contains the maximum number of freed memory
allocations that will be stored in the freed queue if the <code>NOFREE</code> option
is used.  Once the freed queue becomes full then the oldest freed allocation in
the queue will be returned to the free memory pool for reuse every time an
existing memory allocation is freed.  If this value is zero then the freed queue
will never become full.  It can be changed at run-time using the <code>NOFREE</code>
option.

<li>Allocation count.  This value contains the total number of memory allocations
that were created by the mpatrol library.  This value may be more than expected
if the mpatrol library makes any memory allocations during initialisation.

<li>Allocation peak.  This value contains the peak memory usage set by the program
when running; the peak number of memory allocations, and also the peak number of
bytes allocated in parentheses (the two numbers may peak at different times
throughout the lifetime of the program).  This value may be more than expected
if the mpatrol library makes any memory allocations during initialisation.

<li>Allocation limit.  This value is used to limit the amount of memory that can be
allocated by a program, which can be useful for stress-testing in simulated low
memory conditions.  It can be changed at run-time using the <code>LIMIT</code>
option.

<li>Allocated blocks. 
<li>Freed blocks. 
<li>Free blocks.  These values contain the total number of allocated, freed and
free blocks at the time the summary was produced.  A freed block is an allocated
block that has been freed but has not been returned to the free memory list for
later allocation.  These values may be different from those expected if the
mpatrol library makes any memory allocations during initialisation.  In this
example a large amount of memory is used by the system object file access
library which is used for reading the symbols from the program's executable file
and any shared libraries that it requires.

<li>Internal blocks.  This value contains the total number of memory blocks (of
varying sizes) that have been allocated from the system for the mpatrol library
to use internally.  These memory blocks will be write-protected on systems that
support memory protection in order to prevent the program from corrupting the
library's data structures.  This can be overridden at run-time using the
<code>NOPROTECT</code> option in order to speed up program execution slightly.

<li>Total heap usage.  This value contains the total amount of system heap memory
that has been allocated by the mpatrol library.

<li>Total compared. 
<li>Total located. 
<li>Total copied. 
<li>Total set.  These values contain the total number of bytes that have been
tracked by the mpatrol library in byte comparison operations (such as
<code>memcmp()</code>), byte location operations (such as <code>memchr()</code>, byte copy
operations (such as <code>memcpy()</code>) and byte set operations (such as
<code>memset()</code>) respectively.  They do not take into account any other such
operations that occur outwith these functions, such as loading and storing from
machine instructions.

<li>Total warnings. 
<li>Total errors.  The library keeps a count of the total number of warnings and
errors it has displayed so that you can quickly work out this information at
program termination.
</ol>

<p><hr>
Node:<a name="Example%202">Example 2</a>,
Next:<a rel=next href="#Example%203">Example 3</a>,
Previous:<a rel=previous href="#Example%201">Example 1</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.2 Detecting incorrect reuse of freed memory</h2>

<p>The next example uses <code>tests/fail/test2.c</code> to illustrate how the mpatrol
library can detect whereabouts on the heap an address belongs.

<pre>23  /*
24   * Allocates a block of 16 bytes and then immediately frees it.  An
25   * attempt is then made to double the size of the original block.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      if (p = (char *) malloc(16))
37      {
38          free(p);
39          p = (char *) realloc(p, 32);
40      }
41      return EXIT_SUCCESS;
42  }
</pre>

<p>The relevant excerpts from <code>mpatrol.log</code> appear below.  The format of the
log messages should be familiar to you now.

<pre>ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test2.c|36]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

returns 0x080620E8

FREE: free (0x080620E8) [main|test2.c|38]
        0x08049456 main+70
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

    0x080620E8 (16 bytes) {malloc:52:0} [main|test2.c|36]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

REALLOC: realloc (0x080620E8, 32 bytes, 4 bytes) [main|test2.c|39]
        0x08049476 main+102
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

ERROR: [NOTALL]: realloc: 0x080620E8 has not been allocated

returns 0x00000000
</pre>

<p>The mpatrol library stores all of its information about allocated and free
memory in tree structures so that it can quickly determine if an address belongs
to allocated or free memory, or if it even exists in the heap that is managed by
mpatrol.  The above example should illustrate this since after the allocation
had been freed, the library recognised this and reported an error.  It was
possible for the program to continue execution even after that error since
mpatrol could recover from it and return <code>NULL</code>.

<p>It is possible for mpatrol to give even more useful diagnostics in the above
situation by using the <code>NOFREE</code> option.  This prevents the library from
returning any freed allocations to the free memory pool, by preserving any
information about them and marking them as freed.  If you add the
<code>NOFREE=0</code> option to the <code>MPATROL_OPTIONS</code> environment variable you
should see the following entries in <code>mpatrol.log</code> instead.

<pre>ALLOC: malloc (52, 16 bytes, 4 bytes) [main|test2.c|36]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

returns 0x08062F54

FREE: free (0x08062F54) [main|test2.c|38]
        0x08049456 main+70
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

    0x08062F54 (16 bytes) {malloc:52:0} [main|test2.c|36]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

REALLOC: realloc (0x08062F54, 32 bytes, 4 bytes) [main|test2.c|39]
        0x08049476 main+102
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

ERROR: [PRVFRD]: realloc: 0x08062F54 was freed with free
    0x08062F54 (16 bytes) {free:52:0} [main|test2.c|38]
        0x08049456 main+70
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

returns 0x00000000
</pre>

<p>Note the extra information reported by <code>realloc()</code> since the library knows
all of the details about the freed memory allocation and when it was freed.

<p>The <code>NOFREE=0</code> option tends to use up much more system memory than normal
since it effectively instructs the mpatrol library to allocate new memory for
every single memory allocation or reallocation.  It can also slow down program
execution when overflow buffers are used, since with each new memory allocation
the library needs to check more and more overflow buffers every time it is
called.  However, it can be quite useful for problems such as this one.  The
test in <code>tests/fail/test3.c</code> has a similar situation.

<p>The numerical argument specified with the <code>NOFREE</code> option indicates the
number of recently-freed memory allocations that are to be delayed from being
returned to the free memory pool, with a value of zero meaning that no freed
memory allocations will ever be reused.  Obviously, in an ideal world it would
be nice to be able to specify <code>NOFREE=0</code> all the time, but this will
gradually use up more and more memory since no system heap memory will ever be
reused.  Supplying a different number to the <code>NOFREE</code> option allows you
to make a compromise by storing the details of only the most recently-freed
memory allocations.  How many details you wish to store is up to you.

<p>Normally, the <code>NOFREE</code> option will cause the library to fill all freed
memory allocations with the free byte.  However, the original contents of such
allocations can be preserved with the <code>PRESERVE</code> option.  This could
help in situations when you need to determine exactly if a program is relying on
the contents of freed memory.

<p><hr>
Node:<a name="Example%203">Example 3</a>,
Next:<a rel=next href="#Example%204">Example 4</a>,
Previous:<a rel=previous href="#Example%202">Example 2</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.3 Detecting use of free memory</h2>

<p>This next example illustrates how the mpatrol library is able to check to see
if anything has been written into free memory.  The test is located in
<code>tests/fail/test4.c</code> and simply writes a single byte into free memory.

<pre>23  /*
24   * Allocates a block of 16 bytes and then immediately frees it.  A
25   * NULL character is written into the middle of the freed memory.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      if (p = (char *) malloc(16))
37      {
38          free(p);
39          p[8] = '\0';
40      }
41      return EXIT_SUCCESS;
42  }
</pre>

<p>The following output was produced as part of <code>mpatrol.log</code>.  Note that this
test was run using the same <code>MPATROL_OPTIONS</code> settings as the last example,
but make sure that <code>PRESERVE</code> is not set.

<pre>ERROR: [FRDCOR]: freed allocation 0x08062F54 has memory corruption at 0x08062F5C
        0x08062F5C  00555555 55555555                    .UUUUUUU

    0x08062F54 (16 bytes) {free:52:0} [main|test4.c|38]
        0x08049456 main+70
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33
</pre>

<p>The library was able to detect that something had been written into free memory
and could report on the memory allocation that was overwritten.  However, these
checks are only performed whenever a function in the mpatrol library is called. 
In the example above, the code which wrote into free memory could have been
miles away from where the library detected the error.

<p>On platforms that support memory protection, the library also supports the
<code>PAGEALLOC</code> option.  This option instructs the library to force every
single memory allocation to have a size which is a multiple of the system page
size.  Although the library still stores the original requested size, it
effectively means that no two memory allocations occupy the same page of memory. 
It can then use page protection (which only operates on pages of memory) to
protect all free memory from being read from or written to, and uses similar
features to install a page of overflow buffer on either side of the allocation.

<p>However, if the requested size for the memory allocation was not a multiple of
the page size this means that there will still be unused space left over in the
allocated pages.  This problem is solved by turning the unused space into
overflow buffers that will be checked in the normal way.  The positioning of the
allocation within its pages is also important.  If you want to check for illegal
reads from the borders of the memory allocation, unless it fits exactly into its
pages then there is a chance that a program could illegally read the right-most
overflow buffer if the allocation was left-aligned, or vice-versa.  Two settings
therefore exist for the <code>PAGEALLOC</code> option: <code>LOWER</code> and
<code>UPPER</code>.  They refer to the placement of every memory allocation within
its constituent pages.

<p>The following diagram illustrates the <code>PAGEALLOC</code> option.  In the
diagram, the system page size is assumed to be 16 bytes (very unlikely, but will
serve for this example) and each character represents 1 byte.

<pre>x = allocated memory
o = overflow buffer (filled with the overflow byte)
. = overflow buffer page (read and write protected)

PAGEALLOC=LOWER, allocation size is 16 bytes or
PAGEALLOC=UPPER, allocation size is 16 bytes:
    ................xxxxxxxxxxxxxxxx................

PAGEALLOC=LOWER, allocation size is 8 bytes:
    ................xxxxxxxxoooooooo................

PAGEALLOC=UPPER, allocation size is 8 bytes:
    ................ooooooooxxxxxxxx................
</pre>

<p>In our original example, if the <code>PAGEALLOC=LOWER</code> option is added to the
<code>MPATROL_OPTIONS</code> environment variable then the following error will be
produced instead of the original error.

<pre>ERROR: [ILLMEM]: illegal memory access at address 0x081C6008
    0x081C6000 (16 bytes) {free:52:0} [main|test4.c|38]
        0x08049456 main+70
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33

    call stack
        0x0804945F main+79
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33
</pre>

<p>On systems that support memory protection, the mpatrol library has a built-in
signal handler which catches illegal memory accesses and terminates the program. 
In the above case, the freed memory was made write-protected and so could not be
written to.  The underlying virtual memory system in the operating system
noticed this and signaled this to the library immediately after it happened.

<p>Along with the details of the freed memory allocation that was being written to,
the library also attempts to display the function call stack for the location in
the program that caused the illegal memory access, although this can be quite
unreliable.  A better solution would be to run the program in a debugger to
catch the illegal memory access.

<p>Note that the <code>PAGEALLOC</code> option also modifies the behaviour of the
<code>NOFREE</code> and <code>PRESERVE</code> options when used together.  The memory
allocation being freed will always be made write-protected when the
<code>PRESERVE</code> option is used, otherwise it will also be made read-protected
to prevent further accesses.

<p>Note also that the <code>PAGEALLOC=UPPER</code> option is potentially much less
efficient at catching illegal memory accesses than the <code>PAGEALLOC=LOWER</code>
option.  This is due to alignment requirements, since an allocation of 1 byte
requiring an alignment of 16 bytes cannot be placed at the very end of a page of
size 4096 bytes.  The following diagram illustrates this, using the same page
size as the last diagram.

<pre>x = allocated memory
o = overflow buffer (filled with the overflow byte)
. = overflow buffer page (read and write protected)

PAGEALLOC=UPPER, allocation size is 16 bytes, alignment is 8 bytes:
    ................xxxxxxxxxxxxxxxx................

PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 1 byte:
    ................oooooooooooooxxx................

PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 8 bytes:
    ................ooooooooxxxooooo................
</pre>

<p>Everything is OK until the last allocation, where the alignment requirement
means that there must be two overflow buffers.  This slows down program
execution since the library must check an additional overflow buffer, and also
means that the program would have to read six bytes beyond the end of the
allocation before the illegal memory access would be detected.

<p><hr>
Node:<a name="Example%204">Example 4</a>,
Next:<a rel=next href="#Example%205">Example 5</a>,
Previous:<a rel=previous href="#Example%203">Example 3</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.4 Using overflow buffers</h2>

<p>This example illustrates the use of overflow buffers and so the
<code>MPATROL_OPTIONS</code> environment variable should have <code>OFLOWSIZE=2</code>
added to it.  However, turn off any <code>PAGEALLOC</code> options for the purposes
of this example.  The test is located in <code>tests/fail/test5.c</code>, and
<code>tests/fail/test6.c</code> is very similar.

<pre>23  /*
24   * Allocates a block of 16 bytes and then copies a string of 16
25   * bytes into the block.  However, the string is copied to 1 byte
26   * before the allocated block which writes before the start of the
27   * block.  This test must be run with an OFLOWSIZE greater than 0.
28   */


31  #include "mpatrol.h"


34  int main(void)
35  {
36      char *p;

38      if (p = (char *) malloc(16))
39      {
40          strcpy(p - 1, "this test fails!");
41          free(p);
42      }
43      return EXIT_SUCCESS;
44  }
</pre>

<p>The following error should be produced in <code>mpatrol.log</code>.

<pre>ERROR: [ALLOVF]: allocation 0x08062FB8 has a corrupted overflow buffer at
                 0x08062FB7
        0x08062FB6  AA74                                 .t

    0x08062FB8 (16 bytes) {malloc:52:0} [main|test5.c|38]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33
</pre>

<p>Once again, the library attempts to show you as much detail as possible about
where the corruption occurred.  Along with showing you a memory dump of the
overflow buffer that was corrupted, it also shows you the allocation to which
the overflow buffer belongs.

<p>Using overflow buffers can reduce the speed of program execution since the
library has to check every buffer whenever it is called, and if the buffers are
larger then they'll take longer to check and will use up more memory.  However,
larger buffers mean that there is less chance of the program writing past one
memory allocation into another.

<p>Alternatively, the <code>CHECK</code> option can be used to limit the number of
checks that the library has to perform, thus speeding up program execution. 
This option specifies a range of allocation indices through which the library
will check overflow buffers and free memory for corruption.  Such checks occur
when they normally would, but only if the current allocation index falls within
the specified range.  This feature can be used when there is a suspicion that
free memory corruption or overflow buffer corruption occurs at a certain point
during program execution, but checking them at every library call would take too
long.

<p>On systems which support software watch points, there is an extra option called
<code>OFLOWWATCH</code> which allows additional memory protection.  Watch points
allow individual bytes to be read and/or write protected as opposed to just
pages.  The <code>OFLOWWATCH</code> option installs software watch points at every
overflow buffer instead of requiring the library to check the integrity of the
overflow buffers, and can be used in combination with <code>PAGEALLOC</code>. 
However, software watch points slow down program execution to a crawl since
every machine instruction must be checked individually by the system to see if
it accesses a watch point area.  Slowing the program down by a factor of 10,000
is not uncommon on some systems when the <code>OFLOWWATCH</code> option is used.

<p><hr>
Node:<a name="Example%205">Example 5</a>,
Next:<a rel=next href="#Example%206">Example 6</a>,
Previous:<a rel=previous href="#Example%204">Example 4</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.5 Bad memory operations</h2>

<p>In C there are several basic memory operation functions that are often called
to perform tasks such as clearing memory, copying memory, etc.  The mpatrol
library contains replacements for these which allow for better checking of their
arguments to prevent reading and writing past the boundaries of existing memory
allocations.  The following source can be found in <code>tests/fail/test9.c</code>.

<pre>23  /*
24   * Allocates a block of 16 bytes and then attempts to zero the contents of
25   * the block.  However, a zero byte is also written 1 byte before and 1
26   * byte after the allocated block, resulting in an error in the log file.
27   */


30  #include "mpatrol.h"


33  int main(void)
34  {
35      char *p;

37      if (p = (char *) malloc(16))
38      {
39          memset(p - 1, 0, 18);
40          free(p);
41      }
42      return EXIT_SUCCESS;
43  }
</pre>

<p>When this is compiled and run, the following should appear in the log file.

<pre>ERROR: [RNGOVF]: memset: range [0x08062FB7,0x08062FC8] overflows
                 [0x08062FB8,0x08062FC7]
    0x08062FB8 (16 bytes) {malloc:52:0} [main|test9.c|37]
        0x0804942F main+31
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33
</pre>

<p>As you can see, the library detected that the <code>memset()</code> function would
have written past the boundaries of the memory allocation and reported this to
you.  It then proceeded to ignore the request to copy the memory and continued
with the execution of the program<a rel=footnote href="#fn-37"><sup>37</sup></a>.  Note that this will only be done for known memory
allocations.  Reading and writing past the boundaries of static and stack memory
allocations cannot be detected in this way.

<p>If the <code>LOGMEMORY</code> option is added to the <code>MPATROL_OPTIONS</code>
environment variable then it is possible to see a log of all the mpatrol library
memory operation functions that were called during program execution.  For
example, adding this option and running the above program again will produce
something similar to the following.

<pre>MEMSET: memset (0x08062FB7, 18 bytes, 0x00) [main|test9.c|39]
        0x0804945B main+75
        0x4007C9CB __libc_start_main+255
        0x08049381 _start+33
</pre>

<p>This is similar to the tracing produced for memory allocation functions, except
that the arguments in parentheses mean different things.  For <code>MEMSET</code>,
the first argument represents the start of the memory block to set, the second
argument represents the number of bytes to set and the third argument represents
the actual byte to set.

<p>For <code>MEMCOPY</code>, the first argument represents the source memory block, the
second argument represents the destination memory block, the third argument
represents the number of bytes to copy and the fourth argument represents a byte
to copy up to if <code>memccpy()</code> is being called.  This is similar for
<code>MEMCMP</code>.

<p>For <code>MEMFIND</code>, the first and second arguments represent the source memory
block and its length, while the third and fourth arguments represent the memory
block to search for and its length.  In the implementation for <code>memchr()</code>,
the byte to search for is copied to a one byte buffer and the address of that
buffer is used as the memory block to search for.

<p>Note that as with the memory allocation functions, <code>MEMCMP</code>,
<code>MEMFIND</code>, <code>MEMCOPY</code> and <code>MEMSET</code> are used to generalise the
types of operations being performed and are followed by the names of the actual
functions being used.  In some cases the functions may use a different ordering
of parameters than that shown.

<p><hr>
Node:<a name="Example%206">Example 6</a>,
Next:<a rel=next href="#Example%207">Example 7</a>,
Previous:<a rel=previous href="#Example%205">Example 5</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.6 Incompatible function calls</h2>

<p>This example illustrates how the mpatrol library checks for calls to
incompatible pairs of memory allocation functions.  It requires the use of
C++, although does not use any C++ features except for overloaded operators. 
The source is in <code>tests/fail/test7.c</code>, and <code>tests/fail/test8.c</code> is
similar.

<pre>23  /*
24   * Allocates a block of 16 bytes using C++ operator new[] and then
25   * attempts to free it using C++ operator delete.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      p = new char[16];
37      delete p;
38      return EXIT_SUCCESS;
39  }
</pre>

<p>The relevant parts of <code>mpatrol.log</code> are shown below.

<pre>ALLOC: operator new[] (74, 16 bytes, 4 bytes) [int main()|test7.c|36]
        0x0804955D main+13
        0x400DB9CB __libc_start_main+255
        0x080494C1 _start+33

returns 0x08062FC0

FREE: operator delete (0x08062FC0) [int main()|test7.c|37]
        0x0804956E main+30
        0x400DB9CB __libc_start_main+255
        0x080494C1 _start+33

ERROR: [INCOMP]: operator delete: 0x08062FC0 was allocated with operator new[]
    0x08062FC0 (16 bytes) {operator new[]:74:0} [int main()|test7.c|36]
        0x0804955D main+13
        0x400DB9CB __libc_start_main+255
        0x080494C1 _start+33
</pre>

<p>This shows a call to <code>operator new[]</code>, closely followed by a call to
<code>operator delete</code>.  However, in C++ calls to <code>operator new[]</code> must be
matched by calls to <code>operator delete[]</code> and not <code>operator delete</code>. 
Hence, the library reports this as an error and does not free the memory
allocation.

<p><hr>
Node:<a name="Example%207">Example 7</a>,
Next:<a rel=next href="#Example%208">Example 8</a>,
Previous:<a rel=previous href="#Example%206">Example 6</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.7 The <code>alloca()</code> functions</h2>

<p>There are two examples of using <code>alloca()</code> and its related functions in
<code>tests/pass/test8.c</code> and <code>tests/fail/test16.c</code>.  Both rely on mpatrol
having full call stack traceback support, although they will work (albeit with
slightly different results) on systems that do not.

<p>The first test simply illustrates the use of <code>alloca()</code> and how its memory
allocations are freed when they are no longer in use.

<pre>  23  /*
  24   * Tests alloca() and related functions via nested function calls.
  25   * The final output should be a horizontal pyramid of plus signs
  26   * followed by a horizontal pyramid of minus signs.
  27   */


  30  #include "mpatrol.h"
  31  #include &lt;stdio.h&gt;


  34  char *f1(char *s)
  35  {
  36      char *t;
  37      size_t l;

  39      l = strlen(s) + 1;
  40      if ((t = (char *) alloca(l + 1)) == NULL)
  41          return NULL;
  42      memcpy(t, s, l);
  43      t[l - 1] = t[l - 2];
  44      t[l] = '\0';
  45      return strdup(t);
  46  }


  49  char *f2(char *s)
  50  {
  51      char *t;
  52      size_t l;

  54      l = strlen(s) - 1;
  55      if ((t = (char *) alloca(l + 1)) == NULL)
  56          return NULL;
  57      memcpy(t, s, l + 1);
  58      t[l] = '\0';
  59      return strdup(t);
  60  }


  63  int f(char *s, size_t l)
  64  {
  65      char *t;
  66      size_t i;

  68      puts(s);
  69      for (i = 0; i &lt; l; i++)
  70      {
  71          if (((t = f1(s)) == NULL) ||
  72              ((s = (char *) alloca(strlen(t) + 1)) == NULL))
  73              return 0;
  74          strcpy(s, t);
  75          free(t);
  76          puts(s);
  77      }
  78      for (i = 0; i &lt; l; i++)
  79      {
  80          if (((t = f2(s)) == NULL) ||
  81              ((s = (char *) alloca(strlen(t) + 1)) == NULL))
  82              return 0;
  83          strcpy(s, t);
  84          free(t);
  85          puts(s);
  86      }
  87      return 1;
  88  }


  91  int main(void)
  92  {
  93      char *s;

  95      s = strdupa("+");
  96      if (!f(s, 4))
  97          exit(EXIT_FAILURE);
  98      dealloca(s);
  99      s = strdupa("-");
 100      if (!f(s, 4))
 101          exit(EXIT_FAILURE);
 102      dealloca(s);
 103      return EXIT_SUCCESS;
 104  }
</pre>

<p>When compiled and run, you should get the following output.

<pre>+
++
+++
++++
+++++
++++
+++
++
+
-
--
---
----
-----
----
---
--
-
</pre>

<p>If you run it again, this time with the <code>MPATROL_OPTIONS</code> environment
variable set to <code>LOGALLOCS</code> and <code>LOGFREES</code>, you should see the
following in the newly-generated <code>mpatrol.log</code> file.  Note that the
<code><small>...</small></code> marks text that has been removed.

<pre>ALLOC: strdupa (1, 2 bytes, 1 byte) [main|test8.c|95]
        0x000138F0 main+52
        0x00013350 _start+100

returns 0x0008C000

ALLOC: alloca (2, 3 bytes, 8 bytes) [f1|test8.c|40]
        0x000134CC f1+76
        0x000136D8 f+68
        0x00013904 main+72
        0x00013350 _start+100

returns 0x0008C008

ALLOC: strdup (3, 3 bytes, 1 byte) [f1|test8.c|45]
        0x00013584 f1+260
        0x000136D8 f+68
        0x00013904 main+72
        0x00013350 _start+100

returns 0x0008C002

FREE: alloca (0x0008C008) [f|test8.c|72]
        0x00013728 f+148
        0x00013904 main+72
        0x00013350 _start+100

    0x0008C008 (3 bytes) {alloca:2:0} [f1|test8.c|40]
        0x000134CC f1+76
        0x000136D8 f+68
        0x00013904 main+72
        0x00013350 _start+100

ALLOC: alloca (4, 3 bytes, 8 bytes) [f|test8.c|72]
        0x00013728 f+148
        0x00013904 main+72
        0x00013350 _start+100

returns 0x0008C008

<small>...</small>

FREE: alloca (0x0008C040) [main|test8.c|102]
        0x000139C8 main+268
        0x00013350 _start+100

    0x0008C040 (2 bytes) {alloca:50:0} [f|test8.c|81]
        0x00013828 f+404
        0x00013988 main+204
        0x00013350 _start+100

FREE: alloca (0x0008C038) [main|test8.c|102]
        0x000139C8 main+268
        0x00013350 _start+100

    0x0008C038 (3 bytes) {alloca:47:0} [f|test8.c|81]
        0x00013828 f+404
        0x00013988 main+204
        0x00013350 _start+100

<small>...</small>

FREE: alloca (0x0008C010) [main|test8.c|102]
        0x000139C8 main+268
        0x00013350 _start+100

    0x0008C010 (4 bytes) {alloca:32:0} [f|test8.c|72]
        0x00013728 f+148
        0x00013988 main+204
        0x00013350 _start+100

FREE: alloca (0x0008C008) [main|test8.c|102]
        0x000139C8 main+268
        0x00013350 _start+100

    0x0008C008 (3 bytes) {alloca:29:0} [f|test8.c|72]
        0x00013728 f+148
        0x00013988 main+204
        0x00013350 _start+100

FREE: dealloca (0x0008C000) [main|test8.c|102]
        0x000139C8 main+268
        0x00013350 _start+100

    0x0008C000 (2 bytes) {strdupa:26:0} [main|test8.c|99]
        0x00013974 main+184
        0x00013350 _start+100
</pre>

<p>After the first call to <code>strdupa()</code>, there is a call to <code>alloca()</code>
followed by a call to <code>strdup()</code>.  Because the memory allocation made by
<code>strdupa()</code> is at the top level of the program it cannot automatically be
freed until <code>main()</code> returns.  However, at the next call to <code>alloca()</code>
in <code>f()</code>, the mpatrol library notices that the memory allocation that was
made by <code>alloca()</code> in <code>f1()</code> can be freed since <code>f1()</code> has
returned.  The relevant allocation is then freed before making the next memory
allocation.  You can see how it makes its decision by examining the call stack
at the point of deallocation.

<p>However, all of the memory allocations made by <code>alloca()</code> in <code>f()</code>
cannot be freed until <code>f()</code> returns.  This can be seen in the two sets of
eight consecutive deallocations in the log file, each set followed by a call to
<code>dealloca()</code>.  The <code>dealloca()</code> function explicitly frees a memory
allocation that was made by the <code>alloca()</code> family of functions, but these
calls are not really necessary as all of these memory allocations would be freed
anyway when <code>main()</code> returns.  The call to <code>dealloca()</code> is really only
necessary to force a deallocation for a specific purpose at a certain point in
the program.  Note that implicit deallocations are marked as being done by
<code>alloca()</code> while explicit deallocations are marked as being done by
<code>dealloca()</code>.

<p>The second test illustrates how the mpatrol library can help debug
<code>alloca()</code>-related problems by treating such memory allocations as normal
heap allocations.

<pre>23  /*
24   * Duplicates a string using alloca() and then returns the address
25   * of the allocation.  This is illegal since the memory allocated
26   * by alloca() will be freed when the function returns.  The call
27   * to memcpy() will then corrupt free memory and the call to free()
28   * will attempt to free an invalid pointer.
29   */


32  #include "mpatrol.h"
33  #include &lt;stdio.h&gt;


36  char *f(size_t l)
37  {
38      return (char *) alloca(l);
39  }


42  char *g(char *s)
43  {
44      char *t;
45      size_t l;

47      l = strlen(s) + 1;
48      if (t = f(l))
49          memcpy(t, s, l);
50      return t;
51  }


54  int main(void)
55  {
56      char *s;

58      s = g("test");
59      free(s);
60      return EXIT_SUCCESS;
61  }
</pre>

<p>If you compile and run this example with the <code>MPATROL_OPTIONS</code> environment
variable containing the options <code>LOGALL</code> and <code>NOFREE=0</code> you should
see the following in <code>mpatrol.log</code>.

<pre>ALLOC: alloca (1, 5 bytes, 8 bytes) [f|test16.c|38]
        0x0001346C f+52
        0x000134A8 g+40
        0x00013524 main+20
        0x00013308 _start+100

returns 0x0008C000

FREE: alloca (0x0008C000) [g|test16.c|49]
        0x000134F8 g+120
        0x00013524 main+20
        0x00013308 _start+100

    0x0008C000 (5 bytes) {alloca:1:0} [f|test16.c|38]
        0x0001346C f+52
        0x000134A8 g+40
        0x00013524 main+20
        0x00013308 _start+100

MEMCOPY: memcpy (0x0001F760, 0x0008C000, 5 bytes, 0x00) [g|test16.c|49]
        0x000134F8 g+120
        0x00013524 main+20
        0x00013308 _start+100

ERROR: [FRDOPN]: memcpy: attempt to perform operation on freed memory
    0x0008C000 (5 bytes) {alloca:1:0} [g|test16.c|49]
        0x000134F8 g+120
        0x00013524 main+20
        0x00013308 _start+100

returns 0x0008C000

FREE: free (0x0008C000) [main|test16.c|59]
        0x00013550 main+64
        0x00013308 _start+100

ERROR: [PRVFRD]: free: 0x0008C000 was freed with alloca
    0x0008C000 (5 bytes) {alloca:1:0} [g|test16.c|49]
        0x000134F8 g+120
        0x00013524 main+20
        0x00013308 _start+100
</pre>

<p>As you can see, memory allocations made by <code>alloca()</code> are treated in
almost exactly the same way as normal memory allocations, with the result that
errors similar to those above can be detected by the mpatrol library.  The only
real difference between the two types of memory allocations is that allocations
made by the <code>alloca()</code> family of functions will never show up in the list
of unfreed memory allocations.

<p><hr>
Node:<a name="Example%208">Example 8</a>,
Previous:<a rel=previous href="#Example%207">Example 7</a>,
Up:<a rel=up href="#Examples">Examples</a>
<br>

<h2>11.8 Additional useful information</h2>

<p>This last example illustrates the various <code>SHOW</code> options that are
available for displaying additional information from the mpatrol library at
program termination.  It also shows how to easily detect memory leaks.  Use the
<code>OFLOWSIZE=16</code>, <code>NOFREE=0</code> and <code>SHOWALL</code> options in
<code>MPATROL_OPTIONS</code> before running.

<pre> 1  /*
 2   * Introduces a memory leak by clobbering a pointer with a new
 3   * memory allocation.  Use with SHOWUNFREED to display it.
 4   */


 7  #include "mpatrol.h"


10  int main(void)
11  {
12      void *p;

14      p = malloc(4);
15      p = malloc(4);
16      if (p != NULL)
17          free(p);
18      return EXIT_SUCCESS;
19  }
</pre>

<p>The information that we are interested in comes after the summary of library
statistics generated in the log file.  The first block of data shows a memory
map of the heap that is being handled by mpatrol.  This can be used to see
graphically where a particular allocation is located, or to look for memory
fragmentation.  The <code>SHOWMAP</code> option also displays this information.

<p>Note that gaps in the memory map can either be due to space used by internal
memory blocks or to some other memory allocation library using up space.  On
some systems that don't have virtual memory, gaps are likely to be owned by
other processes or belong to the system free memory list.  The <code><small>...</small></code>
marks text that has been removed.

<pre>memory map:
    <small>...</small>
  / 0x0002FDD0-0x0002FDDF overflow (16 bytes)
 |+ 0x0002FDE0-0x0002FE03 allocated (36 bytes) {calloc:13:0} [-|-|-]
  \ 0x0002FE04-0x0002FE13 overflow (16 bytes)
--- 0x0002FE14-0x0002FE17 free (4 bytes)
  / 0x0002FE18-0x0002FE27 overflow (16 bytes)
 |+ 0x0002FE28-0x0002FF18 allocated (241 bytes) {calloc:15:0} [-|-|-]
  \ 0x0002FF19-0x0002FF28 overflow (16 bytes)
--- 0x0002FF29-0x0002FF2F free (7 bytes)
  / 0x0002FF30-0x0002FF3F overflow (16 bytes)
 |+ 0x0002FF40-0x0002FF93 allocated (84 bytes) {calloc:16:0} [-|-|-]
  \ 0x0002FF94-0x0002FFA3 overflow (16 bytes)
--- 0x0002FFA4-0x0002FFA7 free (4 bytes)
  / 0x0002FFA8-0x0002FFB7 overflow (16 bytes)
 |+ 0x0002FFB8-0x0002FFC4 allocated (13 bytes) {calloc:17:0} [-|-|-]
  \ 0x0002FFC5-0x0002FFD4 overflow (16 bytes)
--- 0x0002FFD5-0x0002FFD7 free (3 bytes)
  / 0x0002FFD8-0x0002FFE7 overflow (16 bytes)
 |+ 0x0002FFE8-0x0002FFEB allocated (4 bytes) {malloc:19:0} [main|test.c|14]
  \ 0x0002FFEC-0x0002FFFB overflow (16 bytes)
--- 0x0002FFFC-0x0002FFFF free (4 bytes)
    --------------------- gap (57344 bytes)
  / 0x0003E000-0x0003E00F overflow (16 bytes)
 |+ 0x0003E010-0x0003EFFF freed (4080 bytes) {free:6:0} [-|-|-]
  \ 0x0003F000-0x0003F00F overflow (16 bytes)
  / 0x0003F010-0x0003F01F overflow (16 bytes)
 |+ 0x0003F020-0x0003F707 freed (1768 bytes) {free:12:0} [-|-|-]
  \ 0x0003F708-0x0003F717 overflow (16 bytes)
--- 0x0003F718-0x0003FFFF free (2280 bytes)
    --------------------- gap (16384 bytes)
  / 0x00044000-0x0004400F overflow (16 bytes)
 |+ 0x00044010-0x00045197 freed (4488 bytes) {free:8:0} [-|-|-]
  \ 0x00045198-0x000451A7 overflow (16 bytes)
  / 0x000451A8-0x000451B7 overflow (16 bytes)
 |+ 0x000451B8-0x000459AF freed (2040 bytes) {free:10:0} [-|-|-]
  \ 0x000459B0-0x000459BF overflow (16 bytes)
  / 0x000459C0-0x000459CF overflow (16 bytes)
 |+ 0x000459D0-0x00045D93 allocated (964 bytes) {calloc:14:0} [-|-|-]
  \ 0x00045D94-0x00045DA3 overflow (16 bytes)
  / 0x00045DA4-0x00045DB3 overflow (16 bytes)
 |+ 0x00045DB4-0x00045DCE allocated (27 bytes) {strdup:18:0} [-|-|-]
  \ 0x00045DCF-0x00045DDE overflow (16 bytes)
--- 0x00045DDF-0x00045DDF free (1 byte)
  / 0x00045DE0-0x00045DEF overflow (16 bytes)
 |+ 0x00045DF0-0x00045DF3 freed (4 bytes) {free:20:0} [main|test.c|17]
  \ 0x00045DF4-0x00045E03 overflow (16 bytes)
--- 0x00045E04-0x00045FFF free (508 bytes)
</pre>

<p>The next block of data shows a summary of all the symbols that could be read
from the program's executable file and/or any shared libraries that the program
requires.  This can be useful to see which symbols have actually been read by
the mpatrol library.  The <code>SHOWSYMBOLS</code> option also displays this
information.

<p>Note that the following data has been dramatically cut down in size for the
purposes of this example.  The <code><small>...</small></code> marks text that has been removed.

<pre>symbols read: 3300
               0x000108B0 _ex_text0 [a.out] (0 bytes)
    0x000108B0-0x0001097F _start [a.out] (208 bytes)
    0x00010990-0x00010A27 main [a.out] (152 bytes)
               0x00010A28 _ex_text1 [a.out] (0 bytes)
    0x00010A28-0x00010A77 _init [a.out] (80 bytes)
    0x00010A78-0x00010AC7 _fini [a.out] (80 bytes)
               0x7FA1FFF8 _ex_text0 [/usr/lib/libc.so.1] (0 bytes)
    0x7FA1FFF8-0x7FA2005F atexit [/usr/lib/libc.so.1] (104 bytes)
    0x7FA20060-0x7FA200EF _exithandle [/usr/lib/libc.so.1] (144 bytes)
    0x7FA20470-0x7FA204EB __dtou [/usr/lib/libc.so.1] (124 bytes)
    0x7FA20500-0x7FA20577 __ftou [/usr/lib/libc.so.1] (120 bytes)
    0x7FA2083C-0x7FA20B2F __div64 [/usr/lib/libc.so.1] (756 bytes)
    0x7FA20B30-0x7FA20DEB __rem64 [/usr/lib/libc.so.1] (700 bytes)
    <small>...</small>
    0x7FA96858-0x7FA96867 getpid [/usr/lib/libc.so.1] (16 bytes)
    0x7FA96858-0x7FA96867 _getpid [/usr/lib/libc.so.1] (16 bytes)
    0x7FA96868-0x7FA9689F _kill [/usr/lib/libc.so.1] (56 bytes)
    0x7FA96868-0x7FA9689F _libc_kill [/usr/lib/libc.so.1] (56 bytes)
               0x7FA968A0 _ex_text1 [/usr/lib/libc.so.1] (0 bytes)
    0x7FA968A0-0x7FA968DF _init [/usr/lib/libc.so.1] (64 bytes)
    0x7FA968E0-0x7FA9691F _fini [/usr/lib/libc.so.1] (64 bytes)
    0x7FB105E4-0x7FB1069F memmove [/usr/lib/libc_psr.so.1] (188 bytes)
    0x7FB105E4-0x7FB1069F _memmove [/usr/lib/libc_psr.so.1] (188 bytes)
               0x7FB106A0 forcpy [/usr/lib/libc_psr.so.1] (0 bytes)
    0x7FB106A0-0x7FB1190B memcpy [/usr/lib/libc_psr.so.1] (4716 bytes)
    0x7FB106A0-0x7FB1190B _memcpy [/usr/lib/libc_psr.so.1] (4716 bytes)
    0x7FB106A0-0x7FB1190B __align_cpy_1 [/usr/lib/libc_psr.so.1] (4716 bytes)
    <small>...</small>
    0x7FB135B0-0x7FB135D3 __div64 [/usr/lib/libc_psr.so.1] (36 bytes)
    0x7FB135D4-0x7FB135F7 __udiv64 [/usr/lib/libc_psr.so.1] (36 bytes)
    0x7FB135F8-0x7FB1362B __umul64 [/usr/lib/libc_psr.so.1] (52 bytes)
    0x7FB135F8-0x7FB1362B __mul64 [/usr/lib/libc_psr.so.1] (52 bytes)
    0x7FB1362C-0x7FB13657 __urem64 [/usr/lib/libc_psr.so.1] (44 bytes)
    0x7FB13658-0x7FB13683 __rem64 [/usr/lib/libc_psr.so.1] (44 bytes)
               0x7FB333F8 _ex_text0 [/usr/lib/libelf.so.1] (0 bytes)
    0x7FB333F8-0x7FB3346F _elf32_entsz [/usr/lib/libelf.so.1] (120 bytes)
    0x7FB33470-0x7FB334EB elf32_fsize [/usr/lib/libelf.so.1] (124 bytes)
    0x7FB33470-0x7FB334EB _elf32_fsize [/usr/lib/libelf.so.1] (124 bytes)
    0x7FB334EC-0x7FB3352F _elf32_msize [/usr/lib/libelf.so.1] (68 bytes)
    0x7FB33530-0x7FB335D3 _elf32_mtype [/usr/lib/libelf.so.1] (164 bytes)
    <small>...</small>
    0x7FB49054-0x7FB4921F _elf_nlist [/usr/lib/libelf.so.1] (460 bytes)
    0x7FB49220-0x7FB4932F nlist [/usr/lib/libelf.so.1] (272 bytes)
    0x7FB49330-0x7FB493E3 _elf_findop [/usr/lib/libelf.so.1] (180 bytes)
               0x7FB493E4 _ex_text1 [/usr/lib/libelf.so.1] (0 bytes)
    0x7FB493E4-0x7FB4941B _init [/usr/lib/libelf.so.1] (56 bytes)
    0x7FB4941C-0x7FB49453 _fini [/usr/lib/libelf.so.1] (56 bytes)
    0x7FB65818-0x7FB6582F __mp_newlist [/usr/lib/libmpatrol.so.1.3] (24 bytes)
    0x7FB65830-0x7FB65853 __mp_addhead [/usr/lib/libmpatrol.so.1.3] (36 bytes)
    0x7FB65854-0x7FB6587B __mp_addtail [/usr/lib/libmpatrol.so.1.3] (40 bytes)
    0x7FB6587C-0x7FB6589F __mp_prepend [/usr/lib/libmpatrol.so.1.3] (36 bytes)
    0x7FB658A0-0x7FB658C3 __mp_insert [/usr/lib/libmpatrol.so.1.3] (36 bytes)
    0x7FB658C4-0x7FB658EB __mp_remove [/usr/lib/libmpatrol.so.1.3] (40 bytes)
    <small>...</small>
    0x7FB725F4-0x7FB7262B memmem [/usr/lib/libmpatrol.so.1.3] (56 bytes)
    0x7FB7262C-0x7FB72663 _memmem [/usr/lib/libmpatrol.so.1.3] (56 bytes)
    0x7FB72664-0x7FB72697 memcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
    0x7FB72698-0x7FB726CB _memcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
    0x7FB726CC-0x7FB726FF bcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
    0x7FB72700-0x7FB72733 _bcmp [/usr/lib/libmpatrol.so.1.3] (52 bytes)
    0x7FB9085C-0x7FB90863 dlinfo [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB9085C-0x7FB90863 _dlinfo [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB90864-0x7FB9086B dlmap [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB90864-0x7FB9086B _dlmap [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB9086C-0x7FB90873 dlmopen [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB9086C-0x7FB90873 _dlmopen [/usr/lib/libdl.so.1] (8 bytes)
    <small>...</small>
    0x7FB90894-0x7FB9089B dladdr [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB90894-0x7FB9089B _dladdr [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB9089C-0x7FB908A3 dldump [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB9089C-0x7FB908A3 _dldump [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB908A4-0x7FB908AB _ld_concurrency [/usr/lib/libdl.so.1] (8 bytes)
    0x7FB908AC-0x7FB908B3 bind_guard [/usr/lib/libdl.so.1] (8 bytes)
</pre>

<p>The next table is really only useful for seeing how much memory fragmentation
has occurred in the memory map.  It shows a breakdown of the free memory blocks
that have either resulted from the mpatrol library allocating uninitialised
memory from the system heap or from freeing existing memory allocations.  The
column on the left shows the size of the free block in bytes and the column on
the right shows the number of blocks of that size that are available.  The
<code>SHOWFREE</code> option also displays this information.

<pre>free blocks: 10 (2919 bytes)
       2280: 1
        508: 1
         76: 1
         32: 1
          7: 1
          4: 3
          3: 1
          1: 1
</pre>

<p>The next block of data shows a summary of all freed memory allocations.  This is
only possible because the <code>NOFREE</code> option was also given, otherwise there
would be no details on freed memory allocations.  All of these entries show
where the allocation was freed, which can be useful if you quickly needed to see
where an allocation was freed.  The <code>SHOWFREED</code> option also displays this
information.  Note that if the argument supplied to the <code>NOFREE</code> option
was zero then this list will show the details of every single freed memory
allocation that occurred during the lifetime of the program; otherwise it will
be limited to the size of the freed queue and will show only the most
recently-freed items.

<p>As this example was run on UNIX, the mpatrol library replaces the default
implementations of <code>malloc()</code>, <code>free()</code>, etc.  As can be seen below,
this allows the library to trace all calls to allocate dynamic memory in a
process, even from functions that were not compiled with mpatrol.  Four of the
five functions shown below were called by the mpatrol library in order to read
the symbols from ELF object files.  However, they are located in the ELF access
library which was not compiled with mpatrol.

<p>Note that the following data has again been cut down in size for the purposes of
this example.  The <code><small>...</small></code> marks text that has been removed.

<pre>freed allocations: 13 (19756 bytes)
    0x0002E010 (232 bytes) {free:1:0} [-|-|-]
        0x7FB3E5BC _elf_end+776
        0x7FB6B3D4 __mp_addsymbols+440
        0x7FB6FF5C __mp_init+208
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    0x0002E118 (3536 bytes) {free:2:0} [-|-|-]
        0x7FB3E450 _elf_end+412
        0x7FB6B3D4 __mp_addsymbols+440
        0x7FB6FF5C __mp_init+208
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    0x0002EF08 (232 bytes) {free:3:0} [-|-|-]
        0x7FB3E5BC _elf_end+776
        0x7FB6B3D4 __mp_addsymbols+440
        0x7FB6B4B4 __mp_addextsymbols+208
        0x7FB6FF64 __mp_init+216
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    0x0002F010 (2448 bytes) {free:4:0} [-|-|-]
        0x7FB3E450 _elf_end+412
        0x7FB6B3D4 __mp_addsymbols+440
        0x7FB6B4B4 __mp_addextsymbols+208
        0x7FB6FF64 __mp_init+216
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    <small>...</small>

    0x00045DF0 (4 bytes) {free:20:0} [main|test.c|17]
        0x00010A14 main+132
        0x00010970 _start+192
</pre>

<p>The final block of data shows a summary of all unfreed memory allocations.  This
can show up memory leaks, although all but one of the unfreed memory allocations
in this example come from the standard C library.  On systems such as UNIX it
does not really matter about these unfreed allocations since they will
automatically be returned to the system on process termination.

<p>However, the other unfreed allocation shows an example of a memory leak, where
no pointers referencing that allocation remain in the program to free it with. 
If this was within a loop then the program could quickly run away with memory,
causing at least a decrease in performance, and at most a memory shortage.  The
mpatrol library makes it easier to spot memory leaks, especially if the
<code>PROF</code> profiling option is used.

<p>The <code>SHOWUNFREED</code> option also displays this information.

<pre>unfreed allocations: 7 (1369 bytes)
    0x0002FDE0 (36 bytes) {calloc:13:0} [-|-|-]
        0x7FA54B7C _tzload+56
        0x7FA53990 _ltzset_u+444
        0x7FA52D98 localtime_u+28
        0x7FA3AF20 ctime+12
        0x7FB6D05C __mp_printversion+184
        0x7FB6FFA0 __mp_init+276
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    0x0002FE28 (241 bytes) {calloc:15:0} [-|-|-]
        0x7FA54E3C _tzload+760
        0x7FA53990 _ltzset_u+444
        0x7FA52D98 localtime_u+28
        0x7FA3AF20 ctime+12
        0x7FB6D05C __mp_printversion+184
        0x7FB6FFA0 __mp_init+276
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    0x0002FF40 (84 bytes) {calloc:16:0} [-|-|-]
        0x7FA54E64 _tzload+800
        0x7FA53990 _ltzset_u+444
        0x7FA52D98 localtime_u+28
        0x7FA3AF20 ctime+12
        0x7FB6D05C __mp_printversion+184
        0x7FB6FFA0 __mp_init+276
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    0x0002FFB8 (13 bytes) {calloc:17:0} [-|-|-]
        0x7FA54EE8 _tzload+932
        0x7FA53990 _ltzset_u+444
        0x7FA52D98 localtime_u+28
        0x7FA3AF20 ctime+12
        0x7FB6D05C __mp_printversion+184
        0x7FB6FFA0 __mp_init+276
        0x7FB701FC __mp_alloc+84
        0x000109B8 main+40
        0x00010970 _start+192

    0x0002FFE8 (4 bytes) {malloc:19:0} [main|test.c|14]
        0x000109B8 main+40
        0x00010970 _start+192

    <small>...</small>
</pre>

<p><hr>
Node:<a name="Tutorial">Tutorial</a>,
Next:<a rel=next href="#Functions">Functions</a>,
Previous:<a rel=previous href="#Examples">Examples</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>12 Tutorial</h1>

<p>In this chapter we'll look at a real example of using the mpatrol library to
debug a program.  All of the following building and debugging steps were
performed on an Intel Linux machine so the details may differ slightly on
your system, but the concepts should remain the same.  However, on systems
without virtual memory some of the steps may actually cause the machine to lock
up or crash so be aware of this if you are running such a system -- you may be
safer just reading this tutorial rather than attempting it!

<p>This tutorial will also make use of the option <code>USEDEBUG</code> which displays
source-level file names and line numbers associated with symbols in call stack
tracebacks, but only if the underlying object file access library supports
reading line tables from object files and even then only if the object files
were compiled with debugging information enabled.  Alternatively, you may be
able to use the <code>mpsym</code> command to obtain such information instead.

<p>The program we are going to look at is a simple filter which processes its
standard input and displays the processed information on its standard output. 
In this case the program converts all lowercase characters to uppercase and
removes any blank lines.  The source for the program is given below, but can
also be found in <code>tests/tutorial/test1.c</code>.

<pre>23  /*
24   * Reads the standard input file stream, converts all lowercase
25   * characters to uppercase, and displays all non-empty lines to the
26   * standard output file stream.
27   */


30  #include &lt;stdio.h&gt;
31  #include &lt;stdlib.h&gt;
32  #include &lt;string.h&gt;
33  #include &lt;ctype.h&gt;


36  char *strtoupper(char *s)
37  {
38      char *t;
39      size_t i, l;

41      l = strlen(s);
42      t = (char *) malloc(l);
43      for (i = 0; i &lt; l; i++)
44          t[i] = toupper(s[i]);
45      t[i] = '\0';
46      return t;
47  }


50  int main(void)
51  {
52      char *b, *s;

54      b = (char *) malloc(BUFSIZ);
55      while (gets(b))
56      {
57          s = strtoupper(b);
58          if (*s != '\0')
59          {
60              puts(s);
61              free(s);
62          }
63      }
64      free(b);
65      return EXIT_SUCCESS;
66  }
</pre>

<p>If you quickly skimmed over the above code then you might have noticed some
rather obvious errors, but there are also some less obvious ones hidden there
as well.  After compiling and linking with the system C compiler and libraries
it successfully runs, even when its source code is piped to it.  So if it runs,
why bother trying to debug it?

<p>The short answer to that is that this program does in fact contain one rather
major error that is likely to prevent it from running portably on other systems. 
However, for the purposes of this tutorial, we'll pretend that we've just been
handed the source code for this program and have not worked on it before.  So
let's now try to compile and link it with the mpatrol library<a rel=footnote href="#fn-38"><sup>38</sup></a>.

<p>First, add the inclusion of <code>mpatrol.h</code> to line 34 so that we can replace
calls to <code>malloc()</code> and <code>free()</code> with their mpatrol
equivalents<a rel=footnote href="#fn-39"><sup>39</sup></a>.  Then, recompile the program and link it with the
mpatrol library.  This time, running it with even the simplest of non-empty
input lines should cause it to abort!

<p>If you look at the <code>mpatrol.log</code> file produced, you should see something
along the lines of the following at the end of the log file.

<pre>ERROR: [FRECOR]: free memory corruption at 0x08067FF6
        0x08067FF6  00555555 55555555 5555               .UUUUUUUUU
</pre>

<p>This tells us that something has written a zero byte into free memory at
location <code>0x08067FF6</code>.  Unfortunately, the library only caught it at the
next call to one of its functions so it had already happened somewhere in
between the last call and the current call.  Turning on the <code>LOGALL</code>
option in the <code>MPATROL_OPTIONS</code> environment variable allows us to see the
last successful function call to the mpatrol library.

<pre>ALLOC: malloc (56, 8192 bytes, 4 bytes) [main|test1.c|54]
        0x0804960E main+34 at test1.c:54
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

returns 0x080F0B48

ALLOC: malloc (68, 2 bytes, 4 bytes) [strtoupper|test1.c|42]
        0x08049592 strtoupper+50 at test1.c:42
        0x08049631 main+69 at test1.c:57
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

returns 0x08067FF4
</pre>

<p>Unfortunately, this only tells us that the last successful mpatrol library
function call was <code>malloc()</code> called from <code>strtoupper()</code>.  If we add
the option <code>OFLOWSIZE=8</code> to the <code>MPATROL_OPTIONS</code> environment
variable then we get slightly more information about which memory allocation was
affected<a rel=footnote href="#fn-40"><sup>40</sup></a>.

<pre>ERROR: [ALLOVF]: allocation 0x08071E34 has a corrupted overflow buffer at
                 0x08071E36
        0x08071E36  00AAAAAA AAAAAAAA                    ........

    0x08071E34 (2 bytes) {malloc:68:0} [strtoupper|test1.c|42]
        0x08049592 strtoupper+50 at test1.c:42
        0x08049631 main+69 at test1.c:57
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33
</pre>

<p>Now we can make a better guess about what is happening.  Since the start of
the upper overflow buffer of allocation 68 has been written to, we can assume
that something has written one byte beyond the end of that memory allocation. 
You can probably see where that is happening now by looking at the code, but
let's try to be even more sure that this is what is wrong.

<p>The only foolproof way to do this is to add a watch point to keep an eye on the
address that is being written to.  This can normally only be done within a
debugger, but on systems that support programmable software watch points, the
<code>OFLOWWATCH</code> option can be used to do the same thing.  For the sake of
generality, we'll use the debugger watch point approach, in this case with
<code>gdb</code>.  In order for the following example to work correctly you'll
need to add the <code>ALLOCSTOP=68</code> option to the <code>MPATROL_OPTIONS</code>
environment variable so that we can stop just after the last successful memory
allocation.

<pre>(gdb) break main
Breakpoint 1 at 0x80495f2: file test1.c, line 54.
(gdb) run &lt;test1.c
Starting program: a.out
Breakpoint 1, main() at test1.c:54
54          b = (char *) malloc(BUFSIZ);
(gdb) break __mp_trap
Breakpoint 2 at 0x804f083
(gdb) continue
Continuing.
Breakpoint 2, 0x804f083 in __mp_trap()
(gdb) backtrace
#0  0x804f083 in __mp_trap()
#1  0x804c81b in __mp_getmemory()
#2  0x8049a94 in __mp_alloc()
#3  0x8049592 in strtoupper(s=0x80f0be0 "/*") at test1.c:42
#4  0x8049631 in main() at test1.c:57
(gdb) step
Single stepping until exit from function __mp_trap,
which has no line number information.
0x804c81b in __mp_getmemory()
(gdb) step
Single stepping until exit from function __mp_getmemory,
which has no line number information.
0x8049a94 in __mp_alloc()
(gdb) step
Single stepping until exit from function __mp_alloc,
which has no line number information.
strtoupper(s=0x80f0be0 "/*") at test1.c:43
43          for (i = 0; i &lt; l; i++)
(gdb) watch *0x8071e36
Hardware watchpoint 3: *134684214
(gdb) continue
Continuing.
Hardware watchpoint 3: *134684214
Old value = -1431655766
New value = -1431655936
strtoupper(s=0x80f0be0 "/*") at test1.c:46
46          return t;
(gdb) quit
The program is running.  Exit anyway? (y or n) y
</pre>

<p>After loading the program into <code>gdb</code>, we need to break at <code>main()</code>
so that we can run to a point where all of the shared library symbols have been
loaded into memory<a rel=footnote href="#fn-41"><sup>41</sup></a>.  We can then set another
breakpoint at <code>__mp_trap()</code> and continue until allocation 68 has been
reached.

<p>Because the mpatrol library has not been built with debugging information in
this example we can quickly step back to the <code>strtoupper()</code> function since
<code>gdb</code> won't step through functions that have no debugging information. 
We then set a watch point on address <code>0x8071e36</code>, which is the address of
the memory location that has been causing the problems.  After continuing, the
debugger stops at line 46, but this is more likely to be line 45 since that is
where a zero byte is being written to<a rel=footnote href="#fn-42"><sup>42</sup></a>.

<p>So, we have located the problem, which is simply a case of not allocating
enough memory to contain the copied string <em>and</em> the terminating zero byte. 
We can also improve the <code>strtoupper()</code> function by checking the pointer
returned by <code>malloc()</code> to see if it is <code>NULL</code>, and if so simply exit
with an error.  You can try running the program with the <code>FAILFREQ</code>
option to see how it would originally behave in a low memory situation.

<p>The following listing shows the above modifications that we have made to our
program.  It can also be found in <code>tests/tutorial/test2.c</code>.

<pre>23  /*
24   * Reads the standard input file stream, converts all lowercase
25   * characters to uppercase, and displays all non-empty lines to the
26   * standard output file stream.
27   */


30  #include &lt;stdio.h&gt;
31  #include &lt;stdlib.h&gt;
32  #include &lt;string.h&gt;
33  #include &lt;ctype.h&gt;
34  #include "mpatrol.h"


37  char *strtoupper(char *s)
38  {
39      char *t;
40      size_t i, l;

42      l = strlen(s);
43      if ((t = (char *) malloc(l + 1)) == NULL)
44      {
45          fputs("strtoupper: out of memory\n", stderr);
46          exit(EXIT_FAILURE);
47      }
48      for (i = 0; i &lt; l; i++)
49          t[i] = toupper(s[i]);
50      t[i] = '\0';
51      return t;
52  }


55  int main(void)
56  {
57      char *b, *s;

59      b = (char *) malloc(BUFSIZ);
60      while (gets(b))
61      {
62          s = strtoupper(b);
63          if (*s != '\0')
64          {
65              puts(s);
66              free(s);
67          }
68      }
69      free(b);
70      return EXIT_SUCCESS;
71  }
</pre>

<p>Leaving aside the obvious problem with <code>gets()</code> and the general
inefficiency of the algorithm, we could assume that our program works safely
now and we can release it to the outside world.  However, a user soon reports
a problem with our program steadily using more and more memory during its
execution when processing very large files.

<p>This is generally attributable to a memory leak and so we can use the
<code>SHOWUNFREED</code> option to try to detect where the memory leak is coming
from.  Following is some example output from the mpatrol log file when our
program is run and is given a relatively small text file as input.

<pre>unfreed allocations: 10 (185 bytes)
    0x08062000 (176 bytes) {malloc:1:0} [-|-|-]
        0x400B681B _IO_new_fopen+27
        0x0804F24E __mp_openlogfile+70
        0x080497B5 __mp_init+109
        0x08049973 __mp_alloc+31
        0x0804962E main+34 at test2.c:59
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x08067FF4 (1 byte) {malloc:83:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x08067FF8 (1 byte) {malloc:89:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x08067FFC (1 byte) {malloc:90:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x0808B304 (1 byte) {malloc:95:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x0808B308 (1 byte) {malloc:96:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x0808B30C (1 byte) {malloc:101:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x0808B310 (1 byte) {malloc:113:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x0808B314 (1 byte) {malloc:114:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33

    0x0808B318 (1 byte) {malloc:118:0} [strtoupper|test2.c|43]
        0x08049593 strtoupper+51 at test2.c:43
        0x08049651 main+69 at test2.c:62
        0x4007C9CB __libc_start_main+255
        0x080494D1 _start+33
</pre>

<p>We can discount the first entry since that is obviously coming from when the
mpatrol library first initialises itself.  However, all of the other entries
appear to be coming from line 43 within <code>strtoupper()</code> and appear to be
only 1 byte in length.  At that point in the code, the only possible reason
for allocating 1 byte is when the string is empty and so that must mean that
we are not freeing memory that contains empty strings.  Looking at line 66 we
can see that <code>free()</code> is only ever called for non-empty strings and
therefore if we move the call to <code>free()</code> outside the test for an empty
string we will fix the memory leak.  The file <code>tests/tutorial/test3.c</code>
contains the source for the final program.

<p><hr>
Node:<a name="Functions">Functions</a>,
Next:<a rel=next href="#Environment">Environment</a>,
Previous:<a rel=previous href="#Tutorial">Tutorial</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix A Functions</h1>

<p>The mpatrol library contains implementations of dynamic memory allocation
functions for C and C++ suitable for tracing and debugging.  The library is
intended to be used without requiring any changes to existing user source code
except the inclusion of the <code>mpatrol.h</code> header file, although additional
functions are supplied for extra tracing and control.  Note that the current
version of the mpatrol library is contained in the <code>MPATROL_VERSION</code>
preprocessor macro.

<p>All of the function definitions in <code>mpatrol.h</code> can be disabled by defining
the <code>NDEBUG</code> preprocessor macro, which is the same macro used to control
the behaviour of the <code>assert()</code> function.  If <code>NDEBUG</code> is defined then
no macro redefinition of functions will take place and all special mpatrol
library functions will evaluate to empty statements.  It is intended that the
<code>NDEBUG</code> preprocessor macro be defined in release builds.

<p>The following 18 functions are available as replacements for existing C library
functions.  To use these you must include <code>mpatrol.h</code> before all other
header files, although on UNIX and Windows platforms (and AmigaOS when using
<code>gcc</code>) they will be used anyway, albeit with slightly less tracing
information.  If <code>alloca()</code> is being used and <code>alloca.h</code> is included
then <code>mpatrol.h</code> must appear before <code>alloca.h</code> otherwise the debugging
version of <code>alloca()</code> will not be used.

<dl>
<dt><code>void *malloc(size_t size)</code>
<dd>Allocates <var>size</var> uninitialised bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be suitably aligned
for casting to any type and can be used to store data of up to <var>size</var> bytes
in length.  If <var>size</var> is <code>0</code> then the memory allocated will be
implicitly rounded up to <code>1</code> byte.  If there is not enough space in the
heap then the <code>NULL</code> pointer will be returned and <code>errno</code> will be set
to <code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code>
or reallocated with <code>realloc()</code>.

<br><dt><code>void *calloc(size_t nelem, size_t size)</code>
<dd>Allocates <var>nelem</var> elements of <var>size</var> zero-initialised bytes from the
heap and returns a pointer to the first byte of the allocation.  The pointer
returned will be suitably aligned for casting to any type and can be used to
store data of up to <code>nelem * size</code> bytes in length.  If <code>nelem * size</code>
is <code>0</code> then the amount of memory allocated will be implicitly rounded up to
<code>1</code> byte.  If there is not enough space in the heap then the <code>NULL</code>
pointer will be returned and <code>errno</code> will be set to <code>ENOMEM</code>.  The
allocated memory must be deallocated with <code>free()</code> or reallocated with
<code>realloc()</code>.

<br><dt><code>void *memalign(size_t align, size_t size)</code>
<dd>Allocates <var>size</var> uninitialised bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be aligned to
<var>align</var> bytes and can be used to store data of up to <var>size</var> bytes in
length.  If <var>align</var> is zero then the default system alignment will be used. 
If <var>align</var> is not a power of two then it will be rounded up to the nearest
power of two.  If <var>align</var> is greater than the system page size then it will
be truncated to that value.  If <var>size</var> is <code>0</code> then the memory allocated
will be implicitly rounded up to <code>1</code> byte.  If there is not enough space in
the heap then the <code>NULL</code> pointer will be returned and <code>errno</code> will be
set to <code>ENOMEM</code>.  The allocated memory must be deallocated with
<code>free()</code> or reallocated with <code>realloc()</code>, although the latter will not
guarantee the preservation of alignment.

<br><dt><code>void *valloc(size_t size)</code>
<dd>Allocates <var>size</var> uninitialised bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be aligned to the
system page size and can be used to store data of up to <var>size</var> bytes in
length.  If <var>size</var> is <code>0</code> then the memory allocated will be implicitly
rounded up to <code>1</code> byte.  If there is not enough space in the heap then the
<code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code> or
reallocated with <code>realloc()</code>, although the latter will not guarantee the
preservation of alignment.

<br><dt><code>void *pvalloc(size_t size)</code>
<dd>Allocates <var>size</var> uninitialised bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be aligned to the
system page size and can be used to store data of up to <var>size</var> bytes in
length.  If <var>size</var> is <code>0</code> then the memory allocated will be implicitly
rounded up to <code>1</code> page, otherwise <var>size</var> will be implicitly rounded up
to a multiple of the system page size.  If there is not enough space in the heap
then the <code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code> or
reallocated with <code>realloc()</code>, although the latter will not guarantee the
preservation of alignment.

<br><dt><code>void *alloca(size_t size)</code>
<dd>Allocates <var>size</var> temporary uninitialised bytes from the heap and returns a
pointer to the first byte of the allocation.  The pointer returned will be
suitably aligned for casting to any type and can be used to store data of up to
<var>size</var> bytes in length.  If <var>size</var> is <code>0</code> then the memory allocated
will be implicitly rounded up to <code>1</code> byte.  If there is not enough space in
the heap then the <code>NULL</code> pointer will be returned and <code>errno</code> will be
set to <code>ENOMEM</code>.  The <code>alloca()</code> function normally allocates its
memory from the stack, with the result that all such allocations will be freed
when the function returns.  This version of <code>alloca()</code> allocates its memory
from the heap in order to provide better debugging, but the allocations may not
necessarily be freed immediately when the function returns.  The allocated
memory can be deallocated explicitly with <code>dealloca()</code>, but may not be
reallocated or deallocated in any other way.  This function is available for
backwards compatibility with older C source code and should not be used in new
code.

<br><dt><code>char *strdup(const char *str)</code>
<dd>Allocates exactly enough memory from the heap to duplicate <var>str</var> (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying <var>str</var> to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of <var>str</var>.  If <var>str</var> is <code>NULL</code> then an error
will be given and the <code>NULL</code> pointer will be returned.  If there is not
enough space in the heap then the <code>NULL</code> pointer will be returned and
<code>errno</code> will be set to <code>ENOMEM</code>.  The allocated memory must be
deallocated with <code>free()</code> or reallocated with <code>realloc()</code>.

<br><dt><code>char *strndup(const char *str, size_t size)</code>
<dd>Allocates exactly enough memory from the heap to duplicate <var>str</var> (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying <var>str</var> to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of <var>str</var>.  If <var>str</var> is <code>NULL</code> and <var>size</var>
is non-zero then an error will be given and the <code>NULL</code> pointer will be
returned.  If the length of <var>str</var> is greater than <var>size</var> then only
<var>size</var> characters will be allocated and copied, with one additional byte for
the nul character.  If there is not enough space in the heap then the
<code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code> or
reallocated with <code>realloc()</code>.  This function is available for backwards
compatibility with older C libraries and should not be used in new code.

<br><dt><code>char *strsave(const char *str)</code>
<dd>Allocates exactly enough memory from the heap to duplicate <var>str</var> (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying <var>str</var> to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of <var>str</var>.  If <var>str</var> is <code>NULL</code> then an error
will be given and the <code>NULL</code> pointer will be returned.  If there is not
enough space in the heap then the <code>NULL</code> pointer will be returned and
<code>errno</code> will be set to <code>ENOMEM</code>.  The allocated memory must be
deallocated with <code>free()</code> or reallocated with <code>realloc()</code>.  This
function is available for backwards compatibility with older C libraries and
should not be used in new code.

<br><dt><code>char *strnsave(const char *str, size_t size)</code>
<dd>Allocates exactly enough memory from the heap to duplicate <var>str</var> (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying <var>str</var> to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of <var>str</var>.  If <var>str</var> is <code>NULL</code> and <var>size</var>
is non-zero then an error will be given and the <code>NULL</code> pointer will be
returned.  If the length of <var>str</var> is greater than <var>size</var> then only
<var>size</var> characters will be allocated and copied, with one additional byte for
the nul character.  If there is not enough space in the heap then the
<code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code> or
reallocated with <code>realloc()</code>.  This function is available for backwards
compatibility with older C libraries and should not be used in new code.

<br><dt><code>char *strdupa(const char *str)</code>
<dd>Allocates exactly enough temporary memory from the heap to duplicate <var>str</var>
(including the terminating nul character) and returns a pointer to the first
byte of the allocation after copying <var>str</var> to the newly-allocated memory. 
The pointer returned will have no alignment constraints and can be used to store
character data up to the length of <var>str</var>.  If <var>str</var> is <code>NULL</code> then
an error will be given and the <code>NULL</code> pointer will be returned.  If there
is not enough space in the heap then the <code>NULL</code> pointer will be returned
and <code>errno</code> will be set to <code>ENOMEM</code>.  The <code>strdupa()</code> function
normally allocates its memory from the stack, with the result that all such
allocations will be freed when the function returns.  This version of
<code>strdupa()</code> allocates its memory from the heap in order to provide better
debugging, but the allocations may not necessarily be freed immediately when the
function returns.  The allocated memory can be deallocated explicitly with
<code>dealloca()</code>, but may not be reallocated or deallocated in any other way. 
This function is available for backwards compatibility with older C source code
and should not be used in new code.

<br><dt><code>char *strndupa(const char *str, size_t size)</code>
<dd>Allocates exactly enough temporary memory from the heap to duplicate <var>str</var>
(including the terminating nul character) and returns a pointer to the first
byte of the allocation after copying <var>str</var> to the newly-allocated memory. 
The pointer returned will have no alignment constraints and can be used to store
character data up to the length of <var>str</var>.  If <var>str</var> is <code>NULL</code> and
<var>size</var> is non-zero then an error will be given and the <code>NULL</code> pointer
will be returned.  If the length of <var>str</var> is greater than <var>size</var> then
only <var>size</var> characters will be allocated and copied, with one additional
byte for the nul character.  If there is not enough space in the heap then the
<code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The <code>strndupa()</code> function normally allocates its memory
from the stack, with the result that all such allocations will be freed when the
function returns.  This version of <code>strndupa()</code> allocates its memory from
the heap in order to provide better debugging, but the allocations may not
necessarily be freed immediately when the function returns.  The allocated
memory can be deallocated explicitly with <code>dealloca()</code>, but may not be
reallocated or deallocated in any other way.  This function is available for
backwards compatibility with older C source code and should not be used in new
code.

<br><dt><code>void *realloc(void *ptr, size_t size)</code>
<dd>Resizes the memory allocation beginning at <var>ptr</var> to <var>size</var> bytes and
returns a pointer to the first byte of the new allocation after copying
<var>ptr</var> to the newly-allocated memory, which will be truncated if <var>size</var>
is smaller than the original allocation.  The pointer returned will be suitably
aligned for casting to any type and can be used to store data of up to
<var>size</var> bytes in length.  If <var>ptr</var> is <code>NULL</code> then the call will be
equivalent to <code>malloc()</code>.  If <var>size</var> is <code>0</code> then the existing
memory allocation will be freed and the <code>NULL</code> pointer will be returned. 
If <var>size</var> is greater than the original allocation then the extra space will
be filled with uninitialised bytes.  If there is not enough space in the heap
then the <code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code> and
can be reallocated again with <code>realloc()</code>.

<br><dt><code>void *recalloc(void *ptr, size_t nelem, size_t size)</code>
<dd>Resizes the memory allocation beginning at <var>ptr</var> to <var>nelem</var> elements of
<var>size</var> bytes and returns a pointer to the first byte of the new allocation
after copying <var>ptr</var> to the newly-allocated memory, which will be truncated
if <code>nelem * size</code> is smaller than the original allocation.  The pointer
returned will be suitably aligned for casting to any type and can be used to
store data of up to <code>nelem * size</code> bytes in length.  If <var>ptr</var> is
<code>NULL</code> then the call will be equivalent to <code>calloc()</code>.  If
<code>nelem * size</code> is <code>0</code> then the existing memory allocation will be
freed and the <code>NULL</code> pointer will be returned.  If <code>nelem * size</code> is
greater than the original allocation then the extra space will be filled with
zero-initialised bytes.  If there is not enough space in the heap then the
<code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code> and
can be reallocated again with <code>realloc()</code>.  This function is available for
backwards compatibility with older C libraries and <code>calloc()</code> and should
not be used in new code.

<br><dt><code>void *expand(void *ptr, size_t size)</code>
<dd>Attempts to resize the memory allocation beginning at <var>ptr</var> to <var>size</var>
bytes and either returns <var>ptr</var> if there was enough space to resize it, or
<code>NULL</code> if the block could not be resized for a particular reason.  If
<var>ptr</var> is <code>NULL</code> then the call will be equivalent to <code>malloc()</code>. 
If <var>size</var> is <code>0</code> then the existing memory allocation will be freed and
the <code>NULL</code> pointer will be returned.  If <var>size</var> is greater than the
original allocation then the extra space will be filled with uninitialised bytes
and if <var>size</var> is less than the original allocation then the memory block
will be truncated.  If there is not enough space in the heap then the
<code>NULL</code> pointer will be returned and <code>errno</code> will be set to
<code>ENOMEM</code>.  The allocated memory must be deallocated with <code>free()</code> and
can be reallocated again with <code>realloc()</code>.  This function is available for
backwards compatibility with older C libraries and should not be used in new
code.

<br><dt><code>void free(void *ptr)</code>
<dd>Frees the memory allocation beginning at <var>ptr</var> so the memory can be reused
by another call to allocate memory.  If <var>ptr</var> is <code>NULL</code> then no memory
will be freed.  All of the previous contents will be destroyed.

<br><dt><code>void cfree(void *ptr, size_t nelem, size_t size)</code>
<dd>Frees the memory allocation beginning at <var>ptr</var> so the memory can be reused
by another call to allocate memory.  If <var>ptr</var> is <code>NULL</code> then no memory
will be freed.  All of the previous contents will be destroyed.  The <var>nelem</var>
and <var>size</var> parameters are ignored in this implementation.  This function is
available for backwards compatibility with older C libraries and <code>calloc()</code>
and should not be used in new code.

<br><dt><code>void dealloca(void *ptr)</code>
<dd>Explicitly frees the temporary memory allocation beginning at <var>ptr</var> so the
memory can be reused by another call to allocate memory.  If <var>ptr</var> is
<code>NULL</code> then no memory will be freed.  All of the previous contents will be
destroyed.  This function can only be used to free memory that was allocated
with the <code>alloca()</code>, <code>strdupa()</code> and <code>strndupa()</code> functions, but
is only really required if the mpatrol library does not automatically free such
memory allocations when the allocating function returns.  This function is
mpatrol-specific and should not be used in release code. 
</dl>

<p>The following 5 functions are available as replacements for existing C++ library
functions, but the replacements in <code>mpatrol.h</code> will only be used if the
<code>MP_NOCPLUSPLUS</code> preprocessor macro is not defined.  The replacement
operators make use of the preprocessor in order to obtain source-level
information.  If this causes problems then you should define the
<code>MP_NONEWDELETE</code> preprocessor macro and use the <code>MP_NEW</code> and
<code>MP_DELETE</code> macros instead of <code>new</code> and <code>delete</code> directly.  To
use these C++ features you must include <code>mpatrol.h</code> before all other header
files, although on UNIX and Windows platforms (and AmigaOS when using
<code>gcc</code>) they will be used anyway, albeit with slightly less tracing
information.

<dl>
<dt><code>void *operator new(size_t size)</code>
<dd>Allocates <var>size</var> uninitialised bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be suitably aligned
for casting to any type and can be used to store data of up to <var>size</var> bytes
in length.  If <var>size</var> is <code>0</code> then the memory allocated will be
implicitly rounded up to <code>1</code> byte.  If there is not enough space in the
heap then the <code>NULL</code> pointer will be returned and <code>errno</code> will be set
to <code>ENOMEM</code> -- no exceptions will be thrown.  The allocated memory must be
deallocated with <code>operator delete</code>.

<br><dt><code>void *operator new[](size_t size)</code>
<dd>Allocates <var>size</var> uninitialised bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be suitably aligned
for casting to any type and can be used to store data of up to <var>size</var> bytes
in length.  If <var>size</var> is <code>0</code> then the memory allocated will be
implicitly rounded up to <code>1</code> byte.  If there is not enough space in the
heap then the <code>NULL</code> pointer will be returned and <code>errno</code> will be set
to <code>ENOMEM</code> -- no exceptions will be thrown.  The allocated memory must be
deallocated with <code>operator delete[]</code>.

<br><dt><code>void operator delete(void *ptr)</code>
<dd>Frees the memory allocation beginning at <var>ptr</var> so the memory can be reused
by another call to allocate memory.  If <var>ptr</var> is <code>NULL</code> then no memory
will be freed.  All of the previous contents will be destroyed.  This function
must only be used with memory allocated by <code>operator new</code>.

<br><dt><code>void operator delete[](void *ptr)</code>
<dd>Frees the memory allocation beginning at <var>ptr</var> so the memory can be reused
by another call to allocate memory.  If <var>ptr</var> is <code>NULL</code> then no memory
will be freed.  All of the previous contents will be destroyed.  This function
must only be used with memory allocated by <code>operator new[]</code>.

<br><dt><code>void (*set_new_handler(void (*func)(void)))(void)</code>
<dd>Installs a low-memory handler specifically for use with <code>operator new</code> and
<code>operator new[]</code> and returns a pointer to the previously installed handler,
or the <code>NULL</code> pointer if no handler had been previously installed.  This
will be called repeatedly by both functions when they would normally return
<code>NULL</code>, and this loop will continue until they manage to allocate the
requested space.  The default low-memory handler for the C++ operators will
terminate the program and write an out of memory message to the log file.  Note
that this function is equivalent to <code>__mp_nomemory()</code> and will replace the
handler installed by that function. 
</dl>

<p>The following 10 functions are available as replacements for existing C library
memory operation functions.  To use these you must include <code>mpatrol.h</code>
before all other header files, although on UNIX and Windows platforms (and
AmigaOS when using <code>gcc</code>) they will be used anyway, albeit with slightly
less tracing information.

<dl>
<dt><code>void *memset(void *ptr, int byte, size_t size)</code>
<dd>Writes <var>size</var> bytes of value <var>byte</var> to the memory location beginning at
<var>ptr</var> and returns <var>ptr</var>.  If <var>size</var> is <code>0</code> then no bytes will
be written.  If the operation would affect an existing memory allocation in the
heap but would straddle that allocation's boundaries then an error message will
be generated in the log file and no bytes will be written.

<br><dt><code>void bzero(void *ptr, size_t size)</code>
<dd>Writes <var>size</var> zero bytes to the memory location beginning at <var>ptr</var>.  If
<var>size</var> is <code>0</code> then no bytes will be written.  If the operation would
affect an existing memory allocation in the heap but would straddle that
allocation's boundaries then an error message will be generated in the log file
and no bytes will be written.  This function is available for backwards
compatibility with older C libraries and should not be used in new code.

<br><dt><code>void *memccpy(void *dest, const void *src, int byte, size_t size)</code>
<dd>Copies <var>size</var> bytes from <var>src</var> to <var>dest</var> and returns <code>NULL</code>, or
copies the number of bytes up to and including the first occurrence of
<var>byte</var> if <var>byte</var> exists within the specified range and returns a pointer
to the first byte after <var>byte</var>.  If <var>size</var> is <code>0</code> or <var>src</var> is
the same as <var>dest</var> then no bytes will be copied.  The source and destination
ranges should not overlap, otherwise a warning will be written to the log file. 
If the operation would affect an existing memory allocation in the heap but
would straddle that allocation's boundaries then an error message will be
generated in the log file and no bytes will be copied.

<br><dt><code>void *memcpy(void *dest, const void *src, size_t size)</code>
<dd>Copies <var>size</var> bytes from <var>src</var> to <var>dest</var> and returns <var>dest</var>.  If
<var>size</var> is <code>0</code> or <var>src</var> is the same as <var>dest</var> then no bytes will
be copied.  The source and destination ranges should not overlap, otherwise a
warning will be written to the log file.  If the operation would affect an
existing memory allocation in the heap but would straddle that allocation's
boundaries then an error message will be generated in the log file and no bytes
will be copied.

<br><dt><code>void *memmove(void *dest, const void *src, size_t size)</code>
<dd>Copies <var>size</var> bytes from <var>src</var> to <var>dest</var> and returns <var>dest</var>.  If
<var>size</var> is <code>0</code> or <var>src</var> is the same as <var>dest</var> then no bytes will
be copied.  If the operation would affect an existing memory allocation in the
heap but would straddle that allocation's boundaries then an error message will
be generated in the log file and no bytes will be copied.

<br><dt><code>void bcopy(const void *src, void *dest, size_t size)</code>
<dd>Copies <var>size</var> bytes from <var>src</var> to <var>dest</var>.  If <var>size</var> is <code>0</code>
or <var>src</var> is the same as <var>dest</var> then no bytes will be copied.  If the
operation would affect an existing memory allocation in the heap but would
straddle that allocation's boundaries then an error message will be generated in
the log file and no bytes will be copied.  This function is available for
backwards compatibility with older C libraries and should not be used in new
code.

<br><dt><code>int memcmp(const void *ptr1, const void *ptr2, size_t size)</code>
<dd>Compares <var>size</var> bytes from <var>ptr1</var> and <var>ptr2</var> and returns <code>0</code> if
all of the bytes are identical, or returns the byte difference of the first
differing bytes.  If <var>size</var> is <code>0</code> or <var>ptr1</var> is the same as
<var>ptr2</var> then no bytes will be compared.  If the operation would read from an
existing memory allocation in the heap but would straddle that allocation's
boundaries then an error message will be generated in the log file and no bytes
will be compared.

<br><dt><code>int bcmp(const void *ptr1, const void *ptr2, size_t size)</code>
<dd>Compares <var>size</var> bytes from <var>ptr1</var> and <var>ptr2</var> and returns <code>0</code> if
all of the bytes are identical, or returns the byte difference of the first
differing bytes.  If <var>size</var> is <code>0</code> or <var>ptr1</var> is the same as
<var>ptr2</var> then no bytes will be compared.  If the operation would read from an
existing memory allocation in the heap but would straddle that allocation's
boundaries then an error message will be generated in the log file and no bytes
will be compared.  This function is available for backwards compatibility with
older C libraries and should not be used in new code.

<br><dt><code>void *memchr(const void *ptr, int byte, size_t size)</code>
<dd>Searches up to <var>size</var> bytes in <var>ptr</var> for the first occurrence of
<var>byte</var> and returns a pointer to it or <code>NULL</code> if no such byte occurs. 
If <var>size</var> is <code>0</code> then no bytes will be searched.  If the operation
would affect an existing memory allocation in the heap but would straddle that
allocation's boundaries then an error message will be generated in the log file
and no bytes will be searched.

<br><dt><code>void *memmem(const void *ptr1, size_t size1, const void *ptr2, size_t size2)</code>
<dd>Searches up to <var>size1</var> bytes in <var>ptr1</var> for the first occurrence of
<var>ptr2</var> (which is exactly <var>size2</var> bytes in length) and returns a pointer
to it or <code>NULL</code> if no such sequence of bytes occur.  If <var>size1</var> or
<var>size2</var> is <code>0</code> then no bytes will be searched.  If the operation would
affect an existing memory allocation in the heap but would straddle that
allocation's boundaries then an error message will be generated in the log file
and no bytes will be searched. 
</dl>

<p>The following 8 functions are available as support routines for additional
control and tracing in the mpatrol library.  To use these you should include the
<code>mpatrol.h</code> header file.

<dl>
<dt><code>int __mp_info(const void *ptr, __mp_allocinfo *info)</code>
<dd>Obtains information about a specific memory allocation by placing statistics
about <var>ptr</var> in <var>info</var>.  If <var>ptr</var> does not belong to a previously
allocated memory allocation then <code>0</code> will be returned, otherwise <code>1</code>
will be returned and <var>info</var> will contain the following information:

<p><table><tr align="left"><td><em>Field</em>
<td><em>Description</em>
<br></tr><tr align="left"><td><code>block</code>
<td>Pointer to first byte of allocation. 
<br></tr><tr align="left"><td><code>size</code>
<td>Size of allocation in bytes. 
<br></tr><tr align="left"><td><code>type</code>
<td>Type of function which allocated memory. 
<br></tr><tr align="left"><td><code>alloc</code>
<td>Allocation index. 
<br></tr><tr align="left"><td><code>realloc</code>
<td>Number of times reallocated. 
<br></tr><tr align="left"><td><code>thread</code>
<td>Thread identifier. 
<br></tr><tr align="left"><td><code>func</code>
<td>Function in which allocation took place. 
<br></tr><tr align="left"><td><code>file</code>
<td>File in which allocation took place. 
<br></tr><tr align="left"><td><code>line</code>
<td>Line number at which allocation took place. 
<br></tr><tr align="left"><td><code>stack</code>
<td>Pointer to function call stack. 
<br></tr><tr align="left"><td><code>freed</code>
<td>Indicates if allocation has been freed.
<br></tr></table>

<br><dt><code>int __mp_printinfo(const void *ptr)</code>
<dd>Displays information about a specific memory allocation containing <var>ptr</var> to
the standard error file stream.  If <var>ptr</var> does not belong to a previously
allocated memory allocation then <code>0</code> will be returned, otherwise <code>1</code>
will be returned.  This function is intended to be called from within a
debugger.

<br><dt><code>void __mp_memorymap(int stats)</code>
<dd>If <var>stats</var> is non-zero then the current statistics of the mpatrol library
will be displayed.  If the heap contains at least one allocated, freed or free
block then a map of the current heap will also be displayed.

<br><dt><code>void __mp_summary(void)</code>
<dd>Displays information about the current state of the mpatrol library, including
its settings and any relevant statistics.

<br><dt><code>void __mp_check(void)</code>
<dd>Forces the library to perform an immediate check of the overflow buffers of
every memory allocation and to ensure that nothing has overwritten any free
blocks.  If any memory allocations made by the <code>alloca()</code> family of
functions are out of scope then this function will also cause them to be freed.

<br><dt><code>void (*__mp_prologue(void (*func)(const void *, size_t)))(const void *, size_t)</code>
<dd>Installs a prologue function to be called before any memory allocation,
reallocation or deallocation function.  This function will return a pointer to
the previously installed prologue function, or the <code>NULL</code> pointer if no
prologue function had been previously installed.  The following arguments will
be used to call the prologue function:

<p><table><tr align="left"><td><em>Argument 1</em>
<td><em>Argument 2</em>
<td><em>Called by</em>
<br></tr><tr align="left"><td><code>-1</code>
<td><var>size</var>
<td><code>malloc()</code>, etc. 
<br></tr><tr align="left"><td><var>ptr</var>
<td><var>size</var>
<td><code>realloc()</code>, etc. 
<br></tr><tr align="left"><td><var>ptr</var>
<td><code>-1</code>
<td><code>free()</code>, etc. 
<br></tr><tr align="left"><td><var>ptr</var>
<td><code>-2</code>
<td><code>strdup()</code>, etc.
<br></tr></table>

<br><dt><code>void (*__mp_epilogue(void (*func)(const void *)))(const void *)</code>
<dd>Installs an epilogue function to be called after any memory allocation,
reallocation or deallocation function.  This function will return a pointer to
the previously installed epilogue function, or the <code>NULL</code> pointer if no
epilogue function had been previously installed.  The following arguments will
be used to call the epilogue function:

<p><table><tr align="left"><td><em>Argument</em>
<td><em>Called by</em>
<br></tr><tr align="left"><td><var>ptr</var>
<td><code>malloc()</code>, <code>realloc()</code>, <code>strdup()</code>, etc. 
<br></tr><tr align="left"><td><code>-1</code>
<td><code>free()</code>, etc.
<br></tr></table>

<br><dt><code>void (*__mp_nomemory(void (*func)(void)))(void)</code>
<dd>Installs a low-memory handler and returns a pointer to the previously installed
handler, or the <code>NULL</code> pointer if no handler had been previously installed. 
This will be called once by C memory allocation functions, and repeatedly by C++
memory allocation functions, when they would normally return <code>NULL</code>.  Note
that this function is equivalent to <code>set_new_handler()</code> and will replace
the handler installed by that function. 
</dl>

<p><hr>
Node:<a name="Environment">Environment</a>,
Next:<a rel=next href="#Options">Options</a>,
Previous:<a rel=previous href="#Functions">Functions</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix B Environment</h1>

<p>The library can read certain options at run-time from an environment variable
called <code>MPATROL_OPTIONS</code>.  This variable must contain one or more valid
option keywords from the list below and must be no longer than 1024 characters
in length.  If <code>MPATROL_OPTIONS</code> is unset or empty then the default settings
will be used.

<p>The syntax for options specified within the <code>MPATROL_OPTIONS</code> environment
variable is <code>OPTION</code> or <code>OPTION=VALUE</code>, where <code>OPTION</code> is a
keyword from the list below and <code>VALUE</code> is the setting for that option.  If
<code>VALUE</code> is numeric then it may be specified using binary, octal, decimal or
hexadecimal notation, with binary notation beginning with either <code>0b</code> or
<code>0B</code>.  If <code>VALUE</code> is a character string containing spaces then it may
be quoted using double quotes.  No whitespace may appear between the <code>=</code>
sign, but whitespace must appear between different options.  Note that option
keywords can be given in lowercase as well as uppercase, or a mixture of both.

<dl>
<dt><code>ALLOCBYTE</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies an 8-bit byte pattern with which to prefill newly-allocated memory. 
This can be used to detect the use of memory which has not been initialised
after allocation.  Note that this setting will not affect memory allocated with
<code>calloc()</code> or <code>recalloc()</code> as these functions always prefill allocated
memory with an 8-bit byte pattern of zero.  Default value:
<code>ALLOCBYTE=0xFF</code>.

<br><dt><code>ALLOCSTOP</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies an allocation index at which to stop the program when it is being
allocated.  When the number of memory allocations reaches this number the
program will be halted, and its state may be examined at that point by using a
suitable debugger.  Note that this setting will be ignored if its value is zero. 
Default value: <code>ALLOCSTOP=0</code>.

<br><dt><code>ALLOWOFLOW</code>
<dd>Specifies that a warning rather than an error should be produced if any memory
operation function overflows the boundaries of a memory allocation, and that
the operation should still be performed.  This option is provided for
circumstances where it is desirable for the memory operation to be performed,
regardless of whether it is erroneous or not.

<br><dt><code>AUTOSAVE</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the frequency at which to periodically write the profiling data to
the profiling output file.  When the total number of profiled memory allocations
and deallocations is a multiple of this number then the current profiling
information will be written to the profiling output file.  This option can be
used to instruct the mpatrol library to dump out any profiling information just
before a fatal error occurs in a program, for example.  Note that this setting
will be ignored if its value is zero.  Default value: <code>AUTOSAVE=0</code>.

<br><dt><code>CHECK</code>=&lt;<var>unsigned-range</var>&gt;
<dd>Specifies a range of allocation indices at which to check the integrity of free
memory and overflow buffers.  The range must be specified as no more than two
unsigned integers separated by a dash.  If numbers on either the left side or
the right side of the dash are omitted then they will be assumed to be <code>0</code>
and <var>infinity</var> respectively.  A value of <code>0</code> on its own indicates that
no such checking will ever be performed.  This option can be used to speed up
the execution speed of the library at the expense of checking.  Default value:
<code>CHECK=-</code>.

<br><dt><code>CHECKALL</code>
<dd>Equivalent to the <code>CHECKALLOCS</code>, <code>CHECKREALLOCS</code>,
<code>CHECKFREES</code> and <code>CHECKMEMORY</code> options specified together.

<br><dt><code>CHECKALLOCS</code>
<dd>Checks that no attempt is made to allocate a block of memory of size zero.  A
warning will be issued for every such case.

<br><dt><code>CHECKFREES</code>
<dd>Checks that no attempt is made to deallocate a <code>NULL</code> pointer.  A warning
will be issued for every such case.

<br><dt><code>CHECKMEMORY</code>
<dd>Checks that no attempt is made to perform a zero-length memory operation on a
<code>NULL</code> pointer.

<br><dt><code>CHECKREALLOCS</code>
<dd>Checks that no attempt is made to reallocate a <code>NULL</code> pointer or resize an
existing block of memory to size zero.  Warnings will be issued for every such
case.

<br><dt><code>DEFALIGN</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the default alignment for general-purpose memory allocations, which
must be a power of two (and will be rounded up to the nearest power of two if it
is not).  The default alignment for a particular system is calculated at
run-time.

<br><dt><code>EDIT</code>
<dd>Specifies that a text editor should be invoked to edit any relevant source files
that are associated with any warnings or errors when they occur.  Only
diagnostics which occur at source lines in the program will be affected and only
then if they contain source-level information.  This option is currently only
available on UNIX platforms as it makes use of the <code>mpedit</code> command.  It
also overrides the behaviour of the <code>LIST</code> option.

<br><dt><code>FAILFREQ</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the frequency at which all memory allocations will randomly fail.  For
example, a value of <code>10</code> will mean that roughly 1 in 10 memory allocations
will fail, but a value of <code>0</code> will disable all random failures.  This
option can be useful for stress-testing an application.  Default value:
<code>FAILFREQ=0</code>.

<br><dt><code>FAILSEED</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the random number seed which will be used when determining which
memory allocations will randomly fail.  A value of <code>0</code> will instruct the
library to pick a random seed every time it is run.  Any other value will mean
that the random failures will be the same every time the program is run, but
only as long as the seed stays the same.  Default value: <code>FAILSEED=0</code>.

<br><dt><code>FREEBYTE</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies an 8-bit byte pattern with which to prefill newly-freed memory.  This
can be used to detect the use of memory which has just been freed.  It is also
used internally to ensure that freed memory has not been overwritten.  Note that
the freed memory may be reused the next time a block of memory is allocated and
so once memory has been freed its contents are not guaranteed to remain the same
as the specified byte pattern.  Default value: <code>FREEBYTE=0x55</code>.

<br><dt><code>FREESTOP</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies an allocation index at which to stop the program when it is being
freed.  When the memory allocation with the specified allocation index is to be
freed the program will be halted, and its state may be examined at that point
using a suitable debugger.  Note that this setting will be ignored if its value
is zero.  Default value: <code>FREESTOP=0</code>.

<br><dt><code>HELP</code>
<dd>Displays a quick-reference option summary to the <code>stderr</code> file stream.

<br><dt><code>LARGEBOUND</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the limit in bytes up to which memory allocations should be classified
as large allocations for profiling purposes.  This limit must be greater than
the small and medium bounds.  Default value: <code>LARGEBOUND=2048</code>.

<br><dt><code>LIMIT</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the limit in bytes at which all memory allocations should fail if the
total allocated memory should increase beyond this.  This can be used to
stress-test software to see how it behaves in low memory conditions.  The
internal memory used by the library itself will not be counted as part of the
total heap size, but on some systems there may be a small amount of memory
required to initialise the library itself.  Note that this setting will be
ignored if its value is zero.  Default value: <code>LIMIT=0</code>.

<br><dt><code>LIST</code>
<dd>Specifies that a context listing should be shown for any relevant source files
that are associated with any warnings or errors when they occur.  Only
diagnostics which occur at source lines in the program will be affected and only
then if they contain source-level information.  This option is currently only
available on UNIX platforms as it makes use of the <code>mpedit</code> command.  It
also overrides the behaviour of the <code>EDIT</code> option.

<br><dt><code>LOGALL</code>
<dd>Equivalent to the <code>LOGALLOCS</code>, <code>LOGREALLOCS</code>, <code>LOGFREES</code>
and <code>LOGMEMORY</code> options specified together.

<br><dt><code>LOGALLOCS</code>
<dd>Specifies that all memory allocations are to be logged and sent to the log file. 
Note that any memory allocations made internally by the library will not be
logged.

<br><dt><code>LOGFILE</code>=&lt;<var>string</var>&gt;
<dd>Specifies an alternative file in which to place all diagnostics from the mpatrol
library.  If the <code>LOGDIR</code> environment variable is set and the specified file
does not contain a path component in its filename then the log file will be
located in the directory specified in <code>LOGDIR</code>.  A filename of <code>stderr</code>
will send all diagnostics to the <code>stderr</code> file stream and a filename of
<code>stdout</code> will do the equivalent with the <code>stdout</code> file stream.  Note
that if a problem occurs while opening the log file or if any diagnostics
require to be displayed before the log file has had a chance to be opened then
they will be sent to the <code>stderr</code> file stream.  Default value:
<code>LOGFILE=mpatrol.log</code> or <code>LOGFILE=%n.%p.log</code> if the <code>LOGDIR</code>
environment variable is set.

<br><dt><code>LOGFREES</code>
<dd>Specifies that all memory deallocations are to be logged and sent to the log
file.  Note that any memory deallocations made internally by the library will
not be logged.

<br><dt><code>LOGMEMORY</code>
<dd>Specifies that all memory operations are to be logged and sent to the log file. 
These operations will be made by calls to functions such as <code>memset()</code> and
<code>memcpy()</code>.  Note that any memory operations made internally by the library
will not be logged.

<br><dt><code>LOGREALLOCS</code>
<dd>Specifies that all memory reallocations are to be logged and sent to the log
file.  Note that any memory reallocations made internally by the library will
not be logged.

<br><dt><code>MEDIUMBOUND</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the limit in bytes up to which memory allocations should be classified
as medium allocations for profiling purposes.  This limit must be greater than
the small bound but less than the large bound.  Default value:
<code>MEDIUMBOUND=256</code>.

<br><dt><code>NOFREE</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies that a number of recently-freed memory allocations should be prevented
from being returned to the free memory pool.  Such freed memory allocations will
then be flagged as freed and can be used by the library to provide better
diagnostics.  However, if the size of the freed queue is specified as zero then
no system memory will ever be reused by the mpatrol library, which can quickly
lead to a shortage of available system memory for a process.  Note that this
option will always force a memory reallocation to return a pointer to
newly-allocated memory, but the <code>expand()</code> function will never be affected
by this option.

<br><dt><code>NOPROTECT</code>
<dd>Specifies that the mpatrol library's internal data structures should not be made
read-only after every memory allocation reallocation or deallocation.  This may
significantly speed up execution but this will be at the expense of less safety
if the program accidentally overwrites some of the library's internal data
structures.  Note that this option has no effect on systems that do not support
memory protection.

<br><dt><code>OFLOWBYTE</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies an 8-bit byte pattern with which to fill the overflow buffers of all
memory allocations.  This is used internally to ensure that nothing has been
written beyond the beginning or the end of a block of allocated memory.  Note
that this setting will only have an effect if the <code>OFLOWSIZE</code> option is
in use.  Default value: <code>OFLOWBYTE=0xAA</code>.

<br><dt><code>OFLOWSIZE</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the size in bytes to use for all overflow buffers, which must be a
power of two (and will be rounded up to the nearest power of two if it is not). 
This is used internally to ensure that nothing has been written beyond the
beginning or the end of a block of allocated memory.  Note that this setting
specifies the size for only one of the overflow buffers given to each memory
allocation; the other overflow buffer will have an identical size.  No overflow
buffers will be used if this setting is zero.  Default value:
<code>OFLOWSIZE=0</code>.

<br><dt><code>OFLOWWATCH</code>
<dd>Specifies that watch point areas should be used for overflow buffers rather than
filling with the overflow byte.  This can significantly reduce the speed of
program execution.  Note that this option has no effect on systems that do not
support watch point areas.

<br><dt><code>PAGEALLOC</code>=&lt;<code>LOWER</code>|<code>UPPER</code>&gt;
<dd>Specifies that each individual memory allocation should occupy at least one
page of virtual memory and should be placed at the lowest or highest point
within these pages.  This allows the library to place an overflow buffer of one
page on either side of every memory allocation and write-protect these pages as
well as all free and freed memory.  Note that this option has no effect on
systems that do not support memory protection, and is disabled by default on
other systems as it can slow down the speed of program execution.

<br><dt><code>PRESERVE</code>
<dd>Specifies that any reallocated or freed memory allocations should preserve their
original contents.  This option must be used with the <code>NOFREE</code> option and
has no effect otherwise.

<br><dt><code>PROF</code>
<dd>Specifies that all memory allocations and deallocations are to be profiled and
sent to the profiling output file.  Memory reallocations are treated as a
memory deallocation immediately followed by a memory allocation.

<br><dt><code>PROFFILE</code>=&lt;<var>string</var>&gt;
<dd>Specifies an alternative file in which to place all memory allocation profiling
information from the mpatrol library.  If the <code>PROFDIR</code> environment variable
is set and the specified file does not contain a path component in its filename
then the profiling output file will be located in the directory specified in
<code>PROFDIR</code>.  A filename of <code>stderr</code> will send this information to the
<code>stderr</code> file stream and a filename of <code>stdout</code> will do the equivalent
with the <code>stdout</code> file stream.  Note that if a problem occurs while opening
the profiling output file then the profiling information will not be output. 
Default value: <code>PROFFILE=mpatrol.out</code> or <code>PROFFILE=%n.%p.out</code> if
the <code>PROFDIR</code> environment variable is set.

<br><dt><code>PROGFILE</code>=&lt;<var>string</var>&gt;
<dd>Specifies an alternative filename with which to locate the executable file
containing the program's symbols.  On most systems, the library will
automatically be able to determine this filename, but on a few systems this
option may have to be used before any or all symbols can be read.

<br><dt><code>REALLOCSTOP</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies a reallocation index at which to stop the program when a memory
allocation is being reallocated.  If the <code>ALLOCSTOP</code> option is non-zero
then the program will be halted when the allocation matching that allocation
index is reallocated the specified number of times.  Otherwise the program will
be halted the first time any allocation is reallocated the specified number of
times.  Note that this setting will be ignored if its value is zero.  Default
value: <code>REALLOCSTOP=0</code>.

<br><dt><code>SAFESIGNALS</code>
<dd>Instructs the library to save and replace certain signal handlers during the
execution of library code and to restore them afterwards.  This was the default
behaviour in version 1.0 of the mpatrol library and was changed since some
memory-intensive programs became very hard to interrupt using the keyboard,
thus giving the impression that the program or system had hung.

<br><dt><code>SHOWALL</code>
<dd>Equivalent to the <code>SHOWFREE</code>, <code>SHOWFREED</code>, <code>SHOWUNFREED</code>,
<code>SHOWMAP</code> and <code>SHOWSYMBOLS</code> options specified together.

<br><dt><code>SHOWFREE</code>
<dd>Specifies that a summary of all of the free memory blocks should be displayed at
the end of program execution.  This step will not be performed if an abnormal
termination occurs or if there were no free memory blocks.

<br><dt><code>SHOWFREED</code>
<dd>Specifies that a summary of all of the freed memory allocations should be
displayed at the end of program execution.  This option must be used in
conjunction with the <code>NOFREE</code> option and this step will not be performed
if an abnormal termination occurs or if there were no freed allocations.

<br><dt><code>SHOWMAP</code>
<dd>Specifies that a memory map of the entire heap should be displayed at the end of
program execution.  This step will not be performed if an abnormal termination
occurs or if the heap is empty.

<br><dt><code>SHOWSYMBOLS</code>
<dd>Specifies that a summary of all of the function symbols read from the program's
executable file should be displayed at the end of program execution.  This step
will not be performed if an abnormal termination occurs or if no symbols could
be read from the executable file.

<br><dt><code>SHOWUNFREED</code>
<dd>Specifies that a summary of all of the unfreed memory allocations should be
displayed at the end of program execution.  This step will not be performed if
an abnormal termination occurs or if there are no unfreed allocations.

<br><dt><code>SMALLBOUND</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the limit in bytes up to which memory allocations should be classified
as small allocations for profiling purposes.  This limit must be greater than
zero but less than the medium and large bounds.  Default value:
<code>SMALLBOUND=32</code>.

<br><dt><code>TRACE</code>
<dd>Specifies that all memory allocations and deallocations are to be traced and
sent to the tracing output file.  Memory reallocations are treated as a memory
deallocation immediately followed by a memory allocation.

<br><dt><code>TRACEFILE</code>=&lt;<var>string</var>&gt;
<dd>Specifies an alternative file in which to place all memory allocation tracing
information from the mpatrol library.  If the <code>TRACEDIR</code> environment
variable is set and the specified file does not contain a path component in its
filename then the tracing output file will be located in the directory specified
in <code>TRACEDIR</code>.  A filename of <code>stderr</code> will send this information to
the <code>stderr</code> file stream and a filename of <code>stdout</code> will do the
equivalent with the <code>stdout</code> file stream.  Note that if a problem occurs
while opening the tracing output file then the tracing information will not be
output.  Default value: <code>TRACEFILE=mpatrol.trace</code> or
<code>TRACEFILE=%n.%p.trace</code> if the <code>TRACEDIR</code> environment variable is
set.

<br><dt><code>UNFREEDABORT</code>=&lt;<var>unsigned-integer</var>&gt;
<dd>Specifies the minimum number of unfreed allocations at which to abort the
program just before program termination.  A summary of all the allocations will
be displayed on the standard error file stream before aborting.  This option may
be handy for use in batch tests as it can force tests to fail if they do not
free up a minimum number of memory allocations.  Note that this setting will be
ignored if its value is zero.  Default value: <code>UNFREEDABORT=0</code>.

<br><dt><code>USEDEBUG</code>
<dd>Specifies that any debugging information in the executable file should be used
to obtain additional source-level information.  This option will only have an
effect if the executable file contains a compiler-generated line number table
and will be ignored if the mpatrol library was built to support an object file
access library that cannot read line tables from object files.  Note that this
option will slow down program execution, use up more system memory and may leave
unaccounted unfreed memory allocations at program termination.

<br><dt><code>USEMMAP</code>
<dd>Specifies that the library should use <code>mmap()</code> instead of <code>sbrk()</code> to
allocate system memory on UNIX platforms.  This option should be used if there
are problems when using the mpatrol library in combination with another malloc
library which uses <code>sbrk()</code> to allocate its memory.  It is ignored on
systems that do not support the <code>mmap()</code> system call.  Note that some UNIX
systems require this option in order for the mpatrol library to be able to
perform memory protection with the <code>mprotect()</code> system call. 
</dl>

<p><hr>
Node:<a name="Options">Options</a>,
Next:<a rel=next href="#Diagnostic%20messages">Diagnostic messages</a>,
Previous:<a rel=previous href="#Environment">Environment</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix C Options</h1>

<p>A utility program called <code>mpatrol</code> is provided to run commands that have
been linked with the mpatrol library.

<pre>mpatrol [options] &lt;command&gt; [arguments]
</pre>

<p>The <code>mpatrol</code> command is used to set various mpatrol library
<var>options</var> when running <var>command</var> with its <var>arguments</var>.  In most
cases, <var>command</var> must have been linked with the mpatrol library, unless the
<code>--dynamic</code> option is used in which case <var>command</var> need only have
been dynamically linked.

<p>All mpatrol library diagnostics are sent to the file <code>mpatrol.%n.log</code> in
the current directory by default (where <code>%n</code> is the current process id) but
this can be changed using the <code>--log-file</code> option.  Similarly, the
default profiling output filename is <code>mpatrol.%n.out</code> and the default
tracing output filename is <code>mpatrol.%n.trace</code>.

<p>Alternatively, the log file, profiling output file and tracing output file names
can contain <code>%p</code>, which will be replaced with the name of the program being
executed without the directory components.  If the executable filename could not
be determined or was not set then it will be replaced with <code>mpatrol</code>.  A
similar replacement character sequence is <code>%f</code>, which will be replaced by
the pathname of the program being executed, with all path separation characters
replaced by underscores.

<p>The current date can be entered into such filenames through the use of the
<code>%d</code> character sequence, which will be replaced with the date in the form
<code>YYYYMMDD</code>.  The current time can be added with <code>%t</code>, which will be
replaced with the time in the form <code>HHMMSS</code>.  If the date or time could not
be determined, these will be replaced with <code>today</code> and <code>now</code>
respectively.

<p>All of the following options (except <code>--dynamic</code>, <code>--help</code>,
<code>--show-env</code>, <code>--threads</code> and <code>--version</code>) correspond to
their listed mpatrol library option (see <a href="#Environment">Environment</a>).  Note that some of
these options have a one character equivalent option that can be used for
brevity.  The list of one character options can be viewed with the
<code>--help</code> option or viewed in the UNIX manual pages.  Such options are
parsed on the command line in a similar way to the UNIX function
<code>getopt()</code>.

<dl>
<dt><code>--alloc-byte</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>ALLOCBYTE</code>]  Specifies an 8-bit byte pattern with which to prefill
newly-allocated memory.

<br><dt><code>--alloc-stop</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>ALLOCSTOP</code>]  Specifies an allocation index at which to stop the program
when it is being allocated.

<br><dt><code>--allow-oflow</code>
<dd>[<code>ALLOWOFLOW</code>]  Specifies that a warning rather than an error should be
produced if any memory operation function overflows the boundaries of a memory
allocation, and that the operation should still be performed.

<br><dt><code>--auto-save</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>AUTOSAVE</code>]  Specifies the frequency at which to periodically write
the profiling data to the profiling output file.

<br><dt><code>--check</code> &lt;<var>unsigned-range</var>&gt;
<dd>[<code>CHECK</code>]  Specifies a range of allocation indices at which to check the
integrity of free memory and overflow buffers.

<br><dt><code>--check-all</code>
<dd>[<code>CHECKALL</code>]  Equivalent to the <code>--check-allocs</code>,
<code>--check-reallocs</code>, <code>--check-frees</code> and <code>--check-memory</code>
options specified together.

<br><dt><code>--check-allocs</code>
<dd>[<code>CHECKALLOCS</code>]  Checks that no attempt is made to allocate a block of
memory of size zero.

<br><dt><code>--check-frees</code>
<dd>[<code>CHECKFREES</code>]  Checks that no attempt is made to deallocate a
<code>NULL</code> pointer.

<br><dt><code>--check-memory</code>
<dd>[<code>CHECKMEMORY</code>]  Checks that no attempt is made to perform a zero-length
memory operation on a <code>NULL</code> pointer.

<br><dt><code>--check-reallocs</code>
<dd>[<code>CHECKREALLOCS</code>]  Checks that no attempt is made to reallocate a
<code>NULL</code> pointer or resize an existing block of memory to size zero.

<br><dt><code>--def-align</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>DEFALIGN</code>]  Specifies the default alignment for general-purpose memory
allocations, which must be a power of two.

<br><dt><code>--dynamic</code>
<dd>Specifies that programs which were not linked with the mpatrol library should
also be traced, but only if they were dynamically linked.  This option will
only work if the system dynamic linker has the ability to preload a set of
user-specified shared libraries via a special environment variable.

<br><dt><code>--edit</code>
<dd>[<code>EDIT</code>]  Specifies that a text editor should be invoked to edit any
relevant source files that are associated with any warnings or errors when they
occur.

<br><dt><code>--fail-freq</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>FAILFREQ</code>]  Specifies the frequency at which all memory allocations
will randomly fail.

<br><dt><code>--fail-seed</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>FAILSEED</code>]  Specifies the random number seed which will be used when
determining which memory allocations will randomly fail.

<br><dt><code>--free-byte</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>FREEBYTE</code>]  Specifies an 8-bit byte pattern with which to prefill
newly-freed memory.

<br><dt><code>--free-stop</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>FREESTOP</code>]  Specifies an allocation index at which to stop the program
when it is being freed.

<br><dt><code>--help</code>
<dd>Displays a quick-reference option summary.

<br><dt><code>--large-bound</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>LARGEBOUND</code>]  Specifies the limit in bytes up to which memory
allocations should be classified as large allocations for profiling purposes.

<br><dt><code>--limit</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>LIMIT</code>]  Specifies the limit in bytes at which all memory allocations
should fail if the total allocated memory should increase beyond this.

<br><dt><code>--list</code>
<dd>[<code>LIST</code>]  Specifies that a context listing should be shown for any
relevant source files that are associated with any warnings or errors when they
occur.

<br><dt><code>--log-all</code>
<dd>[<code>LOGALL</code>]  Equivalent to the <code>--log-allocs</code>,
<code>--log-reallocs</code>, <code>--log-frees</code> and <code>--log-memory</code> options
specified together.

<br><dt><code>--log-allocs</code>
<dd>[<code>LOGALLOCS</code>]  Specifies that all memory allocations are to be logged and
sent to the log file.

<br><dt><code>--log-file</code> &lt;<var>string</var>&gt;
<dd>[<code>LOGFILE</code>]  Specifies an alternative file in which to place all
diagnostics from the mpatrol library.

<br><dt><code>--log-frees</code>
<dd>[<code>LOGFREES</code>]  Specifies that all memory deallocations are to be logged
and sent to the log file.

<br><dt><code>--log-memory</code>
<dd>[<code>LOGMEMORY</code>]  Specifies that all memory operations are to be logged and
sent to the log file.

<br><dt><code>--log-reallocs</code>
<dd>[<code>LOGREALLOCS</code>]  Specifies that all memory reallocations are to be logged
and sent to the log file.

<br><dt><code>--medium-bound</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>MEDIUMBOUND</code>]  Specifies the limit in bytes up to which memory
allocations should be classified as medium allocations for profiling purposes.

<br><dt><code>--no-free</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>NOFREE</code>]  Specifies that a number of recently-freed memory allocations
should be prevented from being returned to the free memory pool.

<br><dt><code>--no-protect</code>
<dd>[<code>NOPROTECT</code>]  Specifies that the mpatrol library's internal data
structures should not be made read-only after every memory allocation,
reallocation or deallocation.

<br><dt><code>--oflow-byte</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>OFLOWBYTE</code>]  Specifies an 8-bit byte pattern with which to fill the
overflow buffers of all memory allocations.

<br><dt><code>--oflow-size</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>OFLOWSIZE</code>]  Specifies the size in bytes to use for all overflow
buffers, which must be a power of two.

<br><dt><code>--oflow-watch</code>
<dd>[<code>OFLOWWATCH</code>]  Specifies that watch point areas should be used for
overflow buffers rather than filling with the overflow byte.

<br><dt><code>--page-alloc-lower</code>
<dd>[<code>PAGEALLOC=LOWER</code>]  Specifies that each individual memory allocation
should occupy at least one page of virtual memory and should be placed at the
lowest point within these pages.

<br><dt><code>--page-alloc-upper</code>
<dd>[<code>PAGEALLOC=UPPER</code>]  Specifies that each individual memory allocation
should occupy at least one page of virtual memory and should be placed at the
highest point within these pages.

<br><dt><code>--preserve</code>
<dd>[<code>PRESERVE</code>]  Specifies that any reallocated or freed memory allocations
should preserve their original contents.

<br><dt><code>--prof</code>
<dd>[<code>PROF</code>]  Specifies that all memory allocations are to be profiled and
sent to the profiling output file.

<br><dt><code>--prof-file</code> &lt;<var>string</var>&gt;
<dd>[<code>PROFFILE</code>]  Specifies an alternative file in which to place all
memory allocation profiling information from the mpatrol library.

<br><dt><code>--prog-file</code> &lt;<var>string</var>&gt;
<dd>[<code>PROGFILE</code>]  Specifies an alternative filename with which to locate the
executable file containing the program's symbols.

<br><dt><code>--realloc-stop</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>REALLOCSTOP</code>]  Specifies an allocation index at which to stop the
program when a memory allocation is being reallocated.

<br><dt><code>--safe-signals</code>
<dd>[<code>SAFESIGNALS</code>]  Instructs the library to save and replace certain signal
handlers during the execution of library code and to restore them afterwards.

<br><dt><code>--show-all</code>
<dd>[<code>SHOWALL</code>]  Equivalent to the <code>--show-free</code>,
<code>--show-freed</code>, <code>--show-unfreed</code>, <code>--show-map</code> and
<code>--show-symbols</code> options specified together.

<br><dt><code>--show-env</code>
<dd>Displays the contents of the <code>MPATROL_OPTIONS</code> environment variable.  This
will be shown after all of the other command line options have been processed
and will prevent the specified command from being run.

<br><dt><code>--show-free</code>
<dd>[<code>SHOWFREE</code>]  Specifies that a summary of all of the free memory blocks
should be displayed at the end of program execution.

<br><dt><code>--show-freed</code>
<dd>[<code>SHOWFREED</code>]  Specifies that a summary of all of the freed memory
allocations should be displayed at the end of program execution.

<br><dt><code>--show-map</code>
<dd>[<code>SHOWMAP</code>]  Specifies that a memory map of the entire heap should be
displayed at the end of program execution.

<br><dt><code>--show-symbols</code>
<dd>[<code>SHOWSYMBOLS</code>]  Specifies that a summary of all of the function symbols
read from the program's executable file should be displayed at the end of
program execution.

<br><dt><code>--show-unfreed</code>
<dd>[<code>SHOWUNFREED</code>]  Specifies that a summary of all of the unfreed memory
allocations should be displayed at the end of program execution.

<br><dt><code>--small-bound</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>SMALLBOUND</code>]  Specifies the limit in bytes up to which memory
allocations should be classified as small allocations for profiling purposes.

<br><dt><code>--threads</code>
<dd>Specifies that the program to be run is multithreaded if the <code>--dynamic</code>
option is used.  This option is required if the multithreaded version of the
mpatrol library should be preloaded instead of the normal version.

<br><dt><code>--trace</code>
<dd>[<code>TRACE</code>]  Specifies that all memory allocations are to be traced and
sent to the tracing output file.

<br><dt><code>--trace-file</code> &lt;<var>string</var>&gt;
<dd>[<code>TRACEFILE</code>]  Specifies an alternative file in which to place all
memory allocation tracing information from the mpatrol library.

<br><dt><code>--unfreed-abort</code> &lt;<var>unsigned-integer</var>&gt;
<dd>[<code>UNFREEDABORT</code>]  Specifies the minimum number of unfreed allocations at
which to abort the program just before program termination.

<br><dt><code>--use-debug</code>
<dd>[<code>USEDEBUG</code>]  Specifies that any debugging information in the executable
file should be used to obtain additional source-level information.

<br><dt><code>--use-mmap</code>
<dd>[<code>USEMMAP</code>]  Specifies that the library should use <code>mmap()</code> instead
of <code>sbrk()</code> to allocate system memory.

<br><dt><code>--version</code>
<dd>Displays the version number of the <code>mpatrol</code> command. 
</dl>

<p><hr>
Node:<a name="Diagnostic%20messages">Diagnostic messages</a>,
Next:<a rel=next href="#Library%20performance">Library performance</a>,
Previous:<a rel=previous href="#Options">Options</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix D Diagnostic messages</h1>

<p>The following table lists the warnings and errors that are likely to appear in
the mpatrol log file when problems with dynamic memory allocations and memory
operations occur.  Other types of warnings and errors may also appear in the log
file, but they are likely to be associated with parsing options and reading
symbols from executable files and so should be self-explanatory.

<p>Note that on UNIX platforms, if the diagnostic message is caused by a line in
the program source then the <code>EDIT</code> and <code>LIST</code> options can be used
to illustrate more clearly where in the source code the warning or error
occurred.

<ul>
<li><code>ALLOVF</code>
<dl>
<dt>Message
<dd><code>allocation %1 has a corrupted overflow buffer at %2</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the memory allocation that has a corrupted overflow buffer. 
<br><dt><code>%2</code>
<dd>The pointer to the first byte of corruption in the memory allocation's overflow
buffer. 
<br><dt>Cause
<dd>Something has corrupted the overflow buffer of a memory allocation and this has
been caught at the next invocation of an mpatrol function when the
<code>OFLOWSIZE</code> or <code>PAGEALLOC</code> options were used.  This particular
error message will not occur if the <code>OFLOWWATCH</code> option was used since
all overflow buffers will be write protected. 
<br><dt>Additional
<dd>The library summary, the contents of the overflow buffer and information about
the original memory allocation. 
<br><dt>Result
<dd>Execution terminates. 
</dl>

<li><code>ALLZER</code>
<dl>
<dt>Message
<dd><code>attempt to create an allocation of size 0</code>
<br><dt>Type
<dd>Warning
<br><dt>Cause
<dd>A function was called to allocate memory with a size of <code>0</code> when either of
the <code>CHECKALL</code> or <code>CHECKALLOCS</code> options were used.  This warning
will not occur by default as the ANSI C/C++ standards allow this behaviour, and
it is really only a portability issue. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>The size is increased to 1 byte and execution continues. 
</dl>

<li><code>BADALN</code>
<dl>
<dt>Message
<dd><code>alignment %1 is not a power of two</code>
<br><dt>Type
<dd>Warning
<br><dt><code>%1</code>
<dd>The alignment in bytes. 
<br><dt>Cause
<dd>The <code>memalign()</code> function was called to allocate memory with an alignment
which was not a power of two when either of the <code>CHECKALL</code> or
<code>CHECKALLOCS</code> options were used. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>The alignment is rounded up to the nearest power of two and execution continues. 
</dl>

<li><code>FRDCOR</code>
<dl>
<dt>Message
<dd><code>freed allocation %1 has memory corruption at %2</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the freed memory allocation that has been corrupted. 
<br><dt><code>%2</code>
<dd>The pointer to the first byte of corruption in the freed memory allocation. 
<br><dt>Cause
<dd>Something has corrupted the contents of a previously freed memory allocation and
this has been caught at the next invocation of an mpatrol function when the
<code>NOFREE</code> option was used.  This particular error message will not occur
if the <code>PAGEALLOC</code> option was used since all freed memory allocations
will be write protected and will also not occur if the <code>PRESERVE</code> option
was used since the free byte cannot be used to verify the freed allocation's
contents. 
<br><dt>Additional
<dd>The library summary, the contents of the freed memory block and information
about the original memory allocation. 
<br><dt>Result
<dd>Execution terminates. 
</dl>

<li><code>FRDOPN</code>
<dl>
<dt>Message
<dd><code>attempt to perform operation on freed memory</code>
<br><dt>Type
<dd>Error
<br><dt>Cause
<dd>A memory operation function was called to operate on a previously freed memory
allocation when the <code>NOFREE</code> option was used. 
<br><dt>Additional
<dd>Information about the original memory allocation. 
<br><dt>Result
<dd>The memory operation fails and execution continues. 
</dl>

<li><code>FRDOVF</code>
<dl>
<dt>Message
<dd><code>freed allocation %1 has a corrupted overflow buffer at %2</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the freed memory allocation that has a corrupted overflow buffer. 
<br><dt><code>%2</code>
<dd>The pointer to the first byte of corruption in the freed memory allocation's
overflow buffer. 
<br><dt>Cause
<dd>Something has corrupted the overflow buffer of a previously freed memory
allocation and this has been caught at the next invocation of an mpatrol
function when the <code>NOFREE</code> option was used in conjunction with the
<code>OFLOWSIZE</code> or <code>PAGEALLOC</code> options.  This particular error message
will not occur if the <code>OFLOWWATCH</code> option was used since all overflow
buffers will be write protected. 
<br><dt>Additional
<dd>The library summary, the contents of the overflow buffer and information about
the original memory allocation. 
<br><dt>Result
<dd>Execution terminates. 
</dl>

<li><code>FRECOR</code>
<dl>
<dt>Message
<dd><code>free memory corruption at %1</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the first byte of corruption in free memory. 
<br><dt>Cause
<dd>Something has corrupted the contents of the free memory pool and this has been
caught at the next invocation of an mpatrol function.  This particular error
message will not occur if the <code>PAGEALLOC</code> option was used since all free
memory will be write protected. 
<br><dt>Additional
<dd>The library summary and the contents of the free memory block. 
<br><dt>Result
<dd>Execution terminates. 
</dl>

<li><code>FRENUL</code>
<dl>
<dt>Message
<dd><code>attempt to free a NULL pointer</code>
<br><dt>Type
<dd>Warning
<br><dt>Cause
<dd>A function was called to free an existing memory allocation with a pointer of
<code>NULL</code> when either of the <code>CHECKALL</code> or <code>CHECKFREES</code> options
were used.  This warning will not occur by default as the ANSI C/C++ standards
allow this behaviour, and it is really only a portability issue. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>No memory allocation will be freed and execution continues. 
</dl>

<li><code>FREOPN</code>
<dl>
<dt>Message
<dd><code>attempt to perform operation on free memory</code>
<br><dt>Type
<dd>Error
<br><dt>Cause
<dd>A memory operation function was called to operate on free memory. 
<br><dt>Additional
<dd>No additional information. 
<br><dt>Result
<dd>The memory operation fails and execution continues. 
</dl>

<li><code>ILLMEM</code>
<dl>
<dt>Message
<dd><code>illegal memory access at address %1</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The address at which the illegal memory access occurred. 
<br><dt>Cause
<dd>An attempt was made to read from or write to an illegal address on systems which
have virtual memory.  This address may or may not exist in the heap, or it may
be a perfectly valid address that was misaligned and caused a bus error.  In
either case, the mpatrol library will attempt to associate the address with an
existing memory allocation.  This error may also appear instead of memory
corruption errors if the <code>PAGEALLOC</code> or <code>OFLOWWATCH</code> options were
used. 
<br><dt>Additional
<dd>The library summary, information about the original memory allocation (if
possible) and the call stack of where the error occurred. 
<br><dt>Result
<dd>Execution terminates. 
</dl>

<li><code>INCOMP</code>
<dl>
<dt>Message
<dd><code>%1 was allocated with %2</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the memory allocation that is to be resized or freed. 
<br><dt><code>%2</code>
<dd>The name of the function which originally allocated the memory allocation. 
<br><dt>Cause
<dd>A function was called to resize or free a memory allocation that was allocated
with a function that is incompatible with the current request.  For example,
a memory allocation which was allocated with <code>operator new</code> being resized
with <code>realloc()</code>. 
<br><dt>Additional
<dd>The log file entry and information about the original memory allocation. 
<br><dt>Result
<dd>The reallocation or deallocation fails and execution continues. 
</dl>

<li><code>MAXALN</code>
<dl>
<dt>Message
<dd><code>alignment %1 is greater than the system page size</code>
<br><dt>Type
<dd>Warning
<br><dt><code>%1</code>
<dd>The alignment in bytes. 
<br><dt>Cause
<dd>The <code>memalign()</code> function was called to allocate memory with an alignment
which was greater than the system page size when either of the <code>CHECKALL</code>
or <code>CHECKALLOCS</code> options were used.  The mpatrol library cannot currently
align memory allocations to a byte alignment over this limit, but then neither
can most other implementations. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>The alignment is set to the system page size and execution continues. 
</dl>

<li><code>MISMAT</code>
<dl>
<dt>Message
<dd><code>%1 does not match allocation of %2</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the memory allocation that is to be resized or freed. 
<br><dt><code>%2</code>
<dd>The pointer to the memory allocation that the mpatrol library knows about. 
<br><dt>Cause
<dd>A function was called to resize or free a memory allocation that begins at a
different address from that supplied. 
<br><dt>Additional
<dd>The log file entry and information about the original memory allocation. 
<br><dt>Result
<dd>The reallocation or deallocation fails and execution continues. 
</dl>

<li><code>NOTALL</code>
<dl>
<dt>Message
<dd><code>%1 has not been allocated</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the memory allocation that is to be resized or freed. 
<br><dt>Cause
<dd>A function was called to resize or free a memory allocation that has not been
allocated.  It may be that the memory allocation has just been freed, in which
case the <code>NOFREE</code> option should be used to provide a better diagnostic
message. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>The reallocation or deallocation fails and execution continues. 
</dl>

<li><code>NULOPN</code>
<dl>
<dt>Message
<dd><code>attempt to perform operation on a NULL pointer</code>
<br><dt>Type
<dd>Error
<br><dt>Cause
<dd>A memory operation function was called to operate on a <code>NULL</code> pointer.  If
the length of the operation was zero then this error will only occur when the
<code>CHECKALL</code> or <code>CHECKMEMORY</code> options were used as the ANSI C/C++
standards allow this behaviour, and it is really only a portability issue. 
<br><dt>Additional
<dd>No additional information. 
<br><dt>Result
<dd>The memory operation fails and execution continues. 
</dl>

<li><code>OUTMEM</code>
<dl>
<dt>Message
<dd><code>out of memory</code>
<br><dt>Type
<dd>Error
<br><dt>Cause
<dd>The <code>operator new</code> or <code>operator new[]</code> C++ operator was called to
allocate memory, but no more memory was available to allocate and no low-memory
handler was installed. 
<br><dt>Additional
<dd>The library summary. 
<br><dt>Result
<dd>Execution terminates. 
</dl>

<li><code>PRVFRD</code>
<dl>
<dt>Message
<dd><code>%1 was freed with %2</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The pointer to the memory allocation that is to be resized or freed. 
<br><dt><code>%2</code>
<dd>The name of the function which originally freed the memory allocation. 
<br><dt>Cause
<dd>A function was called to resize or free a memory allocation that had previously
been freed when the <code>NOFREE</code> option was used. 
<br><dt>Additional
<dd>The log file entry and information about the original memory allocation. 
<br><dt>Result
<dd>The reallocation or deallocation fails and execution continues. 
</dl>

<li><code>RNGOVF</code>
<dl>
<dt>Message
<dd><code>range [%1,%2] overflows [%3,%4]</code>
<br><dt>Type
<dd>Warning/Error
<br><dt><code>%1</code>
<dd>The start address of the memory region. 
<br><dt><code>%2</code>
<dd>The end address of the memory region. 
<br><dt><code>%3</code>
<dd>The start address of the memory allocation. 
<br><dt><code>%4</code>
<dd>The end address of the memory allocation. 
<br><dt>Cause
<dd>A memory operation function was called to operate on a range of memory which
overflowed the boundaries of a memory allocation. 
<br><dt>Additional
<dd>Information about the original memory allocation. 
<br><dt>Result
<dd>The operation will be only be performed (and will be changed from an error to a
warning) if the <code>ALLOWOFLOW</code> option was used, but execution will
continue regardless. 
</dl>

<li><code>RNGOVL</code>
<dl>
<dt>Message
<dd><code>range [%1,%2] overlaps [%3,%4]</code>
<br><dt>Type
<dd>Warning
<br><dt><code>%1</code>
<dd>The start address of the source memory region. 
<br><dt><code>%2</code>
<dd>The end address of the source memory region. 
<br><dt><code>%3</code>
<dd>The start address of the destination memory region. 
<br><dt><code>%4</code>
<dd>The end address of the destination memory region. 
<br><dt>Cause
<dd>The <code>memcpy()</code> or <code>memccpy()</code> function was called to copy overlapping
memory regions.  This is an error on many systems and the ANSI C/C++ standards
specify that <code>memmove()</code> should be used instead. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>The copy operation will still be performed but it will deal correctly with
overlapping memory regions. 
</dl>

<li><code>RSZNUL</code>
<dl>
<dt>Message
<dd><code>attempt to resize a NULL pointer</code>
<br><dt>Type
<dd>Warning
<br><dt>Cause
<dd>A function was called to resize an existing memory allocation with a pointer of
<code>NULL</code> when either of the <code>CHECKALL</code> or <code>CHECKREALLOCS</code>
options were used.  This warning will not occur by default as the ANSI C/C++
standards allow this behaviour, and it is really only a portability issue. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>A new memory allocation is returned and execution continues. 
</dl>

<li><code>RSZZER</code>
<dl>
<dt>Message
<dd><code>attempt to resize an allocation to size 0</code>
<br><dt>Type
<dd>Warning
<br><dt>Cause
<dd>A function was called to resize an existing memory allocation to a size of
<code>0</code> when either of the <code>CHECKALL</code> or <code>CHECKREALLOCS</code> options
were used.  This warning will not occur by default as the ANSI C/C++ standards
allow this behaviour, and it is really only a portability issue. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>The existing memory allocation will be freed and execution continues. 
</dl>

<li><code>STROVF</code>
<dl>
<dt>Message
<dd><code>string %1 overflows [%2,%3]</code>
<br><dt>Type
<dd>Error
<br><dt><code>%1</code>
<dd>The start address of the string. 
<br><dt><code>%2</code>
<dd>The start address of the memory allocation. 
<br><dt><code>%3</code>
<dd>The end address of the memory allocation. 
<br><dt>Cause
<dd>A string function was called to operate on a string which overflowed the
boundaries of a memory allocation. 
<br><dt>Additional
<dd>Information about the original memory allocation. 
<br><dt>Result
<dd>The operation will not be performed and execution continues. 
</dl>

<li><code>ZERALN</code>
<dl>
<dt>Message
<dd><code>alignment 0 is invalid</code>
<br><dt>Type
<dd>Warning
<br><dt>Cause
<dd>The <code>memalign()</code> function was called to allocate memory with an alignment
of <code>0</code> when either of the <code>CHECKALL</code> or <code>CHECKALLOCS</code> options
were used. 
<br><dt>Additional
<dd>The log file entry. 
<br><dt>Result
<dd>The alignment is set to the system page size and execution continues. 
</dl>
</ul>

<p><hr>
Node:<a name="Library%20performance">Library performance</a>,
Next:<a rel=next href="#File%20formats">File formats</a>,
Previous:<a rel=previous href="#Diagnostic%20messages">Diagnostic messages</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix E Library performance</h1>

<p>The following times were obtained on a Sun Ultra 5 with an UltraSPARC IIi
processor running at 333MHz and running Solaris 7.  The test performed was the
one in <code>tests/pass/test1.c</code> and all tests were run on a lightly loaded
system, but were run several times to obtain an average result.  Obviously,
these times can only be an approximation, but should serve to illustrate the
effects on performance that each option can have.  All times are given in
seconds, and the second time on each line was obtained with the same options
plus the <code>NOPROTECT</code> option.  Running with the <code>CHECK=0</code> option
would speed things up dramatically, albeit at the expense of less error
checking.

<p>Running with basic options:

<p><table><tr align="left"><td><em>no options</em>
<td>0.618
<td>0.258
<br></tr><tr align="left"><td><code>OFLOWSIZE=2</code>
<td>0.645
<td>0.296
<br></tr><tr align="left"><td><code>OFLOWSIZE=8</code>
<td>0.686
<td>0.327
<br></tr><tr align="left"><td><code>PAGEALLOC=LOWER</code>
<td>7.785
<td>7.372
<br></tr><tr align="left"><td><code>PAGEALLOC=UPPER</code>
<td>7.821
<td>7.469
<br></tr></table>

<p>Running when all freed memory allocations are kept:

<p><table><tr align="left"><td><code>NOFREE=0</code>
<td>0.943
<td>0.506
<br></tr><tr align="left"><td><code>NOFREE=0 OFLOWSIZE=2</code>
<td>1.026
<td>0.579
<br></tr><tr align="left"><td><code>NOFREE=0 OFLOWSIZE=8</code>
<td>1.091
<td>0.645
<br></tr><tr align="left"><td><code>NOFREE=0 PAGEALLOC=LOWER</code>
<td>8.013
<td>7.598
<br></tr><tr align="left"><td><code>NOFREE=0 PAGEALLOC=UPPER</code>
<td>8.026
<td>7.616
<br></tr></table>

<p>Running when all freed memory allocations are kept and their contents are
preserved:

<p><table><tr align="left"><td><code>NOFREE=0 PRESERVE</code>
<td>0.719
<td>0.292
<br></tr><tr align="left"><td><code>NOFREE=0 PRESERVE OFLOWSIZE=2</code>
<td>0.792
<td>0.367
<br></tr><tr align="left"><td><code>NOFREE=0 PRESERVE OFLOWSIZE=8</code>
<td>0.850
<td>0.419
<br></tr><tr align="left"><td><code>NOFREE=0 PRESERVE PAGEALLOC=LOWER</code>
<td>8.043
<td>7.616
<br></tr><tr align="left"><td><code>NOFREE=0 PRESERVE PAGEALLOC=UPPER</code>
<td>8.052
<td>7.631
<br></tr></table>

<p>Running using watch points to check the overflow buffers:

<p><table><tr align="left"><td><code>OFLOWSIZE=2 OFLOWWATCH</code>
<td>Interrupted after half an hour as it still hadn't finished.
<br></tr></table>

<p>Running using the Solaris malloc libraries:

<p><table><tr align="left"><td>Solaris malloc(3c) library
<td>0.033
<br></tr><tr align="left"><td>Solaris malloc(3x) library
<td>0.036
<br></tr><tr align="left"><td>Solaris bsdmalloc(3x) library
<td>0.028
<br></tr><tr align="left"><td>Solaris mapmalloc(3x) library
<td>0.033
<br></tr><tr align="left"><td>Solaris watchmalloc(3x) library
<td>40.845
<br></tr></table>

<p><hr>
Node:<a name="File%20formats">File formats</a>,
Next:<a rel=next href="#Supported%20systems">Supported systems</a>,
Previous:<a rel=previous href="#Library%20performance">Library performance</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix F File formats</h1>

<p>The formats of the profiling and tracing output files that are produced by the
mpatrol library are described here<a rel=footnote href="#fn-43"><sup>43</sup></a>.

<ul>
<li><a href="#Profiling%20file%20format">Profiling file format</a>:        Profiling output file layout. 
<li><a href="#Tracing%20file%20format">Tracing file format</a>:          Tracing output file layout. 
</ul>

<p><hr>
Node:<a name="Profiling%20file%20format">Profiling file format</a>,
Next:<a rel=next href="#Tracing%20file%20format">Tracing file format</a>,
Up:<a rel=up href="#File%20formats">File formats</a>
<br>

<h2>F.1 Profiling file format</h2>

<p>Every mpatrol profiling output file contains the following components.

<ul>
<li>4 bytes containing the characters <code>M</code>, <code>P</code>, <code>T</code> and <code>L</code>.

<li>1 unsigned integer representing the value <code>1</code>.  This is used by
<code>mprof</code> to determine the endianness of the processor that produced the
profiling output file so that it can decide whether to perform byte-swapping on
the input data.

<li>1 unsigned integer containing the version number of the mpatrol library which
produced the profiling output file.

<li>3 unsigned integers containing the small, medium and large allocation bounds.

<li>1 unsigned integer containing the allocation bin size.  If the allocation bin
size is greater than zero then it is followed by the allocation bins, the large
allocation totals, the deallocation bins and the large deallocation totals,
where the bins are arrays of unsigned integers with dimensions of the allocation
bin size and the totals are unsigned integers.

<li>1 unsigned integer containing the number of profiling data structures.  If the
number of profiling data structures is greater than zero then it is followed by
the profiling data structures themselves, which are of the following structure.

<ul>
<li>1 unsigned integer representing the index of this profiling data.

<li>4 unsigned integers representing the small, medium, large and extra large
allocation counts for this profiling data.

<li>4 unsigned integers representing the small, medium, large and extra large
allocation totals for this profiling data.

<li>4 unsigned integers representing the small, medium, large and extra large
deallocation counts for this profiling data.

<li>4 unsigned integers representing the small, medium, large and extra large
deallocation totals for this profiling data. 
</ul>

<li>1 unsigned integer containing the number of call sites.  If the number of call
sites is greater than zero then it is followed by the call sites themselves,
which are of the following structure.

<ul>
<li>1 unsigned integer representing the index of this call site.

<li>1 unsigned integer representing the index of the parent call site.

<li>1 generic pointer representing the code address of this call site.

<li>1 unsigned integer representing the index of an associated symbol.

<li>1 unsigned integer representing the offset of the symbol name.

<li>1 unsigned integer representing the index of any associated profiling data. 
</ul>

<li>1 unsigned integer containing the number of symbol addresses.  If the number
of symbol addresses is greater than zero then it is followed by the symbol
addresses themselves, which are generic pointers.

<li>1 unsigned integer containing the size of the symbol name string table.  This
is followed by the symbol name string table, which is an array of characters
containing the nul-terminated symbol names.

<li>4 bytes containing the characters <code>M</code>, <code>P</code>, <code>T</code> and <code>L</code>. 
</ul>

<p><hr>
Node:<a name="Tracing%20file%20format">Tracing file format</a>,
Previous:<a rel=previous href="#Profiling%20file%20format">Profiling file format</a>,
Up:<a rel=up href="#File%20formats">File formats</a>
<br>

<h2>F.2 Tracing file format</h2>

<p>Every mpatrol tracing output file contains the following components.

<ul>
<li>4 bytes containing the characters <code>M</code>, <code>T</code>, <code>R</code> and <code>C</code>.

<li>1 unsigned integer representing the value <code>1</code>.  This is used by
<code>mptrace</code> to determine the endianness of the processor that produced the
tracing output file so that it can decide whether to perform byte-swapping on
the input data.

<li>1 unsigned integer containing the version number of the mpatrol library which
produced the tracing output file.

<li>One or more of the following event records.

<ul>
<li>If the event is a system heap allocation for use by the mpatrol library's
internal data structures then the event record will begin with the character
<code>I</code> followed by the start address and size in bytes of the heap allocation
encoded as unsigned LEB128 numbers.

<li>If the event is a system heap allocation for use by the program's memory
allocations then the event record will begin with the character <code>H</code>
followed by the start address and size in bytes of the heap allocation encoded
as unsigned LEB128 numbers.

<li>If the event is a memory allocation then the event record will begin with the
character <code>A</code> followed by the allocation index, start address and size in
bytes of the memory allocation encoded as unsigned LEB128 numbers.

<li>If the event is a memory deallocation then the event record will begin with the
character <code>F</code> followed by the allocation index of the memory allocation
encoded as an unsigned LEB128 number. 
</ul>

<li>4 bytes containing the characters <code>M</code>, <code>T</code>, <code>R</code> and <code>C</code>. 
</ul>

<p><hr>
Node:<a name="Supported%20systems">Supported systems</a>,
Next:<a rel=next href="#Notes">Notes</a>,
Previous:<a rel=previous href="#File%20formats">File formats</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix G Supported systems</h1>

<p>Following is a list of systems on which the mpatrol library has been built and
tested.  The system details include the operating system and version, the
processor type, the object file format and the C compiler used to compile the
library and tests.  The details following each system list any features of the
library that are not (or cannot be) supported on that system.

<ul>
<li>AIX 4.1, IBM RS/6000, BFD, <code>cc</code>
<ul>
<li>The thread-safe version of the library does not work. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>There is currently no support for reading symbols from XCOFF shared libraries. 
You should instead link your programs with the following compiler options in
order to perform a static link instead of a dynamic link:
<code>-bnoautoimp</code> <code>-bimport:/lib/syscalls.exp</code>. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>AIX 4.1, IBM RS/6000, XCOFF, <code>cc</code>
<ul>
<li>The thread-safe version of the library does not work. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>There is currently no support for reading symbols from XCOFF shared libraries. 
You should instead link your programs with the following compiler options in
order to perform a static link instead of a dynamic link:
<code>-bnoautoimp</code> <code>-bimport:/lib/syscalls.exp</code>. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>DG/UX 4.11, Intel Pentium Pro, ELF32, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>DG/UX 4.20MU07, Intel Pentium Pro, ELF32, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not work
unless <code>libelf.so</code> is available. 
</ul>

<li>DG/UX 4.11, Motorola 88100, ELF32, <code>gcc</code>
<ul>
<li>The thread-safe version of the library does not work if the mpatrol library is
built as a shared library. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>Call stack traversal only works with unoptimised code. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>DRS/NX 6.2, SPARC V7, ELF32, <code>cc</code>
<ul>
<li>The option <code>-DSYSTEM=SYSTEM_DRSNX</code> must be added to the <code>CFLAGS</code>
section in the <code>Makefile</code> before building the library. 
<li>The thread-safe version of the library does not work.  This is because there
does not appear to be any evidence that this version of the operating system
supports threads. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>DYNIX/ptx 4.5, Intel Pentium Pro, ELF32, <code>cc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not work
unless <code>libelf.so</code> is available. 
</ul>

<li>HP/UX 10.20, HP PA/RISC 9000, BFD, <code>gcc</code>
<ul>
<li>The thread-safe version of the library does not work.  This is because there
does not appear to be any evidence that this version of the operating system
supports threads. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>IRIX 5.3, MIPS R4000, ELF32, <code>cc</code>
<ul>
<li>The thread-safe version of the library does not work.  This is because there
does not appear to be any evidence that this version of the operating system
supports threads. 
<li>This version of the operating system only allows up to 100 user-programmable
software watch points, which means that the <code>OFLOWWATCH</code> option will not
work properly if more than 50 memory allocations exist at one time. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>Stack traversal may be unreliable from signal-handlers. 
</ul>

<li>Red Hat Linux 6.0, Intel Pentium III, BFD, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not work
unless <code>libiberty.so</code> is available. 
</ul>

<li>Red Hat Linux 6.1, Intel Pentium III, BFD, <code>gcc</code>
<ul>
<li>The thread-safe version of the library does not work due to the system threads
library calling <code>malloc()</code> and <code>bzero()</code> recursively. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not work
unless <code>libiberty.so</code> is available. 
</ul>

<li>Red Hat Linux 6.2, Intel Pentium III, BFD, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not work
unless <code>libiberty.so</code> is available. 
</ul>

<li>Red Hat Linux 5.1, Motorola 68040, BFD, <code>gcc</code>
<ul>
<li>The thread-safe version of the library does not work due to the system threads
library calling <code>malloc()</code> and <code>bzero()</code> recursively. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not work
unless <code>libiberty.so</code> is available. 
</ul>

<li>Red Hat Linux 5.1, Motorola 68040, ELF32, <code>gcc</code>
<ul>
<li>The thread-safe version of the library does not work due to the system threads
library calling <code>malloc()</code> and <code>bzero()</code> recursively. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not work
unless <code>libelf.so</code> is available. 
</ul>

<li>LynxOS 3.0.0, Intel Pentium Pro, BFD, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEMMAP</code> option has no effect. 
<li>The <code>LIST</code> option does not work since the <code>--listing</code> option does
not work in the <code>mpedit</code> command. 
<li>There is currently no support for reading symbols from COFF shared libraries. 
You should currently always perform a static link instead of a dynamic link
when linking your program, but that is the default on LynxOS anyway. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
<li>The <code>mpsym</code> command does not work due to the lack of a <code>printf</code>
command on the system. 
<li>The <code>mpedit</code> command does not support the <code>--listing</code> option due
to the lack of an <code>nl</code> command on the system. 
</ul>

<li>LynxOS 3.0.0, Intel Pentium Pro, COFF, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>USEMMAP</code> option has no effect. 
<li>The <code>LIST</code> option does not work since the <code>--listing</code> option does
not work in the <code>mpedit</code> command. 
<li>There is currently no support for reading symbols from COFF shared libraries. 
You should currently always perform a static link instead of a dynamic link
when linking your program, but that is the default on LynxOS anyway. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
<li>The <code>mpsym</code> command does not work due to the lack of a <code>printf</code>
command on the system. 
<li>The <code>mpedit</code> command does not support the <code>--listing</code> option due
to the lack of an <code>nl</code> command on the system. 
</ul>

<li>LynxOS 3.0.0, PowerPC, BFD, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEMMAP</code> option has no effect. 
<li>The <code>LIST</code> option does not work since the <code>--listing</code> option does
not work in the <code>mpedit</code> command. 
<li>There is currently no support for reading symbols from XCOFF shared libraries. 
You should currently always perform a static link instead of a dynamic link
when linking your program, but that is the default on LynxOS anyway. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
<li>The <code>mpsym</code> command does not work due to the lack of a <code>printf</code>
command on the system. 
<li>The <code>mpedit</code> command does not support the <code>--listing</code> option due
to the lack of an <code>nl</code> command on the system. 
</ul>

<li>LynxOS 3.0.0, PowerPC, XCOFF, <code>gcc</code>
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>USEMMAP</code> option has no effect. 
<li>The <code>LIST</code> option does not work since the <code>--listing</code> option does
not work in the <code>mpedit</code> command. 
<li>There is currently no support for reading symbols from XCOFF shared libraries. 
You should currently always perform a static link instead of a dynamic link
when linking your program, but that is the default on LynxOS anyway. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
<li>The <code>mpsym</code> command does not work due to the lack of a <code>printf</code>
command on the system. 
<li>The <code>mpedit</code> command does not support the <code>--listing</code> option due
to the lack of an <code>nl</code> command on the system. 
</ul>

<li>SINIX 5.43, MIPS R4000, ELF32, <code>cc</code>
<ul>
<li>The thread-safe version of the library does not work.  This is because there
does not appear to be any evidence that this version of the operating system
supports threads. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>Stack traversal may be unreliable from signal-handlers. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>Solaris 2.6, Intel Pentium Pro, BFD, <code>gcc</code>
<ul>
<li>No known issues. 
</ul>

<li>Solaris 2.6, Intel Pentium Pro, ELF32, <code>gcc</code>
<ul>
<li>The <code>USEDEBUG</code> option has no effect. 
</ul>

<li>Solaris 2.5, SPARC V8, BFD, <code>gcc</code>
<ul>
<li>The thread-safe version of the library does not work due to a problem with a
system library. 
<li>The <code>OFLOWWATCH</code> option has no effect.  The
<code>-DMP_PROCFS_SUPPORT=0</code> and <code>-DMP_WATCH_SUPPORT=0</code> options must
be added to <code>CFLAGS</code> in the <code>Makefile</code>. 
</ul>

<li>Solaris 2.5, SPARC V8, ELF32, <code>gcc</code>
<ul>
<li>The thread-safe version of the library does not work due to a problem with a
system library. 
<li>The <code>OFLOWWATCH</code> option has no effect.  The
<code>-DMP_PROCFS_SUPPORT=0</code> and <code>-DMP_WATCH_SUPPORT=0</code> options must
be added to <code>CFLAGS</code> in the <code>Makefile</code>. 
<li>The <code>USEDEBUG</code> option has no effect. 
</ul>

<li>Solaris 7, SPARC V9, BFD, <code>gcc</code>
<ul>
<li>The mpatrol library can be compiled and run in a 64-bit environment. 
</ul>

<li>Solaris 7, SPARC V9, ELF32/ELF64, <code>gcc</code>
<ul>
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The mpatrol library can be compiled and run in a 64-bit environment. 
</ul>

<li>Solaris 8, SPARC V9, BFD, <code>gcc</code>
<ul>
<li>The mpatrol library can be compiled and run in a 64-bit environment. 
</ul>

<li>Solaris 8, SPARC V9, ELF32/ELF64, <code>gcc</code>
<ul>
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The mpatrol library can be compiled and run in a 64-bit environment. 
</ul>

<li>UnixWare 7.1.1, Intel Pentium II, ELF32, <code>gcc</code>
<ul>
<li>The option <code>-DSYSTEM=SYSTEM_UNIXWARE</code> must be added to the <code>CFLAGS</code>
section in the <code>Makefile</code> before building the library. 
<li>The thread-safe version of the library does not work. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
</ul>

<li>AmigaOS 3.1, Motorola 68040, BFD, <code>gcc</code>
<ul>
<li>No memory protection so the <code>PAGEALLOC</code> option has no effect. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>USEMMAP</code> option has no effect. 
<li>The <code>EDIT</code> and <code>LIST</code> options have no effect. 
<li>Limited support for call stack traversal. 
<li>Limited support for reading symbols. 
<li>No detection of illegal memory accesses. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
<li>The <code>mptrace</code> command has no GUI. 
<li>The <code>mpsym</code> command does not work unless <code>gdb</code> and the GNU text
processing tools are installed. 
<li>The <code>mpedit</code> command does not work. 
</ul>

<li>AmigaOS 3.1, Motorola 68040, n/a, SAS/C
<ul>
<li>No automatic override of <code>malloc()</code>, etc., without inclusion of
<code>mpatrol.h</code>. 
<li>No memory protection so the <code>PAGEALLOC</code> option has no effect. 
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEDEBUG</code> option has no effect. 
<li>The <code>USEMMAP</code> option has no effect. 
<li>The <code>EDIT</code> and <code>LIST</code> options have no effect. 
<li>No support for call stack traversal. 
<li>No support for reading symbols. 
<li>No detection of illegal memory accesses. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
<li>The <code>mptrace</code> command has no GUI. 
<li>The <code>mpsym</code> command does not work. 
<li>The <code>mpedit</code> command does not work. 
</ul>

<li>Microsoft Windows NT 4.0, Intel Pentium III, PE, Microsoft Visual C/C++
<ul>
<li>The <code>OFLOWWATCH</code> option has no effect. 
<li>The <code>USEMMAP</code> option has no effect. 
<li>The <code>EDIT</code> and <code>LIST</code> options have no effect. 
<li>There is currently a problem when mixing the archive library version of
mpatrol with the DLL version of the Microsoft Runtime Library, and vice versa. 
<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command has no effect. 
<li>The <code>mptrace</code> command has no GUI. 
<li>The <code>mpsym</code> command does not work. 
<li>The <code>mpedit</code> command does not work. 
</ul>
</ul>

<ul>
<li><a href="#New%20system%20support">New system support</a>:           Adding a new operating system. 
<li><a href="#New%20processor%20support">New processor support</a>:        Adding a new processor architecture. 
<li><a href="#New%20file%20format%20support">New file format support</a>:      Adding a new object file format. 
</ul>

<p><hr>
Node:<a name="New%20system%20support">New system support</a>,
Next:<a rel=next href="#New%20processor%20support">New processor support</a>,
Up:<a rel=up href="#Supported%20systems">Supported systems</a>
<br>

<h2>G.1 Adding a new operating system</h2>

<ul>
<li>Add a new <code>TARGET</code> and/or <code>SYSTEM</code> definition in <code>target.h</code>.  The
<code>TARGET</code> macro is for fundamentally different operating systems, whereas
the <code>SYSTEM</code> macro is for differentiating variations of a particular
operating system.

<li>Make any necessary modifications to <code>config.h</code>.

<li>Add any support for memory allocation in <code>memory.c</code>.

<li>Add any support for stack traversal in <code>stack.c</code>.

<li>Add any platform-specific assembler code in <code>machine.c</code>.

<li>Add any support for signals in <code>signals.c</code>.

<li>Add any support for threads in <code>mutex.c</code>.

<li>Add any support for filenames in <code>diag.c</code>.

<li>Add a new version and date format (or use an existing one) in <code>version.c</code>.

<li>Decide if the <code>malloc()</code> replacements should be used from <code>malloc.c</code>.

<li>Add any support for invoking commands in <code>mpatrol.c</code>.

<li>Add a new subdirectory in the <code>build</code> directory that contains a
<code>Makefile</code> and any other files that are required to build the library on
the new operating system. 
</ul>

<p><hr>
Node:<a name="New%20processor%20support">New processor support</a>,
Next:<a rel=next href="#New%20file%20format%20support">New file format support</a>,
Previous:<a rel=previous href="#New%20system%20support">New system support</a>,
Up:<a rel=up href="#Supported%20systems">Supported systems</a>
<br>

<h2>G.2 Adding a new processor architecture</h2>

<ul>
<li>Add a new <code>ARCH</code> and/or <code>ENVIRON</code> definition in <code>target.h</code>.  The
<code>ARCH</code> macro specifies a processor family, whereas the <code>ENVIRON</code> macro
specifies the size of a word if the processor family can support different word
sizes.

<li>Make any necessary modifications to <code>config.h</code>.

<li>Add any support for memory allocation in <code>memory.c</code>.

<li>Add any support for stack traversal in <code>stack.c</code>.

<li>Add any machine-specific assembler code in <code>machine.c</code>. 
</ul>

<p><hr>
Node:<a name="New%20file%20format%20support">New file format support</a>,
Previous:<a rel=previous href="#New%20processor%20support">New processor support</a>,
Up:<a rel=up href="#Supported%20systems">Supported systems</a>
<br>

<h2>G.3 Adding a new object file format</h2>

<ul>
<li>Add a new <code>FORMAT</code> definition in <code>target.h</code>.

<li>Make any necessary modifications to <code>config.h</code>.

<li>Add any support for stack traversal in <code>stack.c</code>.

<li>Add any support for symbol reading in <code>symbol.c</code>. 
</ul>

<p><hr>
Node:<a name="Notes">Notes</a>,
Next:<a rel=next href="#Frequently%20asked%20questions">Frequently asked questions</a>,
Previous:<a rel=previous href="#Supported%20systems">Supported systems</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix H Notes</h1>

<p>This section contains information about known bugs and limitations in the
mpatrol library as well as listing potential future enhancements.

<p>Bugs should be reported to <a href="mailto:mpatrol@cbmamiga.demon.co.uk">mpatrol@cbmamiga.demon.co.uk</a> along with the
details of the operating system, processor architecture and object file format
that the mpatrol library is being used with -- and don't forget to include the
version of the mpatrol library you are using!  Keep in mind that I only have
access to a Pentium III Notebook PC running Red Hat Linux 6.2 and Windows 98, so
I will be most likely unable to reproduce most of the system-specific bugs.  A
bug report that comes with an associated fix will be most welcome.

<p>Enhancement requests and source code containing enhancements should also be sent
to <a href="mailto:mpatrol@cbmamiga.demon.co.uk">mpatrol@cbmamiga.demon.co.uk</a> or the mpatrol discussion group at
<a href="http://www.egroups.com/group/mpatrol/">http://www.egroups.com/group/mpatrol/</a>.  If you are planning to implement
an enhancement, let me know first in case I am (or someone else is) working
towards the same goal -- that way, work won't be wasted.  If you wish to send
me source code changes please send the changes as context diffs or in an e-mail
attachment as a compressed tar archive.

<ul>
<li><a href="#Generic%20notes">Generic notes</a>:                Notes for all platforms. 
<li><a href="#UNIX%20notes">UNIX notes</a>:                   Notes for UNIX platforms. 
<li><a href="#Amiga%20notes">Amiga notes</a>:                  Notes for Amiga platforms. 
<li><a href="#Windows%20notes">Windows notes</a>:                Notes for Windows platforms. 
<li><a href="#Netware%20notes">Netware notes</a>:                Notes for Netware platforms. 
</ul>

<p><hr>
Node:<a name="Generic%20notes">Generic notes</a>,
Next:<a rel=next href="#UNIX%20notes">UNIX notes</a>,
Up:<a rel=up href="#Notes">Notes</a>
<br>

<h2>H.1 Notes for all platforms</h2>

<ul>
<li>C++ support is still fairly limited, and will possibly only work for older C++
code due to the way the operators are overridden (i.e. there are no exceptions
versions of the functions).  Also, explicit references to <code>operator new</code>
rather than <code>new</code> are likely to result in compilation errors, and the way
that source level information is obtained for <code>operator delete</code> means that
the resulting code will not be thread-safe.  It might also be an idea to provide
an allocation class from which user-defined memory allocators can be derived.

<li>Need to add support for other 64-bit processors in addition to the existing
SPARC V9 support.  This shouldn't be too hard, but I haven't got access to such
processors to test them, so I haven't been able to yet.  Also need to add
support for building on targets and architectures where no operating system
features are required or even available.

<li>Need to improve the concurrency in the thread-safe version of the mpatrol
library.  Currently, only one thread at a time is allowed to enter the mpatrol
library, but it should be possible to extend this to protect individual data
structures.  Note that this will not only help to improve efficiency, but might
also allow the mpatrol library to uncover bugs in thread-safe code that are
timing-dependent.

<li>Need to make the library re-entrant.  This could be achieved by moving the
static variables in <code>memory.c</code>, <code>stack.c</code>, <code>mutex.c</code>,
<code>diag.c</code>, <code>trace.c</code>, <code>option.c</code> and <code>sbrk.c</code> into the
<code>infohead</code> structure and then having an array of <code>infohead</code> structures
from which to allocate new memory headers when a new one is required.  This is
only necessary for Amiga shared libraries and Netware NLMs since UNIX and
Windows platforms allocate a new copy of the data section in a shared library or
DLL when it is opened by a new process.

<li>Some implementations of call stack traversal are limited and will only likely
work for unoptimised code.  A much better solution would be write the
implementations at a lower level in assembly, but this is much less portable. 
Perhaps there is a library which can be used to perform this across many
operating systems and processor architectures, or maybe someone would like to
write one<a rel=footnote href="#fn-44"><sup>44</sup></a>?  I
can think of many applications that would benefit from such a library besides
this one<a rel=footnote href="#fn-45"><sup>45</sup></a>.

<li>An alternative implementation for call stack traversal uses the functions
<code>__builtin_frame_address()</code> and <code>__builtin_return_address()</code> that are
available when the library is compiled with <code>gcc</code>.  However, they can
only traverse a number of stack frames at compile-time, not run-time so there is
a maximum number of stack frames that can be traversed at any one time.  The
implementation depends on both of these builtin functions returning <code>NULL</code>
when the top of stack is reached.  If this is not the case then this method
cannot be used or should only be used with a small number of fixed stack frames. 
However, perhaps there might even be a use for an option to limit the number of
stack frames in stack tracebacks for systems that have no such limitation.

<li>Need to change <code>__mp_compareaddrs()</code> so that it will improve the detection
of when to free memory allocations made by <code>alloca()</code> and its related
functions.  This will involve checking the common return addresses in the call
stacks instead of just checking them if the stack depth is the same.  Also,
on systems that don't have full call stack traversal, the minimum number of
bytes that stack frames should differ by should be platform-dependent since the
current value is way too high.

<li>Add a function to display a stack trace of the current call stack to a file
stream and another function to walk all current memory allocations invoking a
callback function for each one encountered.  Note that there is still an issue
with callback functions if they call mpatrol library functions, since this
will lead to recursion.  Callback functions could also be defined for
<code>__malloc_hook()</code>, <code>__realloc_hook()</code> and <code>__free_hook()</code> in much
the same way as for the GNU C library.

<li>Need to store filename and line number information in all call stacks so that
the information can be used at program termination.  May also need to display
this information in the <code>__mp_printinfo()</code> function and add this
information to the profiling output file so that <code>mprof</code> can make use of
it.  Stack traces also need to be displayed when the <code>__mp_checkrange()</code>
and <code>__mp_checkstring()</code> internal functions fail.  Likewise for the
<code>strdup()</code> family of functions if the source string is invalid.

<li>In object file formats that support nested symbols (such as ELF), the current
implementation will tend to show some shortcomings.  This is because there is
currently no nesting count in the function that deals with symbol name lookup,
so the wrong symbol name may be displayed in diagnostics.

<li>In object file formats that don't store the sizes of symbols (such as basic
COFF, or when using the GNU BFD library), the current implementation will simply
assume that the current symbol terminates at the beginning of the next symbol in
the virtual address space.

<li>Add functions to start and stop profiling, and perhaps also to clear the
profiling tables and begin a new profiling output file.  Should also write more
information to the profiling output file, such as the date that it was produced
on and the word size of the processor that it was produced on, so that
<code>mprof</code> will not crash when reading a profiling output file produced on
a processor that has a different word size.

<li>Perhaps add the ability to profile memory operations such as <code>memcpy()</code> and
<code>memset()</code> to the existing memory allocation profiling facility.  Also, add
options to <code>mprof</code> to write out files that can be used by chart drawing
software for a better visualisation of the first few profiling tables.

<li>Extend the <code>mptrace</code> command to graphically display the size of the heap
plotted against time and the allocation size frequency.  Also rewrite the GUI
support to use GNOME instead of Motif.

<li>Improve the speed of watch points by setting a range of allocation indices for
which they will be used.  This may require a lot of code changes in
<code>alloc.c</code>.

<li>Add a software watch point facility that can be placed on ranges of addresses in
the heap.  Then, if a heap operation touches the watch point, either the user
can be notified or a callback function can be called.  The same could be done
for local variables if the stack frame can be easily determined, which would
also allow detecting if a read from or write to memory was performed just beyond
the stack pointer.

<li>Add a CRC checksum to memory blocks and use it to check that freed memory
allocations have not been corrupted when the <code>NOFREE</code> and
<code>PRESERVE</code> options are in use on platforms which have no memory
protection.  This could also be extended to marking allocated memory blocks
and then displaying what blocks have changed after a certain period from within
a debugger.  Another idea could be to display all memory allocations, etc. 
made since a certain function was called from within a program.

<li>Add an option to set up a timer that will automatically check the heap after a
certain number of clock cycles have elapsed.  This could be useful in programs
that have long periods of time where no dynamic memory allocation functions are
called, but heap allocations are still manipulated.  In addition, checks could
automatically be made upon receipt of special signals sent to the program by
the user and information about the last successful verification of the heap
could be used to narrow down problems.

<li>Add a diagnostic number count to each warning and error reported in the log
file.  This could then be used to implement a <code>DIAGSTOP</code> option which
would stop the program running after a certain number of diagnostics have been
displayed.

<li>Perhaps add the string used as an argument to <code>malloc()</code>, <code>calloc()</code>,
etc. to the information stored about each memory allocation.  This could aid
greatly in debugging but might be a bit cryptic if the original source code
involved a lot of preprocessor macros.  This could also be extended to providing
a function that could individually label each memory allocation with a given
string.

<li>Perhaps add time information to the details stored about each memory allocation. 
This is probably not useful unless the system provides a high-resolution timer.

<li>Add an option (perhaps <code>NOINTERNAL</code>) to suppress the display of internal
(recursive) memory allocations in the mpatrol log file and also prevent
information about such allocations being written to the profiling output and
tracing output files.  This could also be extended to prevent memory leaks from
being reported if the original allocations were made from a given set of
functions.

<li>Maybe show the contents of the <code>MPATROL_OPTIONS</code> environment variable in the
summary as well.

<li>Add versions of <code>mallopt()</code>, <code>mallinfo()</code>, <code>memorymap()</code>,
<code>mallocctl()</code>, <code>mallocblksize()</code> and <code>msize()</code> which are provided
in many other malloc libraries.  These won't necessarily behave in exactly the
same way as existing implementations, but at least there won't be link errors
when compiling source code which uses them.  Global variables could also be
added for reading and writing library settings in a debugger.

<li>Perhaps add debugging/tracing versions of the string manipulation functions,
such as <code>strlen()</code> and <code>strcmp()</code> in much the same way as was done for
the memory operation functions.  The only problem with this would be locale
support, but perhaps it might be easier just to assume the C locale to begin
with.  Also need to have better detection of internal and free blocks when
displaying memory range errors.

<li>Perhaps add definitions of <code>xmalloc()</code>, <code>xrealloc()</code>, etc. which
never return <code>NULL</code> on failure.

<li>Perhaps reimplement the standard I/O library for internal use by mpatrol, thus
preventing recursive calls to <code>malloc()</code> each time a write to the log file
occurs on some systems.  Example code to do this was submitted by Alexander
Barton (<a href="mailto:abarton@innotrac.com">abarton@innotrac.com</a>) and this may well be incorporated into
the library at some point in the future.

<li>Add functions to write diagnostics to the mpatrol log file from within program
code.  These could include displaying call stacks and dumping contents of
memory allocations.  The <code>__mp_edit()</code> and <code>__mp_list()</code> functions
could be added to give functionality similar to the <code>EDIT</code> and
<code>LIST</code> options at any time during program execution.

<li>The <code>LOG*</code> options could be extended to take a list of specific functions
to log.  They could also only log operations spanning a range of addresses or
allocation indices as well.

<li>Add an option to limit the size of each memory allocation to a maximum number
of bytes.  This could be useful if a memory allocation function is called with
an uninitialised variable.

<li>Add another library which can be linked in instead of mpatrol and replaces
all calls to <code>__mp_alloc()</code>, etc., with the original calls to
<code>malloc()</code> and related functions.  This would be very useful for quickly
removing all mpatrol functionality for perhaps even a release build, and might
be useful for implementing functions such as <code>memalign()</code> which don't
exist on many systems.

<li>Add assertion macros to <code>mpatrol.h</code> that can be used in program code. 
These could be used to assert that pointers have not been freed or are valid
heap addresses, etc.  They would be disabled if <code>NDEBUG</code> is defined.

<li>Add support functions that could be added to user code to enter and leave
scopes in a source file and ensure that all allocations allocated within the
scope are freed by the time the scope has been exited.  A function could also
be added to mark certain memory allocations as being validly in use so as to
avoid leak warnings.  Any attempts to free such allocations would result in an
error.  Other functions could be added to add or clear references to certain
memory allocations and to return the current number of memory allocations or
bytes allocated.

<li>Write a set of functions that are compatible with those implemented by Checker,
the <code>gcc</code> run-time memory access checker.  This would allow every memory
access to be checked in object files compiled with <code>gcc</code>, not just
pointers into the heap, and would provide error checking as effective as source
code instrumentation.  Could also make use of the <code>etext</code>, <code>edata</code> and
<code>end</code> pointers that are set at run-time on most UNIX systems.

<li>Details of the segments which make up the executable file and any shared
libraries could be made use of in order to detect operations which cross such
segments.  For example, a memory operation may erroneously cross the data
and BSS segments.  The symbol table for data symbols could also be used to
provide much finer-grained error-checking.

<li>Add an option to specify that all failed memory allocations should abort (or at
least give a warning) instead of returning a <code>NULL</code> pointer.  Also, perhaps
add an option to display the partial contents of freed and unfreed allocations
in the mpatrol log file and also a function which can be called to dump the
contents of a memory allocation to the log file.

<li>Perhaps add memory protection to the simulated <code>sbrk</code> heap.

<li>Add an option to report if one thread resizes or frees another thread's
allocations.  This may not be useful in most cases, but it might be possible
to track down some obscure bugs in some situations.

<li>Perhaps add internationalisation support through the use of locales and message
catalogs.  Unfortunately, there does not appear to be a unified method for doing
this across all platforms and there may also be issues with third-party
libraries calling <code>malloc()</code> and other related routines when the mpatrol
library is attempting to initialise itself.

<li>There is currently a problem when the mpatrol library encounters an illegal
memory access on UNIX and Windows platforms, and there is a further illegal
memory access when it is displaying the summary.  This should be prevented by
disabling the signal handler at its first entry.

<li>The <code>mpsym</code> command could optionally preserve any stack traceback lines
that already have symbolic or debugging information associated with them.  It
could also support more debuggers other than just <code>gdb</code>.  Finally, it
could support <code>-</code> as the filename for reading the mpatrol log file from the
standard input file stream.

<li>Add a script to wrap around various popular C and C++ compiler drivers so that
linking with the mpatrol library is much less laborious.  In addition, a
user-defined command or script file could be executed at the end of every
invocation of the <code>mpatrol</code> command.

<li>Add a script to automatically run the mpatrol library tests.  It could be quite
hard to verify the tests since the heap addresses are likely to be different on
every new build and will certainly be different across different platforms.

<li>Perhaps include a script which will combine two or more archive libraries.  This
would certainly simplify linking with the mpatrol library since only one library
would be required.

<li>Perhaps use GNU autoconf to automatically work out values for <code>config.h</code> on
the platform it is being built on, and also use automake, libtool and install
when building and installing files.  Also update the <code>mupdate</code> shell
script to automatically update the version numbers contained in the files in the
<code>pkg</code> directory.

<li>The postscript version of the quick reference card seems to print at an unusual
offset on some printers.  In addition, the mpatrol manual should also be
formatted in DocBook format once a suitable TeXinfo to DocBook translator is
available.

<li>Perhaps add benchmark tests for dynamic memory allocation functions and memory
operation functions.  Obviously the mpatrol library would perform much worse
than normal malloc libraries, but it would help to see just how much worse so
that speed improvements could be made.

<li>Add support for the BeOS operating system, as well as MacOS and OS/2.  Perhaps
MS-DOS might be possible as well. 
</ul>

<p><hr>
Node:<a name="UNIX%20notes">UNIX notes</a>,
Next:<a rel=next href="#Amiga%20notes">Amiga notes</a>,
Previous:<a rel=previous href="#Generic%20notes">Generic notes</a>,
Up:<a rel=up href="#Notes">Notes</a>
<br>

<h2>H.2 Notes for UNIX platforms</h2>

<ul>
<li>Need to improve watch point facility in order to speed it up by an order of
magnitudes.  This will most likely involve removing all watch points when
entering the library and replacing them when returning to user code.

<li>Improve use of watch points by allowing an option which will only install write
watch points instead of both read and write watch points.  Not only will this
speed up the use of watch points, but will also cause less problems with reading
from misaligned memory allocations.

<li>There seems to be a problem on some UNIX systems in that the <code>mprotect()</code>
call will not work unless it is used on memory that has been allocated with
<code>mmap()</code>.  This needs to be investigated further.

<li>There is currently a problem in that the call stack displayed from within the
illegal memory access signal handler is not necessarily accurate with respect to
the function at the top of the stack.  In addition, signal handlers shouldn't
technically call I/O functions in case of additional signals being caught so
this may need to be improved.

<li>Need to add a way of initialising the thread-safe version of the library when
it is not compiled on a system that supports <code>.init</code> sections, or if it is
not compiled with the GNU C compiler, or if it is not compiled with a C++
compiler.  Also perhaps need to support other threads packages instead of just
POSIX threads.

<li>Need to add support for call stack traversal for the Alpha, and Itanium
processor architectures.  The current implementation of call stack traversal for
the Motorola 88xx0 family is also a bit flaky and so should only be used when
the library and program are built unoptimised.  This could be improved on DG/UX
platforms by making use of the TDESC information stored in the object files.

<li>Need to add support for obtaining the program name from the stack for the Alpha,
Itanium and Motorola 88xx0 processor architectures.  If there is no support for
determining the filename that a program was invoked with then the
<code>PROGFILE</code> option can be used to specify the program name at run-time.

<li>If the <code>MP_LIBRARYSTACK_SUPPORT</code> preprocessor macro is defined when
building the mpatrol library on IRIX platforms then the <code>libexc</code> library
must also be linked in.  However, execution speed will fall dramatically since
the <code>unwind()</code> function within that library calls <code>malloc()</code>,
<code>free()</code> and other memory operation functions every time it is invoked. 
The only reason to use this library rather than the default method of stack
traversal on MIPS would be if that method failed due to a bug (in which case
it should be reported anyway).

<li>The mpatrol library <code>unwind()</code> function on MIPS platforms may have problems
with call stack traversal in alternative stacks, such as those used by signal
handlers.  The call stack will then terminate at the point at which the handler
was called rather than unwinding to the top of the stack.

<li>The library cannot currently read any symbols from shared objects that have been
read via <code>dlopen()</code>, <code>shl_load()</code> or similar functions.  In addition,
symbols cannot currently be read from any COFF or XCOFF shared libraries on AIX
or LynxOS and some work needs to be done to build the mpatrol library as a
shared library on those systems.

<li>Perhaps add support for reading HP/UX executable files and libraries in the SOM
object file format without needing to use the GNU BFD library.

<li>Perhaps add support for other popular text editors in the <code>mpedit</code>
command.  Also add a way to specify editor options to the <code>mpedit</code>
command.

<li>Add support for Digital UNIX and also the BSD systems (specifically FreeBSD,
NetBSD, OpenBSD and SunOS) and other non-System V UNIX operating systems.

<li>The <code>--dynamic</code> option to the <code>mpatrol</code> command does not always
work on systems whose dynamic linkers support the <code>LD_PRELOAD</code> or
<code>_RLD_LIST</code> environment variables.  This is because the object file format
access libraries do not exist in shared form on such systems.

<li>Perhaps add files to build the mpatrol library and tools as a Debian package. 
</ul>

<p><hr>
Node:<a name="Amiga%20notes">Amiga notes</a>,
Next:<a rel=next href="#Windows%20notes">Windows notes</a>,
Previous:<a rel=previous href="#UNIX%20notes">UNIX notes</a>,
Up:<a rel=up href="#Notes">Notes</a>
<br>

<h2>H.3 Notes for Amiga platforms</h2>

<p>The Amiga has now been re-released as a completely new machine which comes with
a completely new operating system.  As a result, I will not be implementing
any of the following features (or fixing any of the following problems) in
mpatrol for the old AmigaOS.  Support for the new AmigaOS may be added in the
future.

<ul>
<li>Perhaps add support for building mpatrol as an Amiga shared library.  I
attempted to do this in a previous release of mpatrol, but it would have
involved too many source changes to get working fully.  Perhaps it's not even
worth implementing as the archive library works fine.  However, if it is built
as a shared library and <code>malloc()</code> and related functions are dynamically
linked in some executable files then perhaps it would be possible to override
these functions, thus getting the <code>--dynamic</code> option in the
<code>mpatrol</code> command to work.

<li>Need to fix the problem where the maximum guaranteed alignment of an internal
mpatrol library memory allocation is 8 bytes.  However, this limitation does
not affect the <code>memalign()</code> and related functions, and should not have any
effect on the running of mpatrol since no datatypes require an alignment of more
than 8 bytes.

<li>Need to add proper support for call stack traversal for both the Motorola 680x0
and PowerPC processor architectures.  When <code>gcc</code> is being used then
up to two stack frames can be traversed, but this should really be extended
without requiring <code>MP_BUILTINSTACK_SUPPORT</code>.  When SAS/C is being used then
there is no support for call stack traversal.

<li>Need to add proper support for reading symbols from Amiga executable files. 
When <code>gcc</code> is being used then the BFD library routines will be called
to determine the symbols from the executable file, but this will only work for
objects compiled with <code>gcc</code> and there currently appears to be a problem
getting the <code>USEDEBUG</code> option to work.  When SAS/C is being used then
there is no support for reading symbols from executable files.  Also need to add
support for reading symbols from any shared libraries that are required by the
program.

<li>Possibly make use of other software such as Enforcer, Mungwall or MuLib in order
to provide some form of memory protection.  The features of SegTracker could
also be put to good use so that the file and hunk location of entries on the
call stack could be determined.

<li>Could add support for the <code>EDIT</code> and <code>LIST</code> options.  This would
probably involve finding a way to invoke a shell script without having to search
for the script file or allocating memory in the process.

<li>Add GUI support for the <code>mptrace</code> command.

<li>When using SAS/C it is currently not possible to override the definition of
<code>malloc()</code>, etc., without including the <code>mpatrol.h</code> header file first. 
This is because the compiler startup code and libraries call <code>malloc()</code>
before everything is set up, and so the library cannot properly initialise
itself if the <code>malloc()</code> that the startup code finds is the <code>malloc()</code>
in the mpatrol library.  This restriction does not exist when using
<code>gcc</code>.

<li>Add support for the Amiga in the threads test in <code>tests/pass/test5.c</code>. 
The Amiga doesn't really have support for threads but its processes are similar
enough to threads.

<li>Perhaps add an <code>Installer</code> installation script with icons. 
</ul>

<p><hr>
Node:<a name="Windows%20notes">Windows notes</a>,
Next:<a rel=next href="#Netware%20notes">Netware notes</a>,
Previous:<a rel=previous href="#Amiga%20notes">Amiga notes</a>,
Up:<a rel=up href="#Notes">Notes</a>
<br>

<h2>H.4 Notes for Windows platforms</h2>

<ul>
<li>Need to add support for processors other than the Intel 80x86.  However, about
99% of Windows platforms run on this processor family -- does anyone really use
Windows with other processors?

<li>Perhaps add support for compiling the mpatrol library with <code>gcc</code> on
Windows platforms so that the GNU BFD library can be used as well.

<li>There seems to be a problem when mixing the archive version of the mpatrol
library and the Microsoft C run-time library DLL, and vice versa.  This needs
to be looked into, but for the moment, don't mix them.

<li>The library cannot currently read any symbols from DLLs that have been read via
<code>LoadLibrary()</code>.

<li>Perhaps add support for the <code>mpatrol</code> command's <code>--dynamic</code>
option by preloading the mpatrol DLL from the <code>mpatrol</code> command.

<li>Could add support for the <code>EDIT</code> and <code>LIST</code> options.  This would
probably involve finding a way to invoke a batch file without having to search
for the batch file or allocating memory in the process.

<li>Add GUI support for the <code>mptrace</code> command.

<li>Add a Windows resource file to the mpatrol library with copyright and version
information.

<li>Perhaps add an <code>InstallShield</code> installation script with icons. 
</ul>

<p><hr>
Node:<a name="Netware%20notes">Netware notes</a>,
Previous:<a rel=previous href="#Windows%20notes">Windows notes</a>,
Up:<a rel=up href="#Notes">Notes</a>
<br>

<h2>H.5 Notes for Netware platforms</h2>

<p>There doesn't appear to have been any interest in the Netware version of mpatrol
and as a result I will not be implementing any of the following features (or
fixing any of the following problems) in mpatrol for Netware.  I don't even have
access to a Netware machine so someone else would have had to have done it
anyway.

<ul>
<li>The library has not yet been built (let alone tested) on Netware platforms.  The
names of the system functions that the library calls for Netware were obtained
by looking at Novell's developer documentation, so they may not even compile
correctly without modification.

<li>Need to add support for building the mpatrol library as an NLM.  This is not
currently a high priority requirement as the archive library should suffice for
most purposes.  However, if it is built as an NLM and <code>malloc()</code> and
related functions are dynamically linked in some executable files then perhaps
it would be possible to override these functions, thus getting the
<code>--dynamic</code> option in the <code>mpatrol</code> command to work.

<li>Need to add support for processors other than the Intel 80x86.  However, about
99% of Netware platforms run on this processor family -- does anyone really use
Netware with other processors?

<li>Need to add way to determine when the base of the stack has been reached during
call stack traversal, since on Netware every application is really a thread
running under one large process.

<li>Need to add support for reading symbols from Netware load modules.  Also need to
add support for reading symbols from any NLMs that are required by the program. 
This may be possible in a limited fashion by using the GNU BFD library, but may
only work with code compiled with <code>gcc</code>.

<li>Could add support for the <code>EDIT</code> and <code>LIST</code> options.  This would
probably involve finding a way to invoke a batch file without having to search
for the batch file or allocating memory in the process.

<li>Add GUI support for the <code>mptrace</code> command.

<li>Need to investigate if it is safe (or even possible) to override the definitions
of <code>malloc()</code>, etc., without including the <code>mpatrol.h</code> header file
first.  Currently, non-macro definitions for these functions have been disabled
in the Netware version of the library in case they affect other NLMs that are
currently running. 
</ul>

<p><hr>
Node:<a name="Frequently%20asked%20questions">Frequently asked questions</a>,
Next:<a rel=next href="#Related%20software">Related software</a>,
Previous:<a rel=previous href="#Notes">Notes</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix I Frequently asked questions</h1>

<p>This section contains frequently asked questions about the mpatrol library and
their corresponding answers or solutions.

<ul>
<li><a href="#Documentation">Documentation</a>:                Formatting, converting and printing. 
<li><a href="#Building">Building</a>:                     Compiling with the mpatrol library. 
<li><a href="#Linking">Linking</a>:                      Linking with the mpatrol library. 
<li><a href="#Running">Running</a>:                      Running with the mpatrol library. 
<li><a href="#Files">Files</a>:                        Different types of files. 
</ul>

<p><hr>
Node:<a name="Documentation">Documentation</a>,
Next:<a rel=next href="#Building">Building</a>,
Up:<a rel=up href="#Frequently%20asked%20questions">Frequently asked questions</a>
<br>

<h2>I.1 Documentation</h2>

<ol type=1 start=1>
<li>I can't seem to format the TeXinfo manual for mpatrol into anything that I
can view or print.  What am I doing wrong?

<p>You'll need to have the appropriate document formatting programs installed on
your system before you can do this, and even then you'll also need to have
suitable software for viewing or printing the formatted documents.  You can
download an archive containing the latest mpatrol manual in a variety of formats
from <a href="http://www.cbmamiga.demon.co.uk/mpatrol/">http://www.cbmamiga.demon.co.uk/mpatrol/</a> and this will also contain
a file telling you where to get programs that can be used to view or print these
files.  Alternatively, you can browse the latest mpatrol manual on-line at the
same site.

</p><li>I'd like to convert the mpatrol manual to a different documentation format but
there is no support for that format in the <code>Makefile</code>.  How would I go
about doing this?

<p>Since TeXinfo is intended to be converted to other documentation formats it
should be fairly easy for you to find a tool which will convert it into your
desired format.  I plan to also provide the mpatrol manual in DocBook format if
and when a suitable TeXinfo to DocBook converter becomes available, but I
won't provide preformatted versions of the mpatrol manual in any other format
which isn't already supported.

</p><li>Why is the reference card not centred in the middle of the page when I print it?

<p>The reference card has three columns in landscape format and as a result
requires smaller margins than LaTeX normally uses.  When <code>dvips</code>
converts the DVI file to a postscript file it refers to a configuration file set
up for a specific printer so that it knows what that printer's capabilities are. 
However, you can instruct <code>dvips</code> to offset the page by a given amount
with the <code>-O</code> option so that it appears centred when printed.  I find
that <code>-O -0.75in,0.25in</code> works for me.  Note that the default paper size
for the reference card is DIN A4, but you can change it to US letter in the
LaTeX source file.

</p><li>How do I install the mpatrol manual as a GNU info file?

<p>Assuming you have the GNU info file built and copied to your system's info file
directory, you should use the <code>install-info</code> command to place an entry
for mpatrol in your system's GNU info directory file, otherwise the GNU info
reader may not be able to locate the mpatrol entry.  You may also need to modify
your <code>INFOPATH</code> environment variable if you installed the GNU info file in a
non-standard place.

</p><li>How do I install the mpatrol manual pages?

<p>This is very system-dependent, but need only be done on UNIX systems since they
cannot be used on other platforms.  The unformatted manual pages exist in
<code>man/man1</code> and <code>man/man3</code> and should be copied to your system's manual
page directory.  If you don't have the <code>nroff</code>, <code>troff</code> or
<code>groff</code> commands installed on your system then you may also need to copy
the formatted manual pages, located in <code>man/cat1</code> and <code>man/cat3</code>.  You
may also need to modify your <code>MANPATH</code> environment variable if you installed
the manual pages in a non-standard place, and some systems require you to update
the <em>whatis</em> database after installing new manual pages, by running
<code>makewhatis</code>, <code>catman</code> or equivalent.
</ol>

<p><hr>
Node:<a name="Building">Building</a>,
Next:<a rel=next href="#Linking">Linking</a>,
Previous:<a rel=previous href="#Documentation">Documentation</a>,
Up:<a rel=up href="#Frequently%20asked%20questions">Frequently asked questions</a>
<br>

<h2>I.2 Building</h2>

<ol type=1 start=1>
</p><li>Why does the <code>Makefile</code> assume that I am building mpatrol on platform X
when I am really building on platform Y?

<p>The <code>src/config.h</code> and <code>src/target.h</code> header files attempt to obtain
as much information from the compiler as possible, mainly from any predefined
preprocessor macros that it defines during compilation.  If this information
is incorrect then you can override the <code>TARGET</code>, <code>SYSTEM</code>,
<code>ARCH</code>, <code>ENVIRON</code> and <code>FORMAT</code> preprocessor macros defined in
<code>src/target.h</code> to suit your particular system by explicitly defining them
in <code>CFLAGS</code> within the <code>Makefile</code> when you build mpatrol.  You could
also choose to build different versions of mpatrol with different settings of
<code>ENVIRON</code> or <code>FORMAT</code> on a single system if you wish to by changing
<code>ENVIRON</code> or <code>FORMAT</code> for different builds.

</p><li>The processor family I am compiling on supports both 32-bit and 64-bit modes
of operation.  How do I specify which I want?

<p>You will have to look at the documentation for the compiler you are using in
order to find out how to specify which operating environment you wish to
target.  For example, if you are using the Sun C compiler on a SPARC V9 Solaris
machine then you should specify the <code>-xarch=v9</code> option in the
<code>Makefile</code> when you are building mpatrol in order to target the 64-bit
environment.  If you think that you are already using the correct option, but
the mpatrol code is still being built to support the wrong environment then you
could try explicitly setting the <code>ENVIRON</code> preprocessor macro in the
<code>Makefile</code>.

</p><li>I cannot include <code>mpatrol.h</code> from my C++ source code as I get lots of
compilation errors.  Why is this and what can I do to prevent them?

<p>The most likely reason that you are getting errors is because you are calling
placement <code>new</code>, and the way that mpatrol derives source information from
calls to <code>operator new</code> is by defining a macro called <code>new</code>, thus
causing lots of problems when calling placement <code>new</code> or explicitly
calling <code>operator new</code>.  You can either try not to use placement
<code>new</code> or you can define the preprocessor macro <code>MP_NOCPLUSPLUS</code> when
compiling your source file, which will disable the overriding of any C++
operators in <code>mpatrol.h</code>.  Alternatively, if you define
<code>MP_NONEWDELETE</code> then you can use <code>MP_NEW</code> and <code>MP_DELETE</code> in
order to call the mpatrol versions of the C++ operators.

</p><li>I still have the above problem, but I don't think it's due to placement
<code>new</code> since the compiler complains about <code>operator new[]</code>, so could
that be a clue?

<p>Yes.  The most likely reason is that the C++ compiler does not support the array
<code>new</code> and <code>delete</code> operators.  These were introduced some time before
the standardisation of the C++ language but some compilers may not yet have
support for them.  It may be that you have to use a special compiler option to
enable support for these operators, but if not you will probably have to edit
<code>mpatrol.h</code> to temporarily allow your files to compile.

</p><li>Why am I unable to call the mpatrol version of <code>alloca()</code>?  I only ever
seem to call the default version.

<p>Most implementations of the <code>alloca()</code> function are compiler builtins which
will be converted to inline assembler or object code in order for them to be
able to dynamically modify the calling function's stack frame at run-time.  As
a result, the call to <code>alloca()</code> is recognised as an intrinsic keyword and
is dealt with specially by the compiler.  However, if this can be intercepted by
the preprocessor before the compiler parses the source code then the call can be
redirected to another function.  This is one of the functions of the
<code>mpatrol.h</code> header file, which means that it must be included before the
first call the <code>alloca()</code>.  If <code>alloca.h</code> is also being included then
<code>mpatrol.h</code> must be included after it, otherwise it may redefine
<code>alloca()</code> back to the default version.

</p><li>Why do some of the <code>Makefile</code>s contain the <code>-fno-inline-functions</code>
option as part of <code>OFLAGS</code>?

<p>The <code>-fno-inline-functions</code> option is a <code>gcc</code>-specific option
which instructs the compiler not to inline any functions.  This is necessary on
some platforms where function call stack traversal is supported, since function
inlining may significantly alter the layout of a program's stack.  Normally this
option is only required when building the mpatrol library, but on some platforms
function call stack traversal may not work properly unless this option (or
equivalent) is used for all compiled code.

</p><li>What does the <code>MP_INLINE</code> definition in <code>mpatrol.h</code> do?

<p>It is used in the definition of the debugging versions of the C++ operators in
<code>mpatrol.h</code> so that they are inlined correctly.  We want to define the C++
operators so that they will be inlined in every source file that uses them and
also not clash with the versions defined in the mpatrol library or the standard
C++ library.  Traditionally, this is done by defining them to be
<code>static inline</code>, which means that any non-inlined definition will be local
to each object file.  An even better technique is available with the new C++
standard which allows <code>extern inline</code> definitions, meaning that no
definition will be available if the function is not inlined.  Unfortunately, if
optimisation is turned off in the compiler then no inlining will usually be
performed and so the definitions will be real functions.  Luckily, on ELF
platforms the <code>extern inline</code> function definition will have a weak
visibility and so will not clash with library functions.

</p><li>Why do I get different stack traces in the mpatrol log file from the C++
operators in <code>mpatrol.h</code> when optimisation is turned on and off in the
compiler?

<p>When the compiler is optimising it will invariably be performing inlining, in
which case each inlined function will share the stack frame of its caller when
it is called -- the mpatrol library cannot detect this.  In order to cope in
both situations, the non-inlined case will contain the name of the C++ operator
at the top of its stack, even though it will be removed in the inlined case.

</p><li>How do I build the <code>mptrace</code> command with GUI support?

<p>The GUI support for the <code>mptrace</code> command is currently written to use
Motif and X Windows and so can only be built on systems with these libraries
and run on systems with an X server.  This will most likely be possible only on
UNIX platforms.  LessTif can be used instead of Motif if that is all that is
available on your system.
</ol>

<p><hr>
Node:<a name="Linking">Linking</a>,
Next:<a rel=next href="#Running">Running</a>,
Previous:<a rel=previous href="#Building">Building</a>,
Up:<a rel=up href="#Frequently%20asked%20questions">Frequently asked questions</a>
<br>

<h2>I.3 Linking</h2>

<ol type=1 start=1>
</p><li>Why do I get undefined symbols when linking with the mpatrol library?

<p>This is most likely caused by the mpatrol library requiring additional symbols
defined in an object file access library.  If mpatrol was built with
<code>FORMAT=FORMAT_ELF32</code> or <code>FORMAT=FORMAT_ELF64</code> then you'll need to
add <code>-lelf</code> (or equivalent) to the compiler command line straight after
<code>-lmpatrol</code>.  If mpatrol was built with <code>FORMAT=FORMAT_BFD</code> then
you'll need to add <code>-lbfd -liberty</code> (or equivalent) instead.  If you are
using the thread-safe version of mpatrol then you may also need to link with the
system threads library.

</p><li>Why do I still get undefined symbols on HP/UX, IRIX or Windows platforms,
despite following the above instructions?

<p>If the symbol is called <code>U_get_previous_frame</code> on HP/UX then you still need
to link with the system stack traceback library, <code>libcl.sl</code>.  If the
symbols are called <code>exc_setjmp</code> and <code>unwind</code> on IRIX and you defined
the <code>MP_LIBRARYSTACK_SUPPORT</code> preprocessor macro when building the mpatrol
library then you still need to link with the system exception library,
<code>libexc.so</code>.  If the symbols all begin with <code>Sym</code> on Windows platforms
then you still need to link with the system symbol access library,
<code>imagehlp.lib</code>.

</p><li>I tried all of the above, but why is the <code>SymGetLineFromAddr</code> symbol still
undefined on Windows platforms?

<p>This is due to the <code>imagehlp.lib</code> or <code>imagehlp.dll</code> libraries on your
system being out of date.  The <code>SymGetLineFromAddr()</code> function was added to
this library at a much later date from the original release so if you want the
<code>USEDEBUG</code> option to work you should try to get an updated library from
Microsoft.  Alternatively, you can disable the call to it in
<code>__mp_findsource()</code> but the <code>USEDEBUG</code> option will no longer work.

</p><li>Why do I get duplicate definitions of symbols when linking with the mpatrol
library?

<p>This is most likely caused by your code, or a library, providing definitions of
<code>malloc()</code> and <code>free()</code> which conflict with those defined in the
mpatrol library.  You'll need to disable these in order to perform a successful
link and use the replacements in mpatrol instead.

</p><li>I linked my program to a shared library version of mpatrol.  Now, when I try to
run my program, the system complains that it cannot find the mpatrol library. 
How do I get this to work?

<p>You need to tell the system where to find the shared library version of the
mpatrol library, either by setting your <code>LD_LIBRARY_PATH</code> environment
variable (or just <code>PATH</code> on Windows platforms), or by embedding the full
path to the library into the executable when you link your program by setting
the <code>LD_RUN_PATH</code> environment variable.

</p><li>I linked my program to a shared library version of mpatrol.  Will future
releases of mpatrol remain compatible with this version or will I have to relink
my program?

<p>Backwards compatibility is not generally guaranteed, but should be preserved if
only the bug fix part of the mpatrol version number has changed, with the major
and minor versions staying the same.  For example, versions 1.0.3 and 1.0.8
should be compatible, but upgrading to version 1.1.0 may require a relink.

</p><li>I have linked my program with the DLL version of the mpatrol library on Windows
but it crashes when I run it.  I suspect that the crash is occurring when the
mpatrol library is being initialised, so what is going wrong?

<p>There appears to be a problem when using the mpatrol DLL and the static version
of the Microsoft C run-time library, and also a problem when using the static
version of mpatrol and the Microsoft C run-time library DLL.  Luckily, if you
ensure that you use either both static libraries or both DLLs at the same time
then the problem should go away.  There doesn't seem to be an easier way around
it at this time or, for that matter, an explanation for why it happens.
</ol>

<p><hr>
Node:<a name="Running">Running</a>,
Next:<a rel=next href="#Files">Files</a>,
Previous:<a rel=previous href="#Linking">Linking</a>,
Up:<a rel=up href="#Frequently%20asked%20questions">Frequently asked questions</a>
<br>

<h2>I.4 Running</h2>

<ol type=1 start=1>
</p><li>I've just linked and run my program with the mpatrol library, but the resulting
log file doesn't contain any useful information.  Why does it not contain a list
of all memory transactions or show any unfreed memory allocations?

<p>By default, the mpatrol library will only write a summary of library settings
and statistics to the log file, and that will only occur on successful program
termination (i.e. when <code>exit()</code> is called).  If this does not appear then
it is likely that your program (or some other library function) called
<code>abort()</code> due to a fatal error.  However, there are a multitude of
different options that you can pass to the mpatrol library via the
<code>MPATROL_OPTIONS</code> environment variable that will allow you to control what
is logged and what is not.  Note that the <code>mpatrol</code> command will always
log all calls to allocate, reallocate and free memory by default.

</p><li>I linked my program with the mpatrol library to trace all of its memory
operations, such as <code>memcpy()</code> and <code>memcmp()</code>, but I get nothing in
the log file.  Why is this?

<p>On systems that do not support <code>.init</code> and <code>.fini</code> sections or are
not <code>gcc</code> or C++ based then the memory operation functions will not
automatically initialise the mpatrol library since on many systems the startup
routines call them very early on.  On such systems, if your program does not
call any memory allocation functions to initialise the mpatrol library then you
must explicitly call the <code>__mp_init()</code> function.  All memory operation
functions following that call with then be traced.

</p><li>Why does the <code>USEDEBUG</code> option not work for me?

<p>Firstly, you have to ensure that you have built the mpatrol library with support
for the GNU BFD object file access library by compiling with the
<code>FORMAT=FORMAT_BFD</code> preprocessor macro definition, or you are running on a
Windows platform.  Secondly, you have to ensure that you have compiled all
relevant object files with debugging information enabled (usually by adding an
option to the compiler command line), although the mpatrol library does not need
to be compiled this way.  The file and line number information will hopefully
then appear in the log file for all symbols that have associated debugging
information.  If none of the above suggestions work, you may still be able to
get this information with the <code>mpsym</code> command.

</p><li>Why does the <code>mpatrol</code> command ignore the current value of the
<code>MPATROL_OPTIONS</code> environment variable?

<p>Because I would most likely get lots of bug reports or queries from people who
had forgotten that they had set some options in the environment variable and had
then not seen the expected behaviour from the options they specified to the
<code>mpatrol</code> command.

</p><li>Why does the mpatrol library not read the symbols in my executable file on
Windows platforms?

<p>If the mpatrol library was compiled with the <code>FORMAT=FORMAT_PE</code>
preprocessor macro defined then you must ensure that you compile your files with
debugging information enabled (using the <code>-Z7</code> or <code>-Zi</code> options in
Visual C++) and that you tell the linker that you wish to preserve the debugging
information in the executable file (using the <code>-debug</code> and
<code>-pdb:none</code> options in the Microsoft linker).  Unfortunately, if you do
not do this then the final executable file will not have a symbol table and so
the mpatrol library cannot give symbolic stack tracebacks.

</p><li>Why do some mpatrol log file entries only contain a partial call stack rather
than following the function call stack back to the call to <code>main()</code>?

<p>This could be because the mpatrol library was compiled with limited call stack
traversal support via the <code>MP_BUILTINSTACK_SUPPORT</code> configuration macro. 
However, it could also mean that the mpatrol library encountered a corrupt frame
pointer when traversing the call stack and had to terminate the recursion.  The
frame pointer <em>must</em> be preserved from function to function on most
platforms, otherwise the stack cannot be traversed.  See your compiler manual
for further details.

</p><li>I am trying to use the <code>mpatrol</code> command to debug an executable file
that was not originally compiled with the mpatrol library.  However, even though
it runs successfully, no mpatrol log file is produced.  Why is this?

<p>First, check that you are passing the <code>--dynamic</code> option to the
<code>mpatrol</code> command and, if necessary, the <code>--threads</code> option as
well.  If that doesn't work then check that the executable file has been
dynamically linked; statically linked executables cannot be forced to use the
mpatrol library.  If it still doesn't work then it may be that the dynamic
linker on your system doesn't have the ability to preload any shared libraries
that have been specified in a special environment variable, in which case you
can't use this feature.

</p><li>I am attempting to run a multithreaded C++ program with the mpatrol library on
Linux.  However, my program crashes before <code>main()</code> and the debugger shows
that the failure is in <code>__sigaction()</code> which is called from
<code>__mp_initsignals()</code>.  Is the fault with the mpatrol library?

<p>There have been many reports of this problem and it turns out to be an issue
with shared library dependencies.  ELF shared libraries may contain
initialisation functions that are executed before <code>main()</code>.  However,
sometimes the order in which these functions are executed is critical.  In this
case it is likely that the mpatrol and pthreads libraries are being initialised
in the wrong order.  You must ensure that <code>-lpthread</code> appears near the
very end of the link line after all user libraries, and you must also ensure
that none of the user libraries have a dependency on <code>libpthread.so</code>.  You
can verify this by running the <code>ldd</code> command on them.

</p><li>I know that there's a definite heap corruption problem in my program as it keeps
crashing in unrelated code due to pointer corruption, and when I link with the
mpatrol library it stops crashing.  What can I do?

<p>Try as many of the relevant mpatrol run-time options as possible and make sure
that you closely examine the mpatrol log file for warnings and errors -- your
problem may have been noticed by the mpatrol library but it may not have
considered it a fatal error and continued execution.  If this still doesn't show
up anything then you can probably rest assured that you have a memory corruption
problem but you may need to use a commercial product such as Purify to isolate
it.  If that fails then you'll just have to employ the traditional debugging
method of single-stepping through your program in a debugger until something
unusual or unexpected happens.

</p><li>If I link my program to version 1.0 of the mpatrol library then I cannot
interrupt it using the keyboard, which I would normally be able to do without
using mpatrol.  Is this a bug?

<p>Not really, but it is undesirable behaviour in most cases, which is why it was
removed in later releases of mpatrol and replaced with the <code>SAFESIGNALS</code>
option.  The reason that the program could not be interrupted using the keyboard
was that mpatrol would ignore such signals when its library code was being
executed, otherwise user-defined signal handlers that used <code>malloc()</code> and
related functions would have the capability to cause lots of undesirable side
effects.  However, this does not normally happen, which is why the behaviour was
moved to an option for those that needed it.

</p><li>Why does mpatrol not report an illegal memory access when it can be detected by
a debugger?

<p>First of all, illegal memory accesses can only be detected on systems that
support virtual memory, so that precludes AmigaOS and Netware.  Secondly, it
might be possible that something is overriding the illegal memory access handler
that mpatrol sets up when it is first initialised.  If your program, or an
external library, sets up a signal handler that handles <code>SIGBUS</code> or
<code>SIGSEGV</code> (or their equivalent on Windows platforms) then mpatrol will no
longer be able to catch illegal memory accesses.  You can either try to live
with that, or you could try disabling the overriding handlers.

</p><li>I've linked and run my program with mpatrol under UNIX and it uses a large
amount of heap memory.  However, it crashes near the end of execution and then
proceeds to freeze up the whole system, sometimes requiring a reboot.  What am I
doing wrong?

<p>The most common possible explanation for this is that you are running your
program with too much access to system resources.  What is likely to be
happening is that when your program crashes the system attempts to dump the
entire process image to a core file for later debugging in a non-symbolic
debugger.  If the process has a huge heap then the core file is also going to be
huge, thus resulting in a massive file that may lead to the system thrashing
while it attempts to write it to the disk.  Technically, the system has not
frozen, but it is likely to take a long time to finish writing the file.  The
best solution involves setting your program's maximum core file size to a
reasonable limit (or just zero), and also possibly limiting your program's
maximum data segment size as well.  These can be set from the shell but the
exact details on how to do this differ between shells.

</p><li>Why does my program run so slowly after I link it with the mpatrol library?

<p>Normal malloc libraries are optimised for speed but will typically fall over at
the slightest hint of an error.  Debugging malloc libraries are written to
provide as much debugging information as possible whilst performing a multitude
of additional checks, which is why they may run much slower.  However, you can
control which checks are performed (and when) by using the <code>MPATROL_OPTIONS</code>
environment variable.  Performance may also be lost if you make lots of small
memory allocations rather than fewer larger allocations, but that is mainly due
to the overhead of storing the extra tracing details for each memory allocation.

</p><li>My program is written in C++ and is linked to the mpatrol library, but how do I
go about demangling the C++ symbol names that are shown in the stack tracebacks
in the resulting log file?

<p>Because there is no standard way of mangling C++ symbol names, various compilers
and operating systems have taken different approaches to C++ name mangling, many
of which differ significantly from the method suggested in <em>The Annotated
C++ Reference Manual</em> by Margaret Ellis and Bjarne Stroustrup.  However, most
compilers come with a demangling tool which can be used in a command pipe to
accept mangled names on its standard input file stream and demangle them on its
standard output file stream, and so can be used to process the mpatrol log file. 
Note that mpatrol automatically demangles C++ symbol names on Windows platforms
as Microsoft's name mangling is quite unreadable and would be hard to demangle
using a command line tool.

</p><li>Why does my program not stop when the mpatrol library notices an error?

<p>The library was written to give as much information as possible and so
sometimes, when a non-fatal error is discovered, the library will write the
error message to the log file and continue in the hope of being able to uncover
more errors during the execution of the program.  This means that you should
always check the number of warnings and errors given in the summary at the end
of program execution, and then search backwards in the log file for
<code>WARNING</code> or <code>ERROR</code>.

</p><li>I have linked my program with the mpatrol library on an Amiga or Netware
machine, but when it runs it still crashes the entire system.  Why is this?

<p>AmigaOS and Netware do not have virtual memory and so do not have memory
protection turned on by default.  This means that any rogue write to an
erroneous address may actually overwrite the data of another process or perhaps
even the operating system, thus bringing the entire machine down.  There are
several third-party system utilities available for the Amiga to add memory
protection to machines with built-in MMUs, which can then be used in conjunction
with mpatrol.  I'm not sure about the availability of such software for Netware.

</p><li>I have built the mpatrol library with <code>gcc</code> on AmigaOS and have
successfully linked it to my program.  However, why are none of the options in
the <code>MPATROL_OPTIONS</code> environment variable recognised when I run it?

<p>The <code>getenv()</code> function in the GNU C library is not compatible with the
AmigaDOS <code>SetEnv</code> and <code>GetEnv</code> commands since it does not treat
environment variables as files located in <code>ENV:</code> and is only compatible
with software that uses the ixemul library.  However, the <code>env</code> command
that comes with most GNU software distributions allows you to set an environment
variable that the GNU <code>getenv()</code> function can read when you are running in
AmigaDOS.

</p><li>How do I suppress all diagnostic output from the mpatrol library?

<p>You can do this by setting the mpatrol log file to be your system's <em>bit
bucket</em>, which is <code>/dev/null</code> on UNIX platforms and <code>NIL:</code> on AmigaOS. 
There doesn't appear to be an equivalent way to do this on Windows or Netware.
</ol>

<p><hr>
Node:<a name="Files">Files</a>,
Previous:<a rel=previous href="#Running">Running</a>,
Up:<a rel=up href="#Frequently%20asked%20questions">Frequently asked questions</a>
<br>

<h2>I.5 Files</h2>

<ol type=1 start=1>
</p><li>Why is there a <code>libmpatrol.o</code> target in the UNIX and Amiga
<code>Makefile</code>s?

<p>This is simply used to build the mpatrol library as one large object file for
full incorporation into other libraries and was used during the development of
mpatrol.  On UNIX platforms some linkers support the <code>-r</code> option for
combining many object files into one large object file, but this is not
universally supported, hence the reason for using the compiler instead.  Because
all of the source files are compiled at once, there may be conflicts with system
header files when <code>malloc()</code> and its related functions are being compiled,
which is why such an object file is not built by default.  In addition,
platforms which require the assembler routines in <code>machine.c</code> cannot build
the mpatrol library as one large object file from <code>library.c</code>.  Note that
the Windows and Netware <code>Makefile</code>s use <code>libmpatrol.obj</code>.

</p><li>What are the <code>CVS</code> subdirectories that come with the mpatrol distribution?

<p>CVS stands for Concurrent Versions System and is a project version control
system.  All of the source files that comprise an mpatrol release are stored in
a central CVS repository so that previous releases can be easily retrieved, but
the CVS system needs to have a way of determining the versions of currently
checked-out files, hence the <code>CVS</code> subdirectories.  You shouldn't need to
worry about them, so just ignore them.

</p><li>Why does the <code>mpsym</code> command not work for me?

<p>Firstly, you have to ensure that you have compiled all relevant object files
with debugging information enabled (usually by adding an option to the compiler
command line).  The file and line number information will hopefully then appear
in the log file for all symbols that have associated debugging information when
you run the <code>mpsym</code> command on the log file.  Alternatively, it could be
that your system does not have <code>gdb</code> or any of the required UNIX text
processing tools installed, in which case you might want to try installing them.

</p><li>How can I customise the <code>mpedit</code> command if I do not have the
appropriate permissions to edit the file that was installed on my system?

<p>You just need to take a copy of the installed <code>mpedit</code> command and place
it somewhere that will be picked up earlier on your command search path.  You
can then edit your copy of the file and add support for your favourite text
editor.

</p><li>What does the <code>mupdate</code> shell script do?

<p>This is for my use in order to automate every new release of mpatrol.  You
should never need to run this script and it should not be installed anywhere on
your system.  This script also uses and modifies the <code>VERSION</code> file and
updates the <code>NEWS</code> and <code>ChangeLog</code> files.
</ol>

<p><hr>
Node:<a name="Related%20software">Related software</a>,
Next:<a rel=next href="#References">References</a>,
Previous:<a rel=previous href="#Frequently%20asked%20questions">Frequently asked questions</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix J Related software</h1>

<p>The mpatrol library was designed to solve most common heap-related problems,
but there may be some cases where a different approach is needed, or a
commercial package is required.  I have attempted to provide an overview of
the different types of malloc libraries and memory debuggers available below,
along with a comprehensive list of related software.

<p>The most basic type of heap debugging system simply requires the redefinition
of <code>malloc()</code>, <code>realloc()</code> and <code>free()</code> (and related functions)
with debugging versions that record the file and line number at which
allocations occur.  This might require modifications to the source code in order
to call these new functions or it can be done through preprocessor macros which
will require all source files using the memory allocation functions to be
recompiled.  Such a system will most likely live on top of the existing system
malloc library, but will provide an additional layer with which to store more
information for debugging purposes.  MEM by Walter Bright is a good example of
this type of library.

<p>On many operating systems it is usually possible to write replacements for the
normal memory allocation routines and place them in a library so that they can
be linked in to override the system malloc library without requiring
recompilation of any source files.  Such malloc libraries must take control of
the heap directly and so usually contain more features, including being able to
track memory leaks and place fence posts around allocations.  Dbmalloc by Conor
P. Cahill and Dmalloc by Gray Watson are two of the most popular of these types
of libraries since they are available on a wide range of platforms.  Electric
Fence by Bruce Perens also makes use of the memory protection facilities found
in UNIX systems in order to force programs that access free or freed memory or
read or write beyond the bounds of a memory allocation to crash at the point
that the illegal memory access is made, rather than crashing at the next memory
allocation.

<p>For debugging all memory access errors (not just those on the heap) it is
necessary to modify (instrument) the machine code that is to be run so that each
individual load from memory and store to memory will be checked.  One method of
doing this is to modify the code produced by a compiler (such as is done by
Checker written by Tristan Gingold) but this has the disadvantage of only
working within the object files that have been produced by that compiler.  It is
also possible to modify the source code itself using source to source
translation (such as is done by Parasoft Insure++) or instrument all accesses to
memory in assembler source files (as performed by APurify written by Samuel
Devulder).  However, both of these methods suffer from the same drawback as
compiler-generated instrumentation.  Yet another alternative is to wait until
link-time and then instrument the individual object files and libraries before
they are linked into an executable file.  This is effectively what Purify from
Rational Software does, although Memory Advisor from PLATINUM Technology does
roughly the same except that it disassembles the object files into a
platform-independent format before instrumenting them.

<p>Rather than modifying a program in order to add debugging code, it is sometimes
possible to use a dedicated memory debugger in order to quickly catch any
problems.  ZeroFault from The Kernel Group debugs all memory-related operations
in a program while it is running, whilst AProbe from OC Systems allows users to
dynamically add probe modules at run-time in order to locate errors or perform
profiling.  If such a memory debugger is not available for your system, you may
still be able to dynamically link a malloc library into your application at
run-time if the operating system supports it.  NJAMD by Mike Perry makes
extensive use of this feature on some UNIX systems.  On operating systems that
do not support virtual memory but have hardware memory protection, it is
sometimes possible to trap memory errors before they bring down the whole
system.  On the Amiga, Enforcer by Michael Sinz runs in the background and
detects many common memory access errors in running applications, whilst on the
Macintosh, QC by Onyx Technology provides roughly the same functionality.

<p>A list of over seventy different items of software which help in debugging
dynamic memory allocation problems is given below<a rel=footnote href="#fn-46"><sup>46</sup></a>.  They all provide some of the features that
mpatrol contains and you may wish to use one of them to solve your problem if
you have trouble using mpatrol.  I have only ever used Dbmalloc, Dmalloc,
Electric Fence and Mprof, so I can't vouch for any of the others, although if
you have any recommendations feel free to let me know so I can add them to this
list.  In particular, there seems to be a shortage of such programs for Netware
platforms.

<ul>
<li>AProbe
<dl>
<dt>Author
<dd>OC Systems (<a href="mailto:info@ocsystems.com">info@ocsystems.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.aprobe.com/">http://www.aprobe.com/</a>
<br><dt>Overview
<dd>Instruments a program using Dynamic Action Linking in order to track down memory
corruption and monitor memory usage, among other things. 
</dl>

<li>APurify
<dl>
<dt>Author
<dd>Samuel Devulder (<a href="mailto:Samuel.Devulder@info.unicaen.fr">Samuel.Devulder@info.unicaen.fr</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html">http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html</a>
<br><dt>Overview
<dd>Instruments an assembler source file to insert code that checks all memory
accesses. 
</dl>

<li>BoundsChecker
<dl>
<dt>Author
<dd>NuMega Corporation (<a href="mailto:info@numega.com">info@numega.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Windows, MS-DOS
<br><dt>Location
<dd><a href="http://www.numega.com/">http://www.numega.com/</a>
<br><dt>Overview
<dd>Detects and diagnoses errors in static, stack and heap memory and in memory and
resource leaks. 
</dl>

<li>Ccmalloc
<dl>
<dt>Author
<dd>Armin Biere (<a href="mailto:biere@inf.ethz.ch">biere@inf.ethz.ch</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.inf.ethz.ch/personal/biere/projects/ccmalloc/">http://www.inf.ethz.ch/personal/biere/projects/ccmalloc/</a>
<br><dt>Overview
<dd>Can interface with <code>gdb</code> to find memory leaks, multiple deallocations
and memory corruptions in C or C++ programs. 
</dl>

<li>Chaperon
<dl>
<dt>Author
<dd>John Reiser (<a href="mailto:jreiser@BitWagon.com">jreiser@BitWagon.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://www.bitwagon.com/chaperon.html">http://www.bitwagon.com/chaperon.html</a>
<br><dt>Overview
<dd>Runs existing Intel Linux binary application programs, but checks for and
reports bad behaviour in accessing memory. 
</dl>

<li>Checker
<dl>
<dt>Author
<dd>Tristan Gingold (<a href="mailto:bug-checker@gnu.org">bug-checker@gnu.org</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.gnu.org/software/checker/checker.html">http://www.gnu.org/software/checker/checker.html</a>
<br><dt>Overview
<dd>Detects illegal memory accesses when reading from uninitialised memory, writing
to freed memory or outside memory blocks.  Also contains a garbage collector for
detecting memory leaks. 
</dl>

<li>CMEM
<dl>
<dt>Author
<dd>Brett Hunsaker (<a href="mailto:hunsaker@eisner.decus.org">hunsaker@eisner.decus.org</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>VMS
<br><dt>Location
<dd><a href="http://www.openvms.compaq.com/freeware/CMEM/">http://www.openvms.compaq.com/freeware/CMEM/</a>
<br><dt>Overview
<dd>Provides debugging versions of the C run-time library memory allocation
routines, with support for stack tracebacks and page protection. 
</dl>

<li>CSRI malloc
<dl>
<dt>Author
<dd>Mark Moraes (<a href="mailto:moraes@deshaw.com">moraes@deshaw.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="ftp://ftp.cs.toronto.edu/pub/moraes/malloc.tar.gz">ftp://ftp.cs.toronto.edu/pub/moraes/malloc.tar.gz</a>
<br><dt>Overview
<dd>A library of dynamic memory allocation functions with limited debugging and
profiling support and detection of memory leaks.  Also comes with a graphical
tool to display a dynamic picture of the heap. 
</dl>

<li>Dbmalloc
<dl>
<dt>Author
<dd>Conor P. Cahill (<a href="mailto:cpcahil@virtech.vti.com">cpcahil@virtech.vti.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://dickey.his.com/dbmalloc/dbmalloc.html">http://dickey.his.com/dbmalloc/dbmalloc.html</a>
<br><dt>Overview
<dd>Provides replacements for memory management library functions and provides a
full set of debugging features which detect memory overruns and other types of
misuse. 
</dl>

<li>Dbmalloc
<dl>
<dt>Author
<dd>Michael McTernan (<a href="mailto:mm7323@bris.ac.uk">mm7323@bris.ac.uk</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.cs.bris.ac.uk/~mm7323/DbMalloc/">http://www.cs.bris.ac.uk/~mm7323/DbMalloc/</a>
<br><dt>Overview
<dd>A drop-in replacement for the C memory allocation functions, providing
facilities for quickly finding memory leaks. 
</dl>

<li>Debauch
<dl>
<dt>Author
<dd>Jon A. Christopher (<a href="mailto:jac8792@tamu.edu">jac8792@tamu.edu</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://mackerel.tamu.edu/jon/gnu/">http://mackerel.tamu.edu/jon/gnu/</a>
<br><dt>Overview
<dd>A memory allocation debugger for C which will detect memory leaks, corrupted
memory, stores to freed memory and more. 
</dl>

<li>Debug Heap
<dl>
<dt>Author
<dd>IBM Corporation (<a href="mailto:info@ibm.com">info@ibm.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>IBM AS/400
<br><dt>Location
<dd><a href="http://www.as400.ibm.com/developer/porting/heapexternal.html">http://www.as400.ibm.com/developer/porting/heapexternal.html</a>
<br><dt>Overview
<dd>A heap debugging environment with stack traceback for IBM AS/400 servers. 
</dl>

<li>Dmalloc
<dl>
<dt>Author
<dd>Gray Watson (<a href="mailto:gray@burger.letters.com">gray@burger.letters.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX, Windows, MS-DOS
<br><dt>Location
<dd><a href="http://www.dmalloc.com/">http://www.dmalloc.com/</a>
<br><dt>Overview
<dd>A drop-in replacement for the system's memory management routines, providing
powerful debugging facilities configurable at run-time.  Formerly known as
Malloc_Dbg. 
</dl>

<li>Electric Fence
<dl>
<dt>Author
<dd>Bruce Perens (<a href="mailto:bruce@pixar.com">bruce@pixar.com</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="ftp://ftp.perens.com/pub/ElectricFence/">ftp://ftp.perens.com/pub/ElectricFence/</a>
<br><dt>Overview
<dd>Uses virtual memory hardware to protect dynamically allocated memory in order to
detect illegal memory accesses. 
</dl>

<li>Enforcer
<dl>
<dt>Author
<dd>Michael Sinz (<a href="mailto:Enforcer@sinz.org">Enforcer@sinz.org</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://www.iam.com/amiga/enforcer.html">http://www.iam.com/amiga/enforcer.html</a>
<br><dt>Overview
<dd>Sets up MMU tables to watch for illegal accesses to memory, such as the low page
and non-existent pages. 
</dl>

<li>FDA (Free Debug Allocator)
<dl>
<dt>Author
<dd>Thomas Helvey (<a href="mailto:tomh@inxpress.net">tomh@inxpress.net</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux, Windows
<br><dt>Location
<dd><a href="http://www.debian.org/Packages/unstable/devel/fda.html">http://www.debian.org/Packages/unstable/devel/fda.html</a>
<br><dt>Overview
<dd>Provides routines that can be plugged in to replace <code>malloc()</code>,
<code>calloc()</code>, <code>realloc()</code> and <code>free()</code>. 
</dl>

<li>Fortify
<dl>
<dt>Author
<dd>Simon Bullen (<a href="mailto:sbullen@cybergraphic.com.au">sbullen@cybergraphic.com.au</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://www.geocities.com/SiliconValley/Horizon/8596/fortify.html">http://www.geocities.com/SiliconValley/Horizon/8596/fortify.html</a>
<br><dt>Overview
<dd>Provides a fortified shell for memory allocations, trapping memory leaks,
writes beyond and before memory blocks and writes to freed memory. 
</dl>

<li>GC (Garbage Collector)
<dl>
<dt>Author
<dd>Hans-J. Boehm (<a href="mailto:boehm@acm.org">boehm@acm.org</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX, AmigaOS, Windows, MS-DOS, MacOS
<br><dt>Location
<dd><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">http://www.hpl.hp.com/personal/Hans_Boehm/gc/</a>
<br><dt>Overview
<dd>A general-purpose, garbage-collecting storage allocator that is intended to be
used as a plug-in replacement for <code>malloc()</code>, but can also be used to
detect memory leaks. 
</dl>

<li>GlowCode
<dl>
<dt>Author
<dd>Electric Software, Inc. (<a href="mailto:info@glowcode.com">info@glowcode.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Windows
<br><dt>Location
<dd><a href="http://www.glowcode.com/">http://www.glowcode.com/</a>
<br><dt>Overview
<dd>Provides a profiler, call coverage tool and resource browser which can detail
memory leaks. 
</dl>

<li>Great Circle
<dl>
<dt>Author
<dd>Geodesic Systems (<a href="mailto:info@geodesic.com">info@geodesic.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.geodesic.com/">http://www.geodesic.com/</a>
<br><dt>Overview
<dd>Provides complete heap profiling, allowing programmers to see what parts of a
program are using the most memory with symbolic stack tracing. 
</dl>

<li>HeapAgent
<dl>
<dt>Author
<dd>MicroQuill (<a href="mailto:info@microquill.com">info@microquill.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Windows
<br><dt>Location
<dd><a href="http://www.microquill.com/">http://www.microquill.com/</a>
<br><dt>Overview
<dd>Instruments the heap to provide heap error detection without the need to
recompile any source code. 
</dl>

<li>HeapCheck
<dl>
<dt>Author
<dd>Thanassis Tsiodras (<a href="mailto:ttsiod@softlab.ntua.gr">ttsiod@softlab.ntua.gr</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Windows
<br><dt>Location
<dd><a href="http://www.image.ece.ntua.gr/~ttsiod/HeapCheck.html">http://www.image.ece.ntua.gr/~ttsiod/HeapCheck.html</a>
<br><dt>Overview
<dd>A debugging memory allocator that can detect invalid read/write accesses to heap
memory, and also detects memory leaks. 
</dl>

<li>HeapManager
<dl>
<dt>Author
<dd>Andrew Wulf (<a href="mailto:heapmanager@biit.com">heapmanager@biit.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>MacOS
<br><dt>Location
<dd><a href="http://www.biit.com/">http://www.biit.com/</a>
<br><dt>Overview
<dd>Provides a general-purpose dynamic memory allocation debugging package with
symbolic stack traceback. 
</dl>

<li>Insure++
<dl>
<dt>Author
<dd>ParaSoft (<a href="mailto:info@parasoft.com">info@parasoft.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.parasoft.com/">http://www.parasoft.com/</a>
<br><dt>Overview
<dd>Uses Source Code Instrumentation and Runtime Pointer Tracking technologies to
pinpoint memory corruption, memory leaks, operations on unrelated pointers and
more.  The Inuse graphical memory usage display tool is also provided with this
software. 
</dl>

<li>JMalloc
<dl>
<dt>Author
<dd>Jeff Dunlop
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Windows, MS-DOS
<br><dt>Location
<dd><a href="http://www.snippets.org/">http://www.snippets.org/</a>
<br><dt>Overview
<dd>Provides tracing and debugging for <code>malloc()</code> and <code>operator new</code>. 
</dl>

<li>JProbe
<dl>
<dt>Author
<dd>KL Group (<a href="mailto:info@klgroup.com">info@klgroup.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.klgroup.com/">http://www.klgroup.com/</a>
<br><dt>Overview
<dd>Helps pinpoint memory leaks in Java applications by tracking which objects
hold references to other objects, and allows visualisation of memory usage in
real-time. 
</dl>

<li>Leak
<dl>
<dt>Author
<dd>Christopher Phillips (<a href="mailto:pefv700@hermes.chpc.utexas.edu">pefv700@hermes.chpc.utexas.edu</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://sources.isc.org/devel/memleak/leak.txt">http://sources.isc.org/devel/memleak/leak.txt</a>
<br><dt>Overview
<dd>Logs all calls to <code>malloc()</code> and related functions to database files with
the filename and line number, then attempts to validate reallocations and
deallocations and detect memory leaks. 
</dl>

<li>Leakers
<dl>
<dt>Author
<dd>Gabriel M. Deal (<a href="mailto:gmd@yellowleaf.org">gmd@yellowleaf.org</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.yellowleaf.org/gmd/software/leakers/">http://www.yellowleaf.org/gmd/software/leakers/</a>
<br><dt>Overview
<dd>Detects memory allocation errors by writing a log file and then examining it
for memory leaks and attempts to free memory multiple times. 
</dl>

<li>LeakTracer
<dl>
<dt>Author
<dd>Erwin Andreasen (<a href="mailto:erwin@andreasen.org">erwin@andreasen.org</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.andreasen.org/LeakTracer/">http://www.andreasen.org/LeakTracer/</a>
<br><dt>Overview
<dd>Detects memory leaks in C++ programs by overriding <code>operator new</code> and
<code>operator delete</code>. 
</dl>

<li>Leaky
<dl>
<dt>Author
<dd>Kipp Hickman (<a href="mailto:kipp@netscape.com">kipp@netscape.com</a>)
<br><dt>License
<dd>Netscape Public License
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://www.mozilla.org/unix/leaky.html">http://www.mozilla.org/unix/leaky.html</a>
<br><dt>Overview
<dd>A program which helps find memory leaks and helps debug reference count problems
with xpcom objects. 
</dl>

<li>LibKmalloc
<dl>
<dt>Author
<dd>Akira Higuchi (<a href="mailto:a@kondara.org">a@kondara.org</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://www.kondara.org/~a/libkmalloc.html">http://www.kondara.org/~a/libkmalloc.html</a>
<br><dt>Overview
<dd>A tiny malloc debugger which detects multiple frees and buffer overruns and
underruns. 
</dl>

<li>LibSafe
<dl>
<dt>Author
<dd>AT&amp;T Bell Labs (<a href="mailto:libsafe@research.bell-labs.com">libsafe@research.bell-labs.com</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://www.bell-labs.com/org/11356/libsafe.html">http://www.bell-labs.com/org/11356/libsafe.html</a>
<br><dt>Overview
<dd>Protects a process against the exploitation of buffer overflow vulnerabilities
in process stacks. 
</dl>

<li>Malloc Debug
<dl>
<dt>Author
<dd>Brandon S. Allbery <a href="mailto:allbery@ncoast.org">allbery@ncoast.org</a>
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.leo.org/pub/comp/usenet/comp.sources.misc/malloc-debug/">http://www.leo.org/pub/comp/usenet/comp.sources.misc/malloc-debug/</a>
<br><dt>Overview
<dd>A debugging malloc package with stack traceback capability. 
</dl>

<li>Malloc Debug Library
<dl>
<dt>Author
<dd>Rammi (<a href="mailto:rammi@quincunx.escape.de">rammi@quincunx.escape.de</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.escape.de/users/quincunx/rmdebug.html">http://www.escape.de/users/quincunx/rmdebug.html</a>
<br><dt>Overview
<dd>Implements wrappers for the normal heap handling functions. 
</dl>

<li>MallocTrace
<dl>
<dt>Author
<dd>Mark Brader (<a href="mailto:msb@sq.sq.com">msb@sq.sq.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="ftp://ftp.uu.net/usenet/comp.sources.unix/volume18/malloc-trace.Z">ftp://ftp.uu.net/usenet/comp.sources.unix/volume18/malloc-trace.Z</a>
<br><dt>Overview
<dd>A malloc package with call stack tracebacks. 
</dl>

<li>MalTrace
<dl>
<dt>Author
<dd>Michael Schwartz (<a href="mailto:schwartz@cs.washington.edu">schwartz@cs.washington.edu</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.mit.edu/afs/sipb/user/tytso/News/maltrace">http://www.mit.edu/afs/sipb/user/tytso/News/maltrace</a>
<br><dt>Overview
<dd>Traces all calls to <code>malloc()</code> and <code>free()</code> in order to detect memory
leaks. 
</dl>

<li>MCheck
<dl>
<dt>Author
<dd>Ronald Veldema (<a href="mailto:rveldema@cs.vu.nl">rveldema@cs.vu.nl</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://www.cs.vu.nl/~rveldema/mcheck/mcheck.html">http://www.cs.vu.nl/~rveldema/mcheck/mcheck.html</a>
<br><dt>Overview
<dd>A memory usage and malloc checker for C and C++.  Comes with a Java application
for browsing the trace files produced. 
</dl>

<li>MEM
<dl>
<dt>Author
<dd>Walter Bright
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>MS-DOS
<br><dt>Location
<dd><a href="http://www.snippets.org/">http://www.snippets.org/</a>
<br><dt>Overview
<dd>A set of functions for debugging pointer and memory allocation problems. 
</dl>

<li>MemCheck
<dl>
<dt>Author
<dd>Stratosware Corporation (<a href="mailto:info@stratosware.com">info@stratosware.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Windows
<br><dt>Location
<dd><a href="http://www.stratosware.com/">http://www.stratosware.com/</a>
<br><dt>Overview
<dd>Detects various run-time errors related to operating system resources and
provides information on memory leaks. 
</dl>

<li>MemDebug
<dl>
<dt>Author
<dd>Rene Schmit (<a href="mailto:rene.schmit@bss.lu">rene.schmit@bss.lu</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX, Windows, MS-DOS, MacOS
<br><dt>Location
<dd><a href="http://www.bss.lu/Memdebug/Memdebug.html">http://www.bss.lu/Memdebug/Memdebug.html</a>
<br><dt>Overview
<dd>Provides memory management error detection, memory usage error detection, memory
usage profiling and error simulation. 
</dl>

<li>MemLeak
<dl>
<dt>Author
<dd>Keith Packard (<a href="mailto:keithp@ncd.com">keithp@ncd.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="ftp://ftp.x.org/pub/R6.4/xc/util/memleak/">ftp://ftp.x.org/pub/R6.4/xc/util/memleak/</a>
<br><dt>Overview
<dd>Replaces the C library allocation functions and provides extensive memory
checking, locating lost memory, detecting free memory still in use and stores
to free memory along with stack tracebacks. 
</dl>

<li>Memory Advisor
<dl>
<dt>Author
<dd>PLATINUM Technology (<a href="mailto:info@platinum.com">info@platinum.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.platinum.com/">http://www.platinum.com/</a>
<br><dt>Overview
<dd>Disassembles an object module into system-independent assembler code, inserts
error checking instructions, then re-assembles the code.  Can also replace
existing malloc libraries in order to provide greater error checking.  Formerly
known as Sentinel. 
</dl>

<li>Memory Sleuth
<dl>
<dt>Author
<dd>TurboPower (<a href="mailto:info@turbopower.com">info@turbopower.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Windows
<br><dt>Location
<dd><a href="http://www.turbopower.com/">http://www.turbopower.com/</a>
<br><dt>Overview
<dd>Quickly tracks down memory leaks and resource allocation errors with C++Builder
and Delphi. 
</dl>

<li>Memprof
<dl>
<dt>Author
<dd>Owen Taylor (<a href="mailto:otaylor@redhat.com">otaylor@redhat.com</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://people.redhat.com/otaylor/memprof/">http://people.redhat.com/otaylor/memprof/</a>
<br><dt>Overview
<dd>A tool for profiling memory usage and detecting memory leaks. 
</dl>

<li>Memproof
<dl>
<dt>Author
<dd>AutomatedQA (<a href="mailto:info@totalqa.com">info@totalqa.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Windows
<br><dt>Location
<dd><a href="http://www.totalqa.com/">http://www.totalqa.com/</a>
<br><dt>Overview
<dd>A memory and resource leak debugger for Borland's family of Windows compilers. 
</dl>

<li>MemTrace
<dl>
<dt>Author
<dd>Nico Hoogervorst (<a href="mailto:nico@knoware.nl">nico@knoware.nl</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Windows
<br><dt>Location
<dd><a href="http://utopia.knoware.nl/users/nico/tools/c/memtrace/">http://utopia.knoware.nl/users/nico/tools/c/memtrace/</a>
<br><dt>Overview
<dd>A simple enhancement for C source code which makes it easier to find memory
leaks. 
</dl>

<li>MemWatch
<dl>
<dt>Author
<dd>Johan Lindh (<a href="mailto:johan@link-data.com">johan@link-data.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.link-data.com/">http://www.link-data.com/</a>
<br><dt>Overview
<dd>A fault-tolerant memory leak and corruption detection tool. 
</dl>

<li>MemWatch
<dl>
<dt>Author
<dd>Doug Walker (<a href="mailto:walker@unx.sas.com">walker@unx.sas.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html">http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html</a>
<br><dt>Overview
<dd>Provides replacement memory allocation routines for adding lots of memory
debugging features that you link into your program. 
</dl>

<li>MM (Shared Memory Library)
<dl>
<dt>Author
<dd>Ralf S. Engelschall (<a href="mailto:rse@engelschall.com">rse@engelschall.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.engelschall.com/sw/mm/">http://www.engelschall.com/sw/mm/</a>
<br><dt>Overview
<dd>Simplifies the usage (and can help debug) the use of shared memory between
related processes. 
</dl>

<li>MM
<dl>
<dt>Author
<dd>Dave Clements (<a href="mailto:clements@cs.uoregon.edu">clements@cs.uoregon.edu</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.cirl.uoregon.edu/clements/memoryManager.html">http://www.cirl.uoregon.edu/clements/memoryManager.html</a>
<br><dt>Overview
<dd>Overrides the C dynamic memory allocation functions to provide better debugging
capabilities. 
</dl>

<li>Mmalloc
<dl>
<dt>Author
<dd>Mike Haertel (<a href="mailto:mike@ai.mit.edu">mike@ai.mit.edu</a>) and Fred Fish (<a href="mailto:fnf@cygnus.com">fnf@cygnus.com</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.gnu.org/">http://www.gnu.org/</a>
<br><dt>Overview
<dd>Uses <code>mmap()</code> to allocate separate pools of memory which can be mapped onto
files for later reuse. 
</dl>

<li>MPR
<dl>
<dt>Author
<dd>Taj Khattra (<a href="mailto:taj.khattra@pobox.com">taj.khattra@pobox.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://metalab.unc.edu/pub/Linux/devel/lang/c/mpr-2.0.tar.gz">http://metalab.unc.edu/pub/Linux/devel/lang/c/mpr-2.0.tar.gz</a>
<br><dt>Overview
<dd>Attempts to find memory leaks in C/C++ programs by writing a log file during
program execution, which can then be processed for obtaining further
information. 
</dl>

<li>Mprof
<dl>
<dt>Author
<dd>Ben Zorn (<a href="mailto:zorn@microsoft.com">zorn@microsoft.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="ftp://gatekeeper.dec.com/pub/misc/mprof-3.0.tar.Z">ftp://gatekeeper.dec.com/pub/misc/mprof-3.0.tar.Z</a>
<br><dt>Overview
<dd>Profiles the dynamic memory allocation behaviour of programs by logging details
for each function than makes a memory allocation, including call stack
tracebacks. 
</dl>

<li>MSS (Memory Supervision System)
<dl>
<dt>Author
<dd>Juan Jesus Alcolea Picazo (<a href="mailto:a920101@zipi.fi.upm.es">a920101@zipi.fi.upm.es</a>) and
Peter Palotas (<a href="mailto:blizzar@hem1.passagen.se">blizzar@hem1.passagen.se</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux, Windows, MS-DOS
<br><dt>Location
<dd><a href="http://hem.passagen.se/blizzar/mss/">http://hem.passagen.se/blizzar/mss/</a>
<br><dt>Overview
<dd>Full-featured malloc library for C and C++ providing detection of memory leaks,
use of uninitialised memory and out of range block accesses as well as lots of
tracing facilities. 
</dl>

<li>MuForce
<dl>
<dt>Author
<dd>Thomas Richter (<a href="mailto:thor@einstein.math.tu-berlin.de">thor@einstein.math.tu-berlin.de</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://www.math.tu-berlin.de/~thor/thor/index.html">http://www.math.tu-berlin.de/~thor/thor/index.html</a>
<br><dt>Overview
<dd>Uses the MMU to monitor the system for any writes to non-existent memory and
reports them over the serial port or any other output stream. 
</dl>

<li>MuGuardianAngel
<dl>
<dt>Author
<dd>Thomas Richter (<a href="mailto:thor@einstein.math.tu-berlin.de">thor@einstein.math.tu-berlin.de</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://www.math.tu-berlin.de/~thor/thor/index.html">http://www.math.tu-berlin.de/~thor/thor/index.html</a>
<br><dt>Overview
<dd>An extension to the MuForce program which protects free memory and detects all
illegal memory accesses. 
</dl>

<li>MuLib
<dl>
<dt>Author
<dd>Thomas Richter (<a href="mailto:thor@einstein.math.tu-berlin.de">thor@einstein.math.tu-berlin.de</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://www.math.tu-berlin.de/~thor/thor/index.html">http://www.math.tu-berlin.de/~thor/thor/index.html</a>
<br><dt>Overview
<dd>Provides access to the MMU in modern Amigas so that features such as virtual
memory can be implemented. 
</dl>

<li>MULTI
<dl>
<dt>Author
<dd>Green Hills Software, Inc. (<a href="mailto:sales@ghs.com">sales@ghs.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.ghs.com">http://www.ghs.com</a>
<br><dt>Overview
<dd>Inserts special checks into a program to watch for and report a broad variety
of run-time errors, including freeing unallocated memory and memory leaks. 
</dl>

<li>Mungwall
<dl>
<dt>Author
<dd>Commodore-Amiga, Inc. (<a href="mailto:info@amiga.de">info@amiga.de</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html">http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html</a>
<br><dt>Overview
<dd>Patches the system to check for free memory corruption. 
</dl>

<li>NJAMD (Not Just Another Malloc Debugger)
<dl>
<dt>Author
<dd>Mike Perry (<a href="mailto:mikepery@fscked.org">mikepery@fscked.org</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://fscked.org/proj/njamd.shtml/">http://fscked.org/proj/njamd.shtml/</a>
<br><dt>Overview
<dd>Helps track down a wide range of memory allocation problems and is divided
into a front end executable and a library back end. 
</dl>

<li>ObjectCenter
<dl>
<dt>Author
<dd>CenterLine Development Systems (<a href="mailto:info@centerline.com">info@centerline.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.centerline.com/">http://www.centerline.com/</a>
<br><dt>Overview
<dd>Provides a C and C++ programming environment that can detect memory leaks,
duplicate frees and illegal access errors including loads from uninitialised
objects. 
</dl>

<li>Optimizeit
<dl>
<dt>Author
<dd>Intuitive Systems, Inc. (<a href="mailto:info@optimizeit.com">info@optimizeit.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.optimizeit.com/">http://www.optimizeit.com/</a>
<br><dt>Overview
<dd>Attempts to locate memory leaks and performance bottlenecks in Java programs. 
</dl>

<li>Plumber
<dl>
<dt>Author
<dd>Owen O'Malley (<a href="mailto:omalley@ics.uci.edu">omalley@ics.uci.edu</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux, Solaris, SunOS
<br><dt>Location
<dd><a href="http://www.ics.uci.edu/~softtest/plumber.html">http://www.ics.uci.edu/~softtest/plumber.html</a>
<br><dt>Overview
<dd>A tool that replaces the normal Ada and C/C++ dynamic memory allocation
functions and detects unfreed memory blocks. 
</dl>

<li>Purify
<dl>
<dt>Author
<dd>Rational Software (<a href="mailto:info@rational.com">info@rational.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://www.rational.com/">http://www.rational.com/</a>
<br><dt>Overview
<dd>Uses Object Code Insertion technology to provide run-time error checking and
memory leak detection. 
</dl>

<li>QC
<dl>
<dt>Author
<dd>Onyx Technology (<a href="mailto:sales@onyx-tech.com">sales@onyx-tech.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>MacOS
<br><dt>Location
<dd><a href="http://www.onyx-tech.com/">http://www.onyx-tech.com/</a>
<br><dt>Overview
<dd>Runs in the background as a control panel and detects various memory errors
which can then be caught and run under a debugger. 
</dl>

<li>SmartAlloc
<dl>
<dt>Author
<dd>John Walker
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX, MS-DOS
<br><dt>Location
<dd><a href="http://www.fourmilab.ch/smartall/">http://www.fourmilab.ch/smartall/</a>
<br><dt>Overview
<dd>Detects orphaned buffers of dynamic memory allocations and also helps to find
other common problems in management of dynamic storage. 
</dl>

<li>SmartHeap
<dl>
<dt>Author
<dd>MicroQuill (<a href="mailto:info@microquill.com">info@microquill.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX, Windows, OS/2, MS-DOS, MacOS
<br><dt>Location
<dd><a href="http://www.microquill.com/">http://www.microquill.com/</a>
<br><dt>Overview
<dd>Provides optimised heap performance along with detecting memory leaks, memory
overwrites, double-freeing, wild pointers, invalid parameters, etc. 
</dl>

<li>Spotlight
<dl>
<dt>Author
<dd>Onyx Technology (<a href="mailto:sales@onyx-tech.com">sales@onyx-tech.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>MacOS
<br><dt>Location
<dd><a href="http://www.onyx-tech.com/">http://www.onyx-tech.com/</a>
<br><dt>Overview
<dd>Performs memory protection on PowerPC executables and helps detect memory leaks. 
</dl>

<li>StackTrace
<dl>
<dt>Author
<dd>Bjorn Reese (<a href="mailto:breese@mail1.stofanet.dk">breese@mail1.stofanet.dk</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://home1.stofanet.dk/breese/debug/debug.tar.gz">http://home1.stofanet.dk/breese/debug/debug.tar.gz</a>
<br><dt>Overview
<dd>Provides code to generate a stack trace of the program at any point during
execution using either a debugger or built-in methods found in the GNU C
compiler or on some systems. 
</dl>

<li>TestCenter
<dl>
<dt>Author
<dd>CenterLine Development Systems (<a href="mailto:info@centerline.com">info@centerline.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Various UNIX
<br><dt>Location
<dd><a href="http://www.centerline.com/">http://www.centerline.com/</a>
<br><dt>Overview
<dd>Detects memory leaks, duplicate frees and illegal access errors including loads
from uninitialised objects. 
</dl>

<li>Third Degree
<dl>
<dt>Author
<dd>Digital Equipment Corporation (<a href="mailto:info@digital.com">info@digital.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>Digital UNIX
<br><dt>Location
<dd><a href="http://www.digital.com/">http://www.digital.com/</a>
<br><dt>Overview
<dd>A tool that performs memory access checks and memory leak detection of C, C++
and Fortran programs at run-time.  Applications are modified using ATOM to
determine if any memory locations are accessed when not properly allocated or
initialised. 
</dl>

<li>Vmalloc
<dl>
<dt>Author
<dd>Kiem-Phong Vo (<a href="mailto:kpv@research.att.com">kpv@research.att.com</a>)
<br><dt>License
<dd>AT&amp;T Source Code License
<br><dt>Platforms
<dd>Various UNIX, Windows
<br><dt>Location
<dd><a href="http://akpublic.research.att.com/sw/tools/vmalloc/">http://akpublic.research.att.com/sw/tools/vmalloc/</a>
<br><dt>Overview
<dd>A discipline and method library for dynamic memory allocation, with support for
regions, debugging and profiling. 
</dl>

<li>Wipeout
<dl>
<dt>Author
<dd>Olaf Barthel (<a href="mailto:olsen@sourcery.han.de">olsen@sourcery.han.de</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>AmigaOS
<br><dt>Location
<dd><a href="http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html">http://wuarchive.wustl.edu/~aminet/dirs/dev_debug.html</a>
<br><dt>Overview
<dd>Runs in the background checking free memory for corruption. 
</dl>

<li>YaMa
<dl>
<dt>Author
<dd>Venkatesha Murthy G. (<a href="mailto:gvmt@vsnl.com">gvmt@vsnl.com</a>)
<br><dt>License
<dd>Free Software
<br><dt>Platforms
<dd>Linux
<br><dt>Location
<dd><a href="http://www.geocities.com/ipsgvm/libyama/">http://www.geocities.com/ipsgvm/libyama/</a>
<br><dt>Overview
<dd>A memory allocator with leak tracing and some anti-heap corruption facilities. 
</dl>

<li>YAMD (Yet Another Malloc Debugger)
<dl>
<dt>Author
<dd>Nate Eldredge (<a href="mailto:neldredge@hmc.edu">neldredge@hmc.edu</a>)
<br><dt>License
<dd>GNU General Public License
<br><dt>Platforms
<dd>Linux, MS-DOS
<br><dt>Location
<dd><a href="http://www3.hmc.edu/~neldredge/yamd/">http://www3.hmc.edu/~neldredge/yamd/</a>
<br><dt>Overview
<dd>A tool for finding bugs related to dynamic memory allocation in C and C++, and
includes paging mechanisms to catch bugs immediately. 
</dl>

<li>ZeroFault
<dl>
<dt>Author
<dd>The Kernel Group (<a href="mailto:info@zerofault.com">info@zerofault.com</a>)
<br><dt>License
<dd>Commercial Software
<br><dt>Platforms
<dd>AIX UNIX
<br><dt>Location
<dd><a href="http://www.zerofault.com/">http://www.zerofault.com/</a>
<br><dt>Overview
<dd>Uses run-time emulator technology to provide run-time error checking and memory
leak detection. 
</dl>
</ul>

<p>However, before you try out any of the above software, there may already be a
malloc library with debugging support on your system that might be suitable for
solving your problem.  For example, on Solaris the following libraries are
available:

<dl>
<dt><cite>malloc(3c)</cite>
<dd>Trade-off between performance and efficiency. 
<br><dt><cite>malloc(3x)</cite>
<dd>Slower performance, space-efficient. 
<br><dt><cite>bsdmalloc(3x)</cite>
<dd>Better performance, space-inefficient. 
<br><dt><cite>mtmalloc(3t)</cite>
<dd>Thread-safe memory allocator. 
<br><dt><cite>mapmalloc(3x)</cite>
<dd>Uses <code>mmap()</code> instead of <code>sbrk()</code> to allocate heap space. 
<br><dt><cite>watchmalloc(3x)</cite>
<dd>Uses watch point areas to check for overflows. 
</dl>

<p>On platforms with the GNU C library, such as Linux, there are several
environment variables that can be used to enable various debugging features of
<code>malloc()</code>, etc.  There are also extra functions provided in the library
which can be used to aid in debugging, and some shell scripts which can
translate return addresses or locate unfreed memory allocations in the log files
produced.  Useful information on the debugging features available within the
GNU C library is located at <a href="http://sdb.suse.de/sdb/en/html/aj_debug.html">http://sdb.suse.de/sdb/en/html/aj_debug.html</a>.

<p><hr>
Node:<a name="References">References</a>,
Next:<a rel=next href="#Copying">Copying</a>,
Previous:<a rel=previous href="#Related%20software">Related software</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix K References</h1>

<p>This section contains references to interesting papers and resources on related
topics and the field of memory management in general.  The vast majority of
theoretical information can be found at the Memory Management Reference,
although this does tend to concentrate on garbage collection.  The other
references take a more practical approach to memory management and in some cases
provide implementation details.  Let me know if you'd like to see any other
references or resources added to this list.

<ul>
<li>Avoiding Motif Memory Leaks
<dl>
<dt>Author
<dd>Kenton Lee (<a href="mailto:kenton@rahul.net">kenton@rahul.net</a>)
<br><dt>Location
<dd><a href="http://www.rahul.net/kenton/txa/mar96.html">http://www.rahul.net/kenton/txa/mar96.html</a>
<br><dt>Overview
<dd>An article on avoiding memory leaks in Motif applications. 
</dl>

<li>Effective C++ Memory Allocation
<dl>
<dt>Author
<dd>Aaron Dailey (<a href="mailto:adailey@chaparraltec.com">adailey@chaparraltec.com</a>)
<br><dt>Location
<dd><a href="http://www.embedded.com/1999/9901/9901feat2.htm">http://www.embedded.com/1999/9901/9901feat2.htm</a>
<br><dt>Overview
<dd>Documents techniques for better use of the C++ dynamic memory allocation
operators. 
</dl>

<li>A Memory Allocator
<dl>
<dt>Author
<dd>Doug Lea (<a href="mailto:dl@gee.cs.oswego.edu">dl@gee.cs.oswego.edu</a>)
<br><dt>Location
<dd><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">http://gee.cs.oswego.edu/dl/html/malloc.html</a>
<br><dt>Overview
<dd>Information on general memory allocation principles. 
</dl>

<li>The Memory Management Reference
<dl>
<dt>Author
<dd>XANALYS Software Tools (<a href="mailto:mm-web@xanalys.com">mm-web@xanalys.com</a>)
<br><dt>Location
<dd><a href="http://www.xanalys.com/software_tools/mm/">http://www.xanalys.com/software_tools/mm/</a>
<br><dt>Overview
<dd>Links to many documents and research papers in the field of memory management,
and has a large glossary which lists and explains related terms. 
</dl>

<li>My Rant on C++'s <code>operator new</code>
<dl>
<dt>Author
<dd>David Mazieres (<a href="mailto:dm@cs.nyu.edu">dm@cs.nyu.edu</a>)
<br><dt>Location
<dd><a href="http://www.pdos.lcs.mit.edu/~dm/c++-new.html">http://www.pdos.lcs.mit.edu/~dm/c++-new.html</a>
<br><dt>Overview
<dd>Provides a scathing critique on the C++ dynamic memory allocation operators. 
</dl>

<li>The Virtual Memory Tutorial
<dl>
<dt>Author
<dd>The Hyperlearning Center (<a href="mailto:webmaster@cne.gmu.edu">webmaster@cne.gmu.edu</a>)
<br><dt>Location
<dd><a href="http://www.cne.gmu.edu/modules/vm/">http://www.cne.gmu.edu/modules/vm/</a>
<br><dt>Overview
<dd>Provides a comprehensive tutorial on virtual memory, as well as detailing its
history, theory and implementation. 
</dl>

<li>X Window System Memory Leaks and Other Memory Bugs
<dl>
<dt>Author
<dd>Kenton Lee (<a href="mailto:kenton@rahul.net">kenton@rahul.net</a>)
<br><dt>Location
<dd><a href="http://www.rahul.net/kenton/txa/feb96.html">http://www.rahul.net/kenton/txa/feb96.html</a>
<br><dt>Overview
<dd>An article on debugging memory problems in X applications. 
</dl>
</ul>

<p><hr>
Node:<a name="Copying">Copying</a>,
Next:<a rel=next href="#Function%20index">Function index</a>,
Previous:<a rel=previous href="#References">References</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Appendix L Copying</h1>

<pre>                  GNU LIBRARY GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1991 Free Software Foundation, Inc.
                59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the library GPL.  It is
 numbered 2 because it goes with version 2 of the ordinary GPL.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Library General Public License, applies to some
specially designated Free Software Foundation software, and to any
other libraries whose authors decide to use it.  You can use it for
your libraries, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if
you distribute copies of the library, or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link a program with the library, you must provide
complete object files to the recipients so that they can relink them
with the library, after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  Our method of protecting your rights has two steps: (1) copyright
the library, and (2) offer you this license which gives you legal
permission to copy, distribute and/or modify the library.

  Also, for each distributor's protection, we want to make certain
that everyone understands that there is no warranty for this free
library.  If the library is modified by someone else and passed on, we
want its recipients to know that what they have is not the original
version, so that any problems introduced by others will not reflect on
the original authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that companies distributing free
software will individually obtain patent licenses, thus in effect
transforming the program into proprietary software.  To prevent this,
we have made it clear that any patent must be licensed for everyone's
free use or not licensed at all.

  Most GNU software, including some libraries, is covered by the ordinary
GNU General Public License, which was designed for utility programs.  This
license, the GNU Library General Public License, applies to certain
designated libraries.  This license is quite different from the ordinary
one; be sure to read it in full, and don't assume that anything in it is
the same as in the ordinary license.

  The reason we have a separate public license for some libraries is that
they blur the distinction we usually make between modifying or adding to a
program and simply using it.  Linking a program with a library, without
changing the library, is in some sense simply using the library, and is
analogous to running a utility program or application program.  However, in
a textual and legal sense, the linked executable is a combined work, a
derivative of the original library, and the ordinary General Public License
treats it as such.

  Because of this blurred distinction, using the ordinary General
Public License for libraries did not effectively promote software
sharing, because most developers did not use the libraries.  We
concluded that weaker conditions might promote sharing better.

  However, unrestricted linking of non-free programs would deprive the
users of those programs of all benefit from the free status of the
libraries themselves.  This Library General Public License is intended to
permit developers of non-free programs to use free libraries, while
preserving your freedom as a user of such programs to change the free
libraries that are incorporated in them.  (We have not seen how to achieve
this as regards changes in header files, but we have achieved it as regards
changes in the actual functions of the Library.)  The hope is that this
will lead to faster development of free libraries.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, while the latter only
works together with the library.

  Note that it is possible for a library to be covered by the ordinary
General Public License rather than by this special one.

                  GNU LIBRARY GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library which
contains a notice placed by the copyright holder or other authorized
party saying it may be distributed under the terms of this Library
General Public License (also called "this License").  Each licensee is
addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also compile or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    c) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    d) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the source code distributed need not include anything that is normally
distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Library General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    &lt;one line to give the library's name and a brief idea of what it does.&gt;
    Copyright (C) &lt;year&gt;  &lt;name of author&gt;

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  &lt;signature of Ty Coon&gt;, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
</pre>

<p><hr>
Node:<a name="Function%20index">Function index</a>,
Next:<a rel=next href="#Index">Index</a>,
Previous:<a rel=previous href="#Copying">Copying</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Function index</h1>

<ul compact>
<li><code>__mp_check</code>: <a href="#Functions">Functions</a>
<li><code>__mp_epilogue</code>: <a href="#Functions">Functions</a>
<li><code>__mp_info</code>: <a href="#Functions">Functions</a>
<li><code>__mp_memorymap</code>: <a href="#Functions">Functions</a>
<li><code>__mp_nomemory</code>: <a href="#Functions">Functions</a>
<li><code>__mp_printinfo</code>: <a href="#Functions">Functions</a>
<li><code>__mp_prologue</code>: <a href="#Functions">Functions</a>
<li><code>__mp_summary</code>: <a href="#Functions">Functions</a>
<li><code>alloca</code>: <a href="#Functions">Functions</a>
<li><code>bcmp</code>: <a href="#Functions">Functions</a>
<li><code>bcopy</code>: <a href="#Functions">Functions</a>
<li><code>bzero</code>: <a href="#Functions">Functions</a>
<li><code>calloc</code>: <a href="#Functions">Functions</a>
<li><code>cfree</code>: <a href="#Functions">Functions</a>
<li><code>dealloca</code>: <a href="#Functions">Functions</a>
<li><code>expand</code>: <a href="#Functions">Functions</a>
<li><code>free</code>: <a href="#Functions">Functions</a>
<li><code>malloc</code>: <a href="#Functions">Functions</a>
<li><code>memalign</code>: <a href="#Functions">Functions</a>
<li><code>memccpy</code>: <a href="#Functions">Functions</a>
<li><code>memchr</code>: <a href="#Functions">Functions</a>
<li><code>memcmp</code>: <a href="#Functions">Functions</a>
<li><code>memcpy</code>: <a href="#Functions">Functions</a>
<li><code>memmem</code>: <a href="#Functions">Functions</a>
<li><code>memmove</code>: <a href="#Functions">Functions</a>
<li><code>memset</code>: <a href="#Functions">Functions</a>
<li><code>operator delete</code>: <a href="#Functions">Functions</a>
<li><code>operator delete[]</code>: <a href="#Functions">Functions</a>
<li><code>operator new</code>: <a href="#Functions">Functions</a>
<li><code>operator new[]</code>: <a href="#Functions">Functions</a>
<li><code>pvalloc</code>: <a href="#Functions">Functions</a>
<li><code>realloc</code>: <a href="#Functions">Functions</a>
<li><code>recalloc</code>: <a href="#Functions">Functions</a>
<li><code>set_new_handler</code>: <a href="#Functions">Functions</a>
<li><code>strdup</code>: <a href="#Functions">Functions</a>
<li><code>strdupa</code>: <a href="#Functions">Functions</a>
<li><code>strndup</code>: <a href="#Functions">Functions</a>
<li><code>strndupa</code>: <a href="#Functions">Functions</a>
<li><code>strnsave</code>: <a href="#Functions">Functions</a>
<li><code>strsave</code>: <a href="#Functions">Functions</a>
<li><code>valloc</code>: <a href="#Functions">Functions</a>
</ul>
<p><hr>
Node:<a name="Index">Index</a>,
Previous:<a rel=previous href="#Function%20index">Function index</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Index</h1>

<ul compact>
<li>-addresses: <a href="#Profiling">Profiling</a>
<li>-alloc-byte: <a href="#Options">Options</a>
<li>-alloc-stop: <a href="#Options">Options</a>
<li>-allow-oflow: <a href="#Options">Options</a>
<li>-auto-save: <a href="#Options">Options</a>
<li>-check: <a href="#Options">Options</a>
<li>-check-all: <a href="#Options">Options</a>
<li>-check-allocs: <a href="#Options">Options</a>
<li>-check-frees: <a href="#Options">Options</a>
<li>-check-memory: <a href="#Options">Options</a>
<li>-check-reallocs: <a href="#Options">Options</a>
<li>-counts: <a href="#Profiling">Profiling</a>
<li>-def-align: <a href="#Options">Options</a>
<li>-dynamic: <a href="#Options">Options</a>
<li>-edit: <a href="#Options">Options</a>
<li>-editor: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>-fail-freq: <a href="#Options">Options</a>
<li>-fail-seed: <a href="#Options">Options</a>
<li>-free-byte: <a href="#Options">Options</a>
<li>-free-stop: <a href="#Options">Options</a>
<li>-graph-file: <a href="#Profiling">Profiling</a>
<li>-help: <a href="#Options">Options</a>
<li>-ignore: <a href="#The%20mleak%20command">The mleak command</a>
<li>-large-bound: <a href="#Options">Options</a>
<li>-leaks: <a href="#Profiling">Profiling</a>
<li>-limit: <a href="#Options">Options</a>
<li>-list: <a href="#Options">Options</a>
<li>-listing: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>-log-all: <a href="#Options">Options</a>
<li>-log-allocs: <a href="#Options">Options</a>
<li>-log-file: <a href="#Options">Options</a>
<li>-log-frees: <a href="#Options">Options</a>
<li>-log-memory: <a href="#Options">Options</a>
<li>-log-reallocs: <a href="#Options">Options</a>
<li>-medium-bound: <a href="#Options">Options</a>
<li>-no-free: <a href="#Options">Options</a>
<li>-no-protect: <a href="#Options">Options</a>
<li>-oflow-byte: <a href="#Options">Options</a>
<li>-oflow-size: <a href="#Options">Options</a>
<li>-oflow-watch: <a href="#Options">Options</a>
<li>-page-alloc-lower: <a href="#Options">Options</a>
<li>-page-alloc-upper: <a href="#Options">Options</a>
<li>-preserve: <a href="#Options">Options</a>
<li>-prof: <a href="#Options">Options</a>
<li>-prof-file: <a href="#Options">Options</a>
<li>-prog-file: <a href="#Options">Options</a>
<li>-realloc-stop: <a href="#Options">Options</a>
<li>-safe-signals: <a href="#Options">Options</a>
<li>-show-all: <a href="#Options">Options</a>
<li>-show-env: <a href="#Options">Options</a>
<li>-show-free: <a href="#Options">Options</a>
<li>-show-freed: <a href="#Options">Options</a>
<li>-show-map: <a href="#Options">Options</a>
<li>-show-symbols: <a href="#Options">Options</a>
<li>-show-unfreed: <a href="#Options">Options</a>
<li>-small-bound: <a href="#Options">Options</a>
<li>-source-dir: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>-stack-depth: <a href="#Profiling">Profiling</a>
<li>-threads: <a href="#Options">Options</a>
<li>-trace: <a href="#Options">Options</a>
<li>-trace-file: <a href="#Options">Options</a>
<li>-unfreed-abort: <a href="#Options">Options</a>
<li>-use-debug: <a href="#Options">Options</a>
<li>-use-mmap: <a href="#Options">Options</a>
<li>-version: <a href="#Options">Options</a>
<li>.cshrc: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>.gdbinit: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>.profile: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>32-bit: <a href="#Building">Building</a>
<li>64-bit: <a href="#Building">Building</a>
<li>_RLD_LIST: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>ABI: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>acknowledgements: <a href="#Foreword">Foreword</a>
<li>adding a new object file format: <a href="#New%20file%20format%20support">New file format support</a>
<li>adding a new operating system: <a href="#New%20system%20support">New system support</a>
<li>adding a new processor architecture: <a href="#New%20processor%20support">New processor support</a>
<li>address space: <a href="#Operating%20system%20support">Operating system support</a>
<li>address, physical: <a href="#Virtual%20memory">Virtual memory</a>
<li>address, virtual: <a href="#Virtual%20memory">Virtual memory</a>
<li>AIX, IBM RS/6000: <a href="#Supported%20systems">Supported systems</a>
<li>alignment: <a href="#Library%20behaviour">Library behaviour</a>
<li>all (make target): <a href="#Installation">Installation</a>
<li>alloca: <a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>
<li>allocated blocks: <a href="#Example%201">Example 1</a>
<li>allocation algorithm: <a href="#How%20it%20works">How it works</a>
<li>allocation bin table: <a href="#Profiling">Profiling</a>
<li>allocation bins: <a href="#Profiling">Profiling</a>
<li>allocation boundaries: <a href="#Profiling">Profiling</a>
<li>allocation byte: <a href="#General%20errors">General errors</a>
<li>allocation index: <a href="#Example%201">Example 1</a>
<li>allocation information: <a href="#Functions">Functions</a>
<li>allocation type: <a href="#Example%201">Example 1</a>
<li>ALLOCBYTE: <a href="#Environment">Environment</a>
<li>ALLOCSTOP: <a href="#Environment">Environment</a>
<li>ALLOVF: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>ALLOWOFLOW: <a href="#Environment">Environment</a>
<li>ALLZER: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>amalloc: <a href="#Improving%20performance">Improving performance</a>
<li>Amiga 4000/040: <a href="#Installation">Installation</a>
<li>Amiga notes: <a href="#Amiga%20notes">Amiga notes</a>
<li>AmigaOS, Motorola 680x0: <a href="#Supported%20systems">Supported systems</a>
<li>ANSI: <a href="#Improving%20performance">Improving performance</a>
<li>application binary interface: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>AProbe: <a href="#Related%20software">Related software</a>
<li>APurify: <a href="#Related%20software">Related software</a>
<li>AR: <a href="#Installation">Installation</a>
<li>ARCH: <a href="#Building">Building</a>
<li>archive library: <a href="#Features">Features</a>
<li>arenas: <a href="#Improving%20performance">Improving performance</a>
<li>articles: <a href="#References">References</a>
<li>assembler: <a href="#Profiling">Profiling</a>
<li>ATOM: <a href="#Related%20software">Related software</a>
<li>author, contacting: <a href="#Foreword">Foreword</a>
<li>AutomatedQA: <a href="#Related%20software">Related software</a>
<li>AUTOSAVE: <a href="#Environment">Environment</a>
<li>backwards compatibility: <a href="#Linking">Linking</a>
<li>BADALN: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>bash: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>BASIC: <a href="#Memory%20allocations">Memory allocations</a>
<li>batch testing: <a href="#Testing">Testing</a>
<li>best fit: <a href="#How%20it%20works">How it works</a>
<li>BFD: <a href="#Examples">Examples</a>
<li>bin: <a href="#Profiling">Profiling</a>
<li>binary: <a href="#Environment">Environment</a>
<li>binary file: <a href="#Profiling">Profiling</a>
<li>bit bucket: <a href="#Running">Running</a>
<li>blocks: <a href="#Example%201">Example 1</a>
<li>BoundsChecker: <a href="#Related%20software">Related software</a>
<li>breakpoint: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>bsdmalloc(3x): <a href="#Related%20software">Related software</a>
<li>BSS: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>buffers, overflow: <a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>
<li>bug reports: <a href="#Foreword">Foreword</a>
<li>bugs: <a href="#Notes">Notes</a>
<li>building questions: <a href="#Building">Building</a>
<li>building the library: <a href="#Installation">Installation</a>
<li>bus errors: <a href="#Library%20behaviour">Library behaviour</a>
<li>bytes compared: <a href="#Example%201">Example 1</a>
<li>bytes copied: <a href="#Example%201">Example 1</a>
<li>bytes located: <a href="#Example%201">Example 1</a>
<li>bytes set: <a href="#Example%201">Example 1</a>
<li>C: <a href="#Memory%20allocations">Memory allocations</a>
<li>C++: <a href="#Memory%20allocations">Memory allocations</a>
<li>C++ mangled names: <a href="#Example%201">Example 1</a>
<li>call sites: <a href="#Profiling">Profiling</a>
<li>call stacks: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>call-by-value: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>callback functions: <a href="#Example%201">Example 1</a>
<li>calling convention: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>CC: <a href="#Installation">Installation</a>
<li>Ccmalloc: <a href="#Related%20software">Related software</a>
<li>CenterLine Development Systems: <a href="#Related%20software">Related software</a>
<li>CFLAGS: <a href="#Installation">Installation</a>
<li>ChangeLog: <a href="#Files">Files</a>
<li>Chaperon: <a href="#Related%20software">Related software</a>
<li>CHECK: <a href="#Environment">Environment</a>
<li>CHECKALL: <a href="#Environment">Environment</a>
<li>CHECKALLOCS: <a href="#Environment">Environment</a>
<li>Checker: <a href="#Related%20software">Related software</a>
<li>CHECKFREES: <a href="#Environment">Environment</a>
<li>CHECKMEMORY: <a href="#Environment">Environment</a>
<li>CHECKREALLOCS: <a href="#Environment">Environment</a>
<li>children: <a href="#Profiling">Profiling</a>
<li>CISC: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>clean (make target): <a href="#Installation">Installation</a>
<li>clobber (make target): <a href="#Installation">Installation</a>
<li>CMEM: <a href="#Related%20software">Related software</a>
<li>COFF: <a href="#Examples">Examples</a>
<li>command line options: <a href="#Options">Options</a>
<li>Commodore-Amiga, Inc.: <a href="#Related%20software">Related software</a>
<li>common variables: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>compiler: <a href="#Installation">Installation</a>
<li>compiling: <a href="#Installation">Installation</a>
<li>contacting the author: <a href="#Foreword">Foreword</a>
<li>context listing: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>contributors: <a href="#Foreword">Foreword</a>
<li>core file: <a href="#Running">Running</a>
<li>crash: <a href="#Example%201">Example 1</a>
<li>csh: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>CSRI malloc: <a href="#Related%20software">Related software</a>
<li>CVS: <a href="#Files">Files</a>
<li>cycles: <a href="#Profiling">Profiling</a>
<li>data sections: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>Dbmalloc: <a href="#Related%20software">Related software</a>
<li>Debauch: <a href="#Related%20software">Related software</a>
<li>Debug Heap: <a href="#Related%20software">Related software</a>
<li>debugger: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>debugging: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>debugging information: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>decimal: <a href="#Environment">Environment</a>
<li>declarations, tentative: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>DEFALIGN: <a href="#Environment">Environment</a>
<li>Dell Inspiron 7500: <a href="#Installation">Installation</a>
<li>demangler: <a href="#Example%201">Example 1</a>
<li>DG/UX, Intel 80x86: <a href="#Supported%20systems">Supported systems</a>
<li>DG/UX, Motorola 88xx0: <a href="#Supported%20systems">Supported systems</a>
<li>diagnostic messages: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>Digital Equipment Corporation: <a href="#Related%20software">Related software</a>
<li>Digital UNIX: <a href="#Improving%20performance">Improving performance</a>
<li>direct allocation table: <a href="#Profiling">Profiling</a>
<li>direct allocations: <a href="#Profiling">Profiling</a>
<li>DLLs: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>Dmalloc: <a href="#Related%20software">Related software</a>
<li>DocBook: <a href="#Documentation">Documentation</a>
<li>documentation: <a href="#Installation">Installation</a>
<li>documentation formats: <a href="#Documentation">Documentation</a>
<li>documentation questions: <a href="#Documentation">Documentation</a>
<li>dot: <a href="#Profiling">Profiling</a>
<li>dotty: <a href="#Profiling">Profiling</a>
<li>driver: <a href="#Profiling">Profiling</a>
<li>DRS/NX, SPARC: <a href="#Supported%20systems">Supported systems</a>
<li>dumping memory: <a href="#Example%204">Example 4</a>
<li>duplicate symbols: <a href="#Linking">Linking</a>
<li>DVI: <a href="#Documentation">Documentation</a>
<li>DWARF: <a href="#How%20it%20works">How it works</a>
<li>dynamic link libraries: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>dynamic linker: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>dynamic linking: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>dynamic memory allocations: <a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>
<li>DYNIX/ptx, Intel 80x86: <a href="#Supported%20systems">Supported systems</a>
<li>EDIT: <a href="#Environment">Environment</a>
<li>EDITOR: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>editor: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>Electric Fence: <a href="#Related%20software">Related software</a>
<li>Electric Software, Inc.: <a href="#Related%20software">Related software</a>
<li>ELF32: <a href="#Examples">Examples</a>
<li>ELF64: <a href="#Examples">Examples</a>
<li>emacs: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>embedded libraries: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>embedded systems: <a href="#Operating%20system%20support">Operating system support</a>
<li>endianness: <a href="#Profiling">Profiling</a>
<li>Enforcer: <a href="#Related%20software">Related software</a>
<li>enhancements: <a href="#Notes">Notes</a>
<li>entry-point: <a href="#Example%201">Example 1</a>
<li>ENVIRON: <a href="#Building">Building</a>
<li>environment: <a href="#Environment">Environment</a>
<li>epilogue function: <a href="#Example%201">Example 1</a>
<li>error abbreviation code: <a href="#Example%201">Example 1</a>
<li>error severity: <a href="#Example%201">Example 1</a>
<li>errors: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>errors, run-time: <a href="#Overview">Overview</a>
<li>examples: <a href="#Examples">Examples</a>
<li>executable files: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>extern inline: <a href="#Building">Building</a>
<li>FAILFREQ: <a href="#Environment">Environment</a>
<li>FAILSEED: <a href="#Environment">Environment</a>
<li>failure frequency: <a href="#Testing">Testing</a>
<li>failure seed: <a href="#Testing">Testing</a>
<li>FAQ: <a href="#Frequently%20asked%20questions">Frequently asked questions</a>
<li>fatal errors: <a href="#Example%201">Example 1</a>
<li>fault, page: <a href="#Virtual%20memory">Virtual memory</a>
<li>FDA (Free Debug Allocator): <a href="#Related%20software">Related software</a>
<li>features: <a href="#Features">Features</a>
<li>fence posts: <a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>
<li>file formats: <a href="#File%20formats">File formats</a>
<li>file scope variables: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>files questions: <a href="#Files">Files</a>
<li>files, mapping: <a href="#Virtual%20memory">Virtual memory</a>
<li>first fit: <a href="#How%20it%20works">How it works</a>
<li>fitting allocations: <a href="#Example%203">Example 3</a>
<li>foreword: <a href="#Foreword">Foreword</a>
<li>FORMAT: <a href="#Building">Building</a>
<li>format string: <a href="#Profiling">Profiling</a>
<li>Fortify: <a href="#Related%20software">Related software</a>
<li>FORTRAN: <a href="#Memory%20allocations">Memory allocations</a>
<li>frame pointer: <a href="#Running">Running</a>
<li>FRDCOR: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>FRDOPN: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>FRDOVF: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>FRECOR: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>free blocks: <a href="#Example%201">Example 1</a>
<li>free byte: <a href="#General%20errors">General errors</a>
<li>free memory: <a href="#General%20errors">General errors</a>
<li>FREEBYTE: <a href="#Environment">Environment</a>
<li>freed blocks: <a href="#Example%201">Example 1</a>
<li>freed memory: <a href="#General%20errors">General errors</a>
<li>freed queue: <a href="#Example%201">Example 1</a>
<li>FREESTOP: <a href="#Environment">Environment</a>
<li>FRENUL: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>FREOPN: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>frequently asked questions: <a href="#Frequently%20asked%20questions">Frequently asked questions</a>
<li>FreshMeat: <a href="#Foreword">Foreword</a>
<li>function call stacks: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>functions: <a href="#Functions">Functions</a>
<li>functions, callback: <a href="#Example%201">Example 1</a>
<li>functions, handler: <a href="#Example%201">Example 1</a>
<li>future enhancements: <a href="#Notes">Notes</a>
<li>g++: <a href="#Example%201">Example 1</a>
<li>garbage collector: <a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>
<li>GC (Garbage Collector): <a href="#Related%20software">Related software</a>
<li>gcc: <a href="#Example%201">Example 1</a>
<li>gdb: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>general errors: <a href="#General%20errors">General errors</a>
<li>Geodesic Systems: <a href="#Related%20software">Related software</a>
<li>getting updates: <a href="#Foreword">Foreword</a>
<li>GlowCode: <a href="#Related%20software">Related software</a>
<li>GNU C library: <a href="#Related%20software">Related software</a>
<li>gprof: <a href="#Profiling">Profiling</a>
<li>graph: <a href="#Profiling">Profiling</a>
<li>graph specification file: <a href="#Profiling">Profiling</a>
<li>GraphViz: <a href="#Profiling">Profiling</a>
<li>Great Circle: <a href="#Related%20software">Related software</a>
<li>Green Hills Software, Inc.: <a href="#Related%20software">Related software</a>
<li>halting the library: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>handler functions: <a href="#Example%201">Example 1</a>
<li>heap: <a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>
<li>heap usage: <a href="#Example%201">Example 1</a>
<li>HeapAgent: <a href="#Related%20software">Related software</a>
<li>HeapCheck: <a href="#Related%20software">Related software</a>
<li>HeapManager: <a href="#Related%20software">Related software</a>
<li>HELP: <a href="#Environment">Environment</a>
<li>hexadecimal: <a href="#Environment">Environment</a>
<li>hidden memory: <a href="#How%20it%20works">How it works</a>
<li>hints: <a href="#Improving%20performance">Improving performance</a>
<li>HP/UX, HP PA/RISC: <a href="#Supported%20systems">Supported systems</a>
<li>Hyperlearning Center: <a href="#References">References</a>
<li>IBM Corporation: <a href="#Related%20software">Related software</a>
<li>illegal memory accesses: <a href="#Example%203">Example 3</a>
<li>ILLMEM: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>implementation details: <a href="#How%20it%20works">How it works</a>
<li>improving performance: <a href="#Improving%20performance">Improving performance</a>
<li>INCOMP: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>INFOPATH: <a href="#Documentation">Documentation</a>
<li>information about an allocation: <a href="#Functions">Functions</a>
<li>inline functions: <a href="#Building">Building</a>
<li>installation: <a href="#Installation">Installation</a>
<li>instrumentation: <a href="#Related%20software">Related software</a>
<li>Insure++: <a href="#Related%20software">Related software</a>
<li>integration: <a href="#Integration">Integration</a>
<li>internal blocks: <a href="#Example%201">Example 1</a>
<li>Intuitive Systems, Inc.: <a href="#Related%20software">Related software</a>
<li>Inuse: <a href="#Installation">Installation</a>
<li>IRIX, MIPS: <a href="#Supported%20systems">Supported systems</a>
<li>JMalloc: <a href="#Related%20software">Related software</a>
<li>JProbe: <a href="#Related%20software">Related software</a>
<li>Kernel Group, The: <a href="#Related%20software">Related software</a>
<li>KL Group: <a href="#Related%20software">Related software</a>
<li>known bugs: <a href="#Notes">Notes</a>
<li>ksh: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>LARGEBOUND: <a href="#Environment">Environment</a>
<li>LaTeX: <a href="#Installation">Installation</a>
<li>LD: <a href="#Installation">Installation</a>
<li>LD_LIBRARY_PATH: <a href="#Linking">Linking</a>
<li>LD_PRELOAD: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>LD_RUN_PATH: <a href="#Linking">Linking</a>
<li>Leak: <a href="#Related%20software">Related software</a>
<li>Leakers: <a href="#Related%20software">Related software</a>
<li>LeakTracer: <a href="#Related%20software">Related software</a>
<li>Leaky: <a href="#Related%20software">Related software</a>
<li>LessTif: <a href="#Building">Building</a>
<li>LhA archive: <a href="#Installation">Installation</a>
<li>LibKmalloc: <a href="#Related%20software">Related software</a>
<li>library behaviour: <a href="#Library%20behaviour">Library behaviour</a>
<li>library functions: <a href="#Library%20functions">Library functions</a>
<li>library settings: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>library statistics: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>library, archive: <a href="#Features">Features</a>
<li>library, building: <a href="#Installation">Installation</a>
<li>library, mpatrol: <a href="#Overview">Overview</a>
<li>library, shared: <a href="#Features">Features</a>
<li>library, thread-safe: <a href="#Features">Features</a>
<li>LibSafe: <a href="#Related%20software">Related software</a>
<li>LIMIT: <a href="#Environment">Environment</a>
<li>limitations: <a href="#Notes">Notes</a>
<li>limiting available memory: <a href="#Testing">Testing</a>
<li>line number table: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>linker: <a href="#Installation">Installation</a>
<li>linking: <a href="#Installation">Installation</a>
<li>linking questions: <a href="#Linking">Linking</a>
<li>links, symbolic: <a href="#Installation">Installation</a>
<li>lint: <a href="#Installation">Installation</a>
<li>lint (make target): <a href="#Installation">Installation</a>
<li>Linux Software Map: <a href="#Installation">Installation</a>
<li>Linux, Intel 80x86: <a href="#Supported%20systems">Supported systems</a>
<li>Linux, Motorola 680x0: <a href="#Supported%20systems">Supported systems</a>
<li>LIST: <a href="#Environment">Environment</a>
<li>list: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>local static variables: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>log file: <a href="#Example%201">Example 1</a>
<li>LOGALL: <a href="#Environment">Environment</a>
<li>LOGALLOCS: <a href="#Environment">Environment</a>
<li>LOGDIR: <a href="#Environment">Environment</a>
<li>LOGFILE: <a href="#Environment">Environment</a>
<li>LOGFREES: <a href="#Environment">Environment</a>
<li>logging: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>LOGMEMORY: <a href="#Environment">Environment</a>
<li>LOGREALLOCS: <a href="#Environment">Environment</a>
<li>low memory handler function: <a href="#Example%201">Example 1</a>
<li>LSM: <a href="#Installation">Installation</a>
<li>LynxOS, Intel 80x86: <a href="#Supported%20systems">Supported systems</a>
<li>LynxOS, PowerPC: <a href="#Supported%20systems">Supported systems</a>
<li>magic: <a href="#File%20formats">File formats</a>
<li>make: <a href="#Installation">Installation</a>
<li>Makefile: <a href="#Installation">Installation</a>
<li>Malloc Debug: <a href="#Related%20software">Related software</a>
<li>Malloc Debug Library: <a href="#Related%20software">Related software</a>
<li>malloc libraries for Solaris: <a href="#Related%20software">Related software</a>
<li>malloc(3c): <a href="#Related%20software">Related software</a>
<li>malloc(3x): <a href="#Related%20software">Related software</a>
<li>Malloc_Dbg: <a href="#Related%20software">Related software</a>
<li>MallocTrace: <a href="#Related%20software">Related software</a>
<li>mallopt: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>MalTrace: <a href="#Related%20software">Related software</a>
<li>mangled names: <a href="#Example%201">Example 1</a>
<li>MANPATH: <a href="#Documentation">Documentation</a>
<li>manual layout: <a href="#Foreword">Foreword</a>
<li>manual pages: <a href="#Installation">Installation</a>
<li>map of memory: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>mapmalloc(3x): <a href="#Related%20software">Related software</a>
<li>mapping files: <a href="#Virtual%20memory">Virtual memory</a>
<li>MAXALN: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>MCheck: <a href="#Related%20software">Related software</a>
<li>MEDIUMBOUND: <a href="#Environment">Environment</a>
<li>MEM: <a href="#Related%20software">Related software</a>
<li>MemCheck: <a href="#Related%20software">Related software</a>
<li>MemDebug: <a href="#Related%20software">Related software</a>
<li>MemLeak: <a href="#Related%20software">Related software</a>
<li>Memory Advisor: <a href="#Related%20software">Related software</a>
<li>memory allocation profiling: <a href="#Profiling">Profiling</a>
<li>memory allocations: <a href="#Memory%20allocations">Memory allocations</a>
<li>memory allocations, dynamic: <a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>
<li>memory allocations, stack: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>memory allocations, static: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>memory blocks: <a href="#Example%201">Example 1</a>
<li>memory debugger: <a href="#Related%20software">Related software</a>
<li>memory dump: <a href="#Example%204">Example 4</a>
<li>memory leak table: <a href="#Profiling">Profiling</a>
<li>memory leaks: <a href="#Example%208">Example 8</a>
<li>memory management interface: <a href="#Operating%20system%20support">Operating system support</a>
<li>Memory Management Reference: <a href="#References">References</a>
<li>memory management unit: <a href="#Virtual%20memory">Virtual memory</a>
<li>memory map: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>memory mapped files: <a href="#Virtual%20memory">Virtual memory</a>
<li>memory protection: <a href="#Virtual%20memory">Virtual memory</a>
<li>Memory Sleuth: <a href="#Related%20software">Related software</a>
<li>memory usage: <a href="#Example%201">Example 1</a>
<li>memory, physical: <a href="#Virtual%20memory">Virtual memory</a>
<li>memory, virtual: <a href="#Virtual%20memory">Virtual memory</a>
<li>Memprof: <a href="#Related%20software">Related software</a>
<li>Memproof: <a href="#Related%20software">Related software</a>
<li>MemTrace: <a href="#Related%20software">Related software</a>
<li>MemWatch: <a href="#Related%20software">Related software</a>
<li>message passing: <a href="#Threads">Threads</a>
<li>MicroQuill: <a href="#Related%20software">Related software</a>
<li>Microsoft: <a href="#Supported%20systems">Supported systems</a>
<li>misaligned data: <a href="#Library%20behaviour">Library behaviour</a>
<li>misaligned memory accesses: <a href="#Virtual%20memory">Virtual memory</a>
<li>MISMAT: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>ML: <a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>
<li>mleak: <a href="#The%20mleak%20command">The mleak command</a>
<li>mleak command: <a href="#The%20mleak%20command">The mleak command</a>
<li>MM (Shared Memory Library): <a href="#Related%20software">Related software</a>
<li>Mmalloc: <a href="#Related%20software">Related software</a>
<li>mmap: <a href="#Library%20behaviour">Library behaviour</a>
<li>MMU: <a href="#Virtual%20memory">Virtual memory</a>
<li>modules: <a href="#How%20it%20works">How it works</a>
<li>Motif: <a href="#Building">Building</a>
<li>MP_BUILTINSTACK_SUPPORT: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>MP_DELETE: <a href="#Functions">Functions</a>
<li>MP_INLINE: <a href="#Building">Building</a>
<li>MP_LIBRARYSTACK_SUPPORT: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>MP_NEW: <a href="#Functions">Functions</a>
<li>MP_NOCPLUSPLUS: <a href="#Functions">Functions</a>
<li>MP_NONEWDELETE: <a href="#Functions">Functions</a>
<li>mpatrol: <a href="#Overview">Overview</a>
<li>mpatrol command: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>mpatrol features: <a href="#Features">Features</a>
<li>mpatrol library: <a href="#Overview">Overview</a>
<li>mpatrol.h: <a href="#Functions">Functions</a>
<li>mpatrol.log: <a href="#Example%201">Example 1</a>
<li>MPATROL_OPTIONS: <a href="#Environment">Environment</a>
<li>MPATROL_SOURCEPATH: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>MPATROL_VERSION: <a href="#Functions">Functions</a>
<li>mpedit: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>mpedit command: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>MPR: <a href="#Related%20software">Related software</a>
<li>Mprof: <a href="#Related%20software">Related software</a>
<li>mprof: <a href="#Profiling">Profiling</a>
<li>mprof command: <a href="#Profiling">Profiling</a>
<li>mpsym: <a href="#The%20mpsym%20command">The mpsym command</a>
<li>mpsym command: <a href="#The%20mpsym%20command">The mpsym command</a>
<li>MSS (Memory Supervision System): <a href="#Related%20software">Related software</a>
<li>mtmalloc(3t): <a href="#Related%20software">Related software</a>
<li>MuForce: <a href="#Related%20software">Related software</a>
<li>MuGuardianAngel: <a href="#Related%20software">Related software</a>
<li>MuLib: <a href="#Related%20software">Related software</a>
<li>MULTI: <a href="#Related%20software">Related software</a>
<li>multi-processor systems: <a href="#Threads">Threads</a>
<li>Mungwall: <a href="#Related%20software">Related software</a>
<li>mupdate: <a href="#Files">Files</a>
<li>mutexes: <a href="#Threads">Threads</a>
<li>NDEBUG: <a href="#Functions">Functions</a>
<li>Netware notes: <a href="#Netware%20notes">Netware notes</a>
<li>NEWS: <a href="#Files">Files</a>
<li>NJAMD (Not Just Another Malloc Debugger): <a href="#Related%20software">Related software</a>
<li>NOFREE: <a href="#Environment">Environment</a>
<li>non-static local variables: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>NOPROTECT: <a href="#Environment">Environment</a>
<li>NOTALL: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>notes: <a href="#Notes">Notes</a>
<li>notes for all platforms: <a href="#Generic%20notes">Generic notes</a>
<li>notes for Amiga platforms: <a href="#Amiga%20notes">Amiga notes</a>
<li>notes for Netware platforms: <a href="#Netware%20notes">Netware notes</a>
<li>notes for UNIX platforms: <a href="#UNIX%20notes">UNIX notes</a>
<li>notes for Windows platforms: <a href="#Windows%20notes">Windows notes</a>
<li>NULOPN: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>NuMega Corporation: <a href="#Related%20software">Related software</a>
<li>object file formats, adding support: <a href="#New%20file%20format%20support">New file format support</a>
<li>object files: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>ObjectCenter: <a href="#Related%20software">Related software</a>
<li>OC Systems: <a href="#Related%20software">Related software</a>
<li>octal: <a href="#Environment">Environment</a>
<li>OFLAGS: <a href="#Installation">Installation</a>
<li>OFLOWBYTE: <a href="#Environment">Environment</a>
<li>OFLOWSIZE: <a href="#Environment">Environment</a>
<li>OFLOWWATCH: <a href="#Environment">Environment</a>
<li>Onyx Technology: <a href="#Related%20software">Related software</a>
<li>operating systems: <a href="#Operating%20system%20support">Operating system support</a>
<li>operating systems, adding support: <a href="#New%20system%20support">New system support</a>
<li>optimisation: <a href="#Installation">Installation</a>
<li>Optimizeit: <a href="#Related%20software">Related software</a>
<li>option summary: <a href="#Environment">Environment</a>
<li>options: <a href="#Options">Options</a>
<li>original implementation: <a href="#How%20it%20works">How it works</a>
<li>other programs: <a href="#Related%20software">Related software</a>
<li>OUTMEM: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>overflow buffers: <a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>
<li>overflow byte: <a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>
<li>overflow size: <a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>
<li>overview: <a href="#Overview">Overview</a>
<li>overwrites: <a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>
<li>page: <a href="#Virtual%20memory">Virtual memory</a>
<li>page fault: <a href="#Virtual%20memory">Virtual memory</a>
<li>page size: <a href="#Virtual%20memory">Virtual memory</a>
<li>PAGEALLOC: <a href="#Environment">Environment</a>
<li>papers: <a href="#References">References</a>
<li>parallel programming: <a href="#Threads">Threads</a>
<li>parameter variables: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>Parasoft: <a href="#Related%20software">Related software</a>
<li>parents: <a href="#Profiling">Profiling</a>
<li>Pascal: <a href="#Memory%20allocations">Memory allocations</a>
<li>PATH: <a href="#Linking">Linking</a>
<li>PE: <a href="#Examples">Examples</a>
<li>peak memory usage: <a href="#Example%201">Example 1</a>
<li>performance bottleneck: <a href="#Improving%20performance">Improving performance</a>
<li>performance improvements: <a href="#Improving%20performance">Improving performance</a>
<li>performance times: <a href="#Library%20performance">Library performance</a>
<li>physical address: <a href="#Virtual%20memory">Virtual memory</a>
<li>physical memory: <a href="#Virtual%20memory">Virtual memory</a>
<li>PKG package: <a href="#Installation">Installation</a>
<li>platform-independent notes: <a href="#Generic%20notes">Generic notes</a>
<li>platforms: <a href="#Supported%20systems">Supported systems</a>
<li>PLATINUM Technology: <a href="#Related%20software">Related software</a>
<li>Plumber: <a href="#Related%20software">Related software</a>
<li>portability: <a href="#Improving%20performance">Improving performance</a>
<li>POSIX threads: <a href="#Threads">Threads</a>
<li>postscript: <a href="#Documentation">Documentation</a>
<li>prelinker: <a href="#Profiling">Profiling</a>
<li>preprocessor: <a href="#Profiling">Profiling</a>
<li>PRESERVE: <a href="#Environment">Environment</a>
<li>preserve freed contents: <a href="#General%20errors">General errors</a>
<li>prevent freeing memory: <a href="#General%20errors">General errors</a>
<li>printing: <a href="#Installation">Installation</a>
<li>process id: <a href="#Options">Options</a>
<li>processor architectures, adding support: <a href="#New%20processor%20support">New processor support</a>
<li>PROF: <a href="#Environment">Environment</a>
<li>PROFDIR: <a href="#Environment">Environment</a>
<li>PROFFILE: <a href="#Environment">Environment</a>
<li>profiling: <a href="#Profiling">Profiling</a>
<li>profiling file format: <a href="#Profiling%20file%20format">Profiling file format</a>
<li>PROGFILE: <a href="#Environment">Environment</a>
<li>program counter: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>programs: <a href="#Related%20software">Related software</a>
<li>prologue function: <a href="#Example%201">Example 1</a>
<li>PRVFRD: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>Purify: <a href="#Related%20software">Related software</a>
<li>QC: <a href="#Related%20software">Related software</a>
<li>questions: <a href="#Frequently%20asked%20questions">Frequently asked questions</a>
<li>quick reference card: <a href="#Installation">Installation</a>
<li>random failures: <a href="#Testing">Testing</a>
<li>Rational Software: <a href="#Related%20software">Related software</a>
<li>re-entrancy: <a href="#Threads">Threads</a>
<li>read protection: <a href="#Virtual%20memory">Virtual memory</a>
<li>REALLOCSTOP: <a href="#Environment">Environment</a>
<li>recompilation: <a href="#Integration">Integration</a>
<li>recoverable errors: <a href="#Example%201">Example 1</a>
<li>Red Hat: <a href="#Supported%20systems">Supported systems</a>
<li>reference card: <a href="#Installation">Installation</a>
<li>references: <a href="#References">References</a>
<li>registers: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>related software: <a href="#Related%20software">Related software</a>
<li>release builds: <a href="#Foreword">Foreword</a>
<li>reporting bugs: <a href="#Foreword">Foreword</a>
<li>resources: <a href="#References">References</a>
<li>return address: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>RISC: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>RNGOVF: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>RNGOVL: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>RPM package: <a href="#Installation">Installation</a>
<li>RSZNUL: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>RSZZER: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>run-time errors: <a href="#Overview">Overview</a>
<li>running questions: <a href="#Running">Running</a>
<li>SAFESIGNALS: <a href="#Environment">Environment</a>
<li>sbrk: <a href="#Library%20behaviour">Library behaviour</a>
<li>SD/UX package: <a href="#Installation">Installation</a>
<li>sections: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>semaphores: <a href="#Threads">Threads</a>
<li>Sentinel: <a href="#Related%20software">Related software</a>
<li>settings: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>severity of errors: <a href="#Example%201">Example 1</a>
<li>SFLAGS: <a href="#Installation">Installation</a>
<li>shared libraries: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>shared library: <a href="#Features">Features</a>
<li>shared memory: <a href="#Threads">Threads</a>
<li>SHOWALL: <a href="#Environment">Environment</a>
<li>SHOWFREE: <a href="#Environment">Environment</a>
<li>SHOWFREED: <a href="#Environment">Environment</a>
<li>SHOWMAP: <a href="#Environment">Environment</a>
<li>SHOWSYMBOLS: <a href="#Environment">Environment</a>
<li>SHOWUNFREED: <a href="#Environment">Environment</a>
<li>signal handler: <a href="#Example%203">Example 3</a>
<li>signals: <a href="#Features">Features</a>
<li>similar programs: <a href="#Related%20software">Related software</a>
<li>single-step: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>SINIX, MIPS: <a href="#Supported%20systems">Supported systems</a>
<li>slot tables: <a href="#Improving%20performance">Improving performance</a>
<li>SMALLBOUND: <a href="#Environment">Environment</a>
<li>SmartAlloc: <a href="#Related%20software">Related software</a>
<li>SmartHeap: <a href="#Related%20software">Related software</a>
<li>software: <a href="#Related%20software">Related software</a>
<li>Solaris malloc libraries: <a href="#Related%20software">Related software</a>
<li>Solaris, Intel 80x86: <a href="#Supported%20systems">Supported systems</a>
<li>Solaris, SPARC: <a href="#Supported%20systems">Supported systems</a>
<li>Spotlight: <a href="#Related%20software">Related software</a>
<li>stack: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>stack memory allocations: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>stack tracebacks: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>stack unwinding: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>StackTrace: <a href="#Related%20software">Related software</a>
<li>static inline: <a href="#Building">Building</a>
<li>static memory allocations: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>statistics: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>Stratosware Corporation: <a href="#Related%20software">Related software</a>
<li>stress testing: <a href="#Improving%20performance">Improving performance</a>
<li>stripped executable file: <a href="#Library%20behaviour">Library behaviour</a>
<li>STROVF: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>summary of options: <a href="#Environment">Environment</a>
<li>supported systems: <a href="#Supported%20systems">Supported systems</a>
<li>SVR4: <a href="#Examples">Examples</a>
<li>swap file: <a href="#Virtual%20memory">Virtual memory</a>
<li>swap in: <a href="#Virtual%20memory">Virtual memory</a>
<li>swap out: <a href="#Virtual%20memory">Virtual memory</a>
<li>swapping: <a href="#Virtual%20memory">Virtual memory</a>
<li>symbol summary: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>symbol tables: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>symbolic links: <a href="#Installation">Installation</a>
<li>symbols: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>SYSTEM: <a href="#Building">Building</a>
<li>system page size: <a href="#Virtual%20memory">Virtual memory</a>
<li>systems: <a href="#Supported%20systems">Supported systems</a>
<li>systems, embedded: <a href="#Operating%20system%20support">Operating system support</a>
<li>TAR archive: <a href="#Installation">Installation</a>
<li>TARGET: <a href="#Building">Building</a>
<li>tcsh: <a href="#The%20mpatrol%20command">The mpatrol command</a>
<li>tentative declarations: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>test suite: <a href="#Features">Features</a>
<li>TestCenter: <a href="#Related%20software">Related software</a>
<li>testing: <a href="#Testing">Testing</a>
<li>TeXinfo: <a href="#Installation">Installation</a>
<li>text editor: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>TFLAGS: <a href="#Installation">Installation</a>
<li>Third Degree: <a href="#Related%20software">Related software</a>
<li>thrashing: <a href="#Virtual%20memory">Virtual memory</a>
<li>thread-safe library: <a href="#Features">Features</a>
<li>threads: <a href="#Threads">Threads</a>
<li>threads library: <a href="#Threads">Threads</a>
<li>times: <a href="#Library%20performance">Library performance</a>
<li>tips: <a href="#Improving%20performance">Improving performance</a>
<li>TRACE: <a href="#Environment">Environment</a>
<li>tracebacks: <a href="#Call%20stacks%20and%20symbol%20tables">Call stacks and symbol tables</a>
<li>TRACEDIR: <a href="#Environment">Environment</a>
<li>TRACEFILE: <a href="#Environment">Environment</a>
<li>tracing: <a href="#Logging%20and%20tracing">Logging and tracing</a>
<li>tracing file format: <a href="#Tracing%20file%20format">Tracing file format</a>
<li>tree structure: <a href="#Example%202">Example 2</a>
<li>TurboPower: <a href="#Related%20software">Related software</a>
<li>tutorial: <a href="#Tutorial">Tutorial</a>
<li>type of allocation: <a href="#Example%201">Example 1</a>
<li>undefined symbols: <a href="#Linking">Linking</a>
<li>underwrites: <a href="#Overwrites%20and%20underwrites">Overwrites and underwrites</a>
<li>unfreed allocations: <a href="#Example%201">Example 1</a>
<li>UNFREEDABORT: <a href="#Environment">Environment</a>
<li>UNIX notes: <a href="#UNIX%20notes">UNIX notes</a>
<li>UnixWare, Intel 80x86: <a href="#Supported%20systems">Supported systems</a>
<li>updates: <a href="#Foreword">Foreword</a>
<li>USEDEBUG: <a href="#Environment">Environment</a>
<li>USEMMAP: <a href="#Environment">Environment</a>
<li>using mpatrol: <a href="#Using%20mpatrol">Using mpatrol</a>
<li>using with a debugger: <a href="#Using%20with%20a%20debugger">Using with a debugger</a>
<li>utilities: <a href="#Utilities">Utilities</a>
<li>variable length arrays: <a href="#Dynamic%20memory%20allocations">Dynamic memory allocations</a>
<li>variables, file scope: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>variables, local static: <a href="#Static%20memory%20allocations">Static memory allocations</a>
<li>variables, non-static local: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>variables, parameter: <a href="#Stack%20memory%20allocations">Stack memory allocations</a>
<li>VAX: <a href="#Profiling">Profiling</a>
<li>VERSION: <a href="#Files">Files</a>
<li>vi: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>vim: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>virtual address: <a href="#Virtual%20memory">Virtual memory</a>
<li>virtual memory: <a href="#Virtual%20memory">Virtual memory</a>
<li>Virtual Memory Tutorial: <a href="#References">References</a>
<li>Vmalloc: <a href="#Related%20software">Related software</a>
<li>warnings: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>warranty: <a href="#Foreword">Foreword</a>
<li>watch points: <a href="#Virtual%20memory">Virtual memory</a>
<li>watchmalloc(3x): <a href="#Related%20software">Related software</a>
<li>Windows notes: <a href="#Windows%20notes">Windows notes</a>
<li>Windows, Intel 80x86: <a href="#Supported%20systems">Supported systems</a>
<li>Wipeout: <a href="#Related%20software">Related software</a>
<li>write protection: <a href="#Virtual%20memory">Virtual memory</a>
<li>X Windows: <a href="#Building">Building</a>
<li>XANALYS Software Tools: <a href="#References">References</a>
<li>XCOFF: <a href="#Examples">Examples</a>
<li>xemacs: <a href="#The%20mpedit%20command">The mpedit command</a>
<li>YaMa: <a href="#Related%20software">Related software</a>
<li>YAMD (Yet Another Malloc Debugger): <a href="#Related%20software">Related software</a>
<li>ZERALN: <a href="#Diagnostic%20messages">Diagnostic messages</a>
<li>ZeroFault: <a href="#Related%20software">Related software</a>
<li>ZIP archive: <a href="#Installation">Installation</a>
</ul>


<hr><h4>Footnotes</h4>
<ol type="1">
<li><a name="fn-1"></a>
<p>Also available on DG/UX 4.20MU05 with
patch dgux_R4.20MU05.p59 and DG/UX 4.20MU06 with patch dgux_R4.20MU06.p08.</p>

<li><a name="fn-2"></a>
<p>Or more accurately, at link time.</p>

<li><a name="fn-3"></a>
<p>Or per thread on some
systems.</p>

<li><a name="fn-4"></a>
<p>There is currently at least one
garbage collection package available for C and C++ (see <a href="#Related%20software">Related software</a>).</p>

<li><a name="fn-5"></a>
<p>Some compilers now support
variable length arrays which provide roughly the same functionality.</p>

<li><a name="fn-6"></a>
<p>Well, perhaps that's too harsh a word, but it will certainly seem
that way to a process running on a 32-bit UNIX system with only 4 megabytes of
physical memory, and yet it will be able to read from and write to over 4
gigabytes of virtual memory!</p>

<li><a name="fn-7"></a>
<p>The size of a page varies between operating
systems and processor architectures, but they are generally around 4 or 8
kilobytes in size, and are always a power of two.</p>

<li><a name="fn-8"></a>
<p>DLLs on Windows platforms.</p>

<li><a name="fn-9"></a>
<p>The operating system is still considered software.</p>

<li><a name="fn-10"></a>
<p>Due to the overhead of
having to translate every address and swap in and out pages -- although memory
mapped files will usually be more efficient than using normal file operations on
a system without virtual memory.</p>

<li><a name="fn-11"></a>
<p>Usually part of the
<em>Application Binary Interface</em>, or ABI.</p>

<li><a name="fn-12"></a>
<p>A process also known as <em>stack unwinding</em>.</p>

<li><a name="fn-13"></a>
<p>Also known as the <em>return address</em>.</p>

<li><a name="fn-14"></a>
<p>Reduced Instruction Set Computer.</p>

<li><a name="fn-15"></a>
<p>Complex Instruction Set Computer.</p>

<li><a name="fn-16"></a>
<p>Generally known as a line number table.</p>

<li><a name="fn-17"></a>
<p>Which is
the part of the operating system that performs the run-time linking of shared
libraries.</p>

<li><a name="fn-18"></a>
<p>Where the kernel is
effectively a single process running all user programs as threads.</p>

<li><a name="fn-19"></a>
<p>In mpatrol release
1.0 it was enabled by default.</p>

<li><a name="fn-20"></a>
<p>I attempted to do the same for the ANSI C++ memory allocation
operators but there are still namespace and exception handling issues to be
resolved.</p>

<li><a name="fn-21"></a>
<p>In the case of <code>NOFREE=0</code> a double negative does not make
a positive.  The zero indicates that all memory allocations will not really be
freed for later reuse.</p>

<li><a name="fn-22"></a>
<p>Commonly known as <em>overflow buffers</em> or <em>fence
posts</em>.</p>

<li><a name="fn-23"></a>
<p>This is a feature that
was first used by Electric Fence (see <a href="#Related%20software">Related software</a>) to track down memory
corruption.</p>

<li><a name="fn-24"></a>
<p>Unless you've linked the debugger with the mpatrol
library.</p>

<li><a name="fn-25"></a>
<p>The other reason that this
program is simple is because a proper example would generally involve crashing
the program, but on AmigaOS and Netware that would also involve crashing the
system -- not something you'd want to do whilst trying this out.</p>

<li><a name="fn-26"></a>
<p>A sample GDB command file for use with
mpatrol can be found in <code>extra/.gdbinit</code>.</p>

<li><a name="fn-27"></a>
<p>Actually, it's not really the mpatrol library that
uses the memory but the object file access libraries since they call
<code>malloc()</code> to allocate any memory that they require.</p>

<li><a name="fn-28"></a>
<p>A set of tests that run without user
intervention.</p>

<li><a name="fn-29"></a>
<p>If no symbols could be read from the program's
executable file, or if the corresponding symbol could not be determined, then
the function names will be replaced with the code addresses at which the calls
took place.</p>

<li><a name="fn-30"></a>
<p>Cycles in the graph are marked by dashed lines along the
relevant edges instead of solid lines.</p>

<li><a name="fn-31"></a>
<p>You might also have noticed the dotted lines connecting
<code>do_spec_1()</code> and <code>handle_braces()</code> in the previous graph.</p>

<li><a name="fn-32"></a>
<p>Such as for use
in a linked list.</p>

<li><a name="fn-33"></a>
<p>A freely distributably library
called GC (see <a href="#Related%20software">Related software</a>).</p>

<li><a name="fn-34"></a>
<p>If you can, why are you reading this -- you've already read
it!</p>

<li><a name="fn-35"></a>
<p>Whether they are documented or not.</p>

<li><a name="fn-36"></a>
<p>This information may also be filled in if the
<code>USEDEBUG</code> option or the <code>mpsym</code> command is used and supported,
and if debugging information about the call to <code>malloc()</code> is available.</p>

<li><a name="fn-37"></a>
<p>The error can be turned into a
warning with the <code>ALLOWOFLOW</code> option which will also force the operation
to be performed.</p>

<li><a name="fn-38"></a>
<p>On UNIX
systems with dynamic linking it might also be possible to run the program under
the <code>mpatrol</code> command with its <code>--dynamic</code> option without having
to recompile or relink, but compiling and linking with the mpatrol library is a
more generic solution across different platforms.</p>

<li><a name="fn-39"></a>
<p>This is not strictly necessary on UNIX and Windows
platforms (and AmigaOS when using <code>gcc</code>), but it does give us more
debugging information.</p>

<li><a name="fn-40"></a>
<p>Note that the start address of the allocation has changed
slightly since we added padding around it with the <code>OFLOWSIZE</code> option.</p>

<li><a name="fn-41"></a>
<p>This is really only necessary when the mpatrol
library has been built as a shared library.</p>

<li><a name="fn-42"></a>
<p>This is not necessarily the fault
of the debugger or the debugging information generated by the compiler since
on most platforms such watch points can only be caught after they occur, hence
most debuggers show the next statement to be executed rather than the current
one.</p>

<li><a name="fn-43"></a>
<p>The file <code>extra/magic</code> contains
a UNIX <em>magic</em> file excerpt for automatically identifying an mpatrol log
file, an mpatrol profiling output file and an mpatrol tracing output file with
the <code>file</code> command.</p>

<li><a name="fn-44"></a>
<p>There is currently a library called StackTrace written by
Bjorn Reese which invokes a debugger to generate a stack traceback on certain
UNIX platforms.  This method would be too slow for mpatrol to use though.</p>

<li><a name="fn-45"></a>
<p>Looking back at these statements about six months after they
were written, it would appear that I have just written such a library judging by
the number of architectures for which stack traversal is now supported.</p>

<li><a name="fn-46"></a>
<p>This list can be
considered to be a slightly more up to date version of <cite>Debugging Tools
for Dynamic Storage Allocation and Memory Management</cite>
(<a href="http://www.cs.colorado.edu/~zorn/MallocDebug.html">http://www.cs.colorado.edu/~zorn/MallocDebug.html</a>) by Ben Zorn
(<a href="mailto:zorn@microsoft.com">zorn@microsoft.com</a>).</p>

</ol><hr>

</body></html>

